{"2020/万历十五年":{"slug":"2020/万历十五年","filePath":"2020/万历十五年.md","title":"万历十五年","links":[],"tags":["书/划线笔记","书/历史"],"content":"第一章 万历皇帝\n大风起于青萍之末\n第二章 首辅申时行\n它所做的事，就是以抽象的原则，施用于实际问题，或者说把实际问题抽象化。\n本朝法令缺乏对具体问题评断是非的准则，即令有时对争执加以裁处，也只能引用经典中抽象道德的名目作为依据。\n皇帝以一人而君临天下，具有最高的权威，实因天意之所归。天意必须通过亿万臣民的信念而体现出来。皇帝和他的大臣，经常以庄严美观的形式举行各式各样的礼仪，又为巩固这种信念不可或缺。\n一项政策能否付诸实施，实施后或成或败，全看它与所有文官的共同习惯是否相安无扰，否则理论上的完美，仍不过是空中楼阁。\n施政的要诀，仍不外以抽象的方针为主，以道德为一切事业的根基。朝廷最大的任务是促进文官之间的互相信赖与和谐。此亦即鼓舞士气，发挥精神上的力量。\n个人的私心会随时随地变迁，只有伦理道德永恒不变。\n第三章 世间已无张居正\n皇帝也是人而并非神，即使他的意志被称为”圣旨”，也并不是他的判断真正高于常人。他的高于一切的、神秘的力量是传统所赋予，超过理智的范围，带有宗教性的色彩，这才使他成为决断人间的最大的权威。\n第四章 活着的祖宗\n由于成宪的不可更改，一个年轻皇帝没有能把自己创造能力在政治生活中充分使用，他的个性也无从发挥，反而被半信半疑地引导进这乌有之乡，充当了活着的祖宗。\n他朱翊钧生前有九五之尊，死后被称为神宗显皇帝，而几百年之后他带给人们最强烈的印象，仍然是命运的残酷。\n第五章 海瑞-古怪的模范官僚\n他的政治生涯，已经充分表示了为人臣者尽忠之不易；而他的家庭经历，也恰恰说明了为人子者尽孝的艰难。\n第六章 戚继光-孤独的将领\n在本质上无非是数不清的农村合并成的一个集合体，礼仪和道德代替了法律，对于违法的行为作掩饰则被认为忠厚识大体。\n现代化的技术和古老的社会组织断然不能相容，要不是新的技术推动社会组织趋于精确和严密，那就是松散的社会组织扼杀新的技术，二者必居其一。\n在抗倭战争中功绩最为卓著的戚继光不是在理想上把事情做得至善至美的将领，而是最能适应环境以发挥他的天才的将领。"},"2020/心流":{"slug":"2020/心流","filePath":"2020/心流.md","title":"心流","links":[],"tags":["书/划线笔记","书/心理学"],"content":"序一 自造内心秩序之途\n幸福不是人生主题，而是附带现象。幸福是你全身心地投入一桩事物，达到忘我\n的程度，并由此获得内心秩序和安宁时的状态。\n第一章 心流，快乐的源泉\n人何时最幸福\n只有在不计较好坏、全身心投入生活的每一个细节时，才会觉得幸福，直接去找\n反而不会奏效。\n真正能带来满足感的不是苗条或财富，而是肯定自己的人生。\n最优体验有赖于时时刻刻用意识控制周遭事物，而要达到这种境界，唯有靠个人\n的努力与创意。\n人类不满的根源\n最好不要期望任何改善外界环境的努力能立即提升生活品质。\n我们对自己的观感、从生活中得到的快乐，归根结底直接取决于心灵如何过滤与\n阐释日常体验。\n善用自己的体验\n弗洛伊德及其他心理学家指出，文明就是建立在压抑个人欲望基础上的。社会成\n员不论乐意与否，都被迫接受既定的习惯与技能，否则就不可能维持社会秩序和\n复杂的分工制度。\n我们应该了解，寻求快乐是基因为物种延续而设的一种即时反射，其目的非关个\n人利益。\n好的。如果我们不加诘问就服从基因和社会的控制，不啻就放弃了对意识的控制，\n成为非人性力量的玩物。\n剥削我们的精力以逞其私欲，使我们沦为社会制度的附庸。\n第三章 心流的构成要素\n幸福的假象\n纵然明知物质的丰裕并不能带来幸福，我们还是习惯外求，不停地追逐外在的目\n标，希望借此改善生活。\n构成心流体验的要素 &gt; 位置 1686\n冒险专家的乐趣并非来自危险本身，而是来自他们使危险降至最低的能力。真正\n令他们乐此不疲的，不是追逐危险的病态悚栗，而是一种有办法控制潜在危险的\n感觉。\n赌博的人往往自以为能未卜先知------至少在赌博的目标与规则下可以做到这一点，\n而这种不能自拔的控制幻觉，正是赌博最吸引人的地方。\n目标不假外求 &gt; 位置 1803\n在自成目标的活动中，一个人可以完全为行动本身而投入全部心力，否则他会把\n注意力集中到行动的结果上。\n第四章 如何在日常生活中寻找心流？\n自得其乐的性格\n一个人若时时都在担心别人对自己的看法，害怕给人留下不好的印象，或做出不\n妥当的事情，就注定与乐趣绝缘。\n以自我为中心的人无法变得更复杂，因为他把全部精神能量都用于实现眼前的目\n标，不肯去尝试新目标。\n虽然一般认为，注意力集中时会增加处理资讯的负担，但对于懂得如何控制意识\n的人而言，集中注意力反而更轻松，因为他们可以把其他不相关的资讯都抛在一\n旁。\n集中注意的能力与心流之间的关系十分明显，但仍需要做进一步的研究才能确定\n何者是因，何者是果。\n有助于产生最优体验的家庭环境具有五个特点：\n\n第一是”清晰”，青少年知道父母对自己的期望------在家人互动关系中，目标与\n回馈都毫不含糊。\n第二是”重视”，孩子觉得父母对他们目前所做的事、他们具体的感受与体验\n都有浓厚的兴趣，而不是一味巴望他们将来念一所好大学，或找一份高薪的\n工作。\n第三是”选择”，孩子觉得自己有很多选择，包括不听父母的话------只是他们得\n准备好自己承担后果。\n第四是”投入”，亦即让孩子有足够的信心，放开自卫的护盾和自我意识，全\n心全意去做他感兴趣的事。\n最后是”挑战”，也就是由父母为孩子安排复杂渐进的行动机会。\n\n第五章 感官之乐\n人值多少钱？\n如果任由身体感官萎缩，生活品质充其量只能勉强及格，有时甚至相当苦闷。但\n一个人一旦掌握了身体所能，学习为肉体感官建立秩序，精神熵的现象就会一扫\n而空，变为充满乐趣的和谐。\n心流不可能是纯体能的活动，肌肉和大脑必须参与才行。\n如果我们只为赶时髦或改善健康而参与，不见得会有什么乐趣。很多人陷入一种\n到头来无法自拔的体能活动中，把锻炼身体当成一种义务，一点儿也没有乐趣。\n这是一种常见的错误，形式与本质混淆不清，以为具体的行动与事件就是决定体\n验内容的唯一现实。这种人以为加入豪华健身俱乐部就是乐趣的保证，但我们早\n已说过，乐趣不在于你”做什么”，而在于你”怎么做”。\n视觉之乐\n不培养必需的技巧，就不可能在追求中找到真正的乐趣。\n第六章 思维之乐\n身体与心灵相辅相成\n文化分派给我们的社会角色负责塑造我们的心灵，我们通常也任由这套既定规则\n操纵，\n挖掘历史宝藏\n品质，由外界控制的知识也不能带来乐趣。\n业余与专业\n一旦业余者忘了这个目标，用知识来支撑自大，或取得物质利益，就变成了学者\n的拙劣模仿。\n在理想状况下，强迫教育的结束应该就是自动自发追求更高教育的开始。这时，\n学习的目标不再是分数、文凭或找份好工作，而是了解周遭的事物，从个人经验\n中发掘意义，建构价值观，思考者会从这里面找到深邃的乐趣。\n第七章 工作之乐\n工作与休闲\n谈起工作，一般人就忽略了理性的证据。他们无视当下的体验品质，一味坚持传\n统文化对工作根深蒂固的成见。他们认为工作是强加的限制，妨碍他们的自由，\n必须尽可能地逃避。\n工作上的冲突往往源自怕丢面子的自卫心理。有些人为了证明自己的价值，会设\n定目标，要求别人以某种方式对待他，并坚持别人按照他的理想行事。\n第八章 人际之乐\n一个人若不能忍受孤独，甚至从中发现乐趣，就很难完成需要全神贯注的任务。\n因此，我们有必要学习在没有外援时，仍能控制自己的意识。\n微妙的人际关系\n一个人之所以重要，并不仅仅是因为他能帮助我们实现目标；只有在我们因一个\n人本身的优点而重视他时，他才能成为最丰富的幸福泉源。\n寂寞之苦\n内在维持心灵的秩序十分困难。我们往往需要外在的目标、外来的刺激、外来的\n回馈，帮助我们控制注意力的方向。\n可预测的情节、熟悉的角色，甚至大量的广告，都提供一种令人安心的刺激模式。\n屏幕使注意力集中在一个容易处理的小范围之内，心灵跟电视互动，暂时可以不\n受个人的烦虑打扰。屏幕上掠过的资讯，会把不愉快的念头逐走。但用这种方式\n逃避沮丧，实在是一种浪费，因为徒然投下许多注意力，却得不到什么收获。\n艺术创作需要的是清醒的心灵。药物作用下完成的作品，经常缺少杰作应有的复\n杂性------它往往显得肤浅而自我陶醉。\n驯服孤独\n如果把孤独当作实现在人群中不可能实现的目标的机会，那么你不但不会觉得寂\n寞，反而会喜欢独处，而且从中学到新的技巧。\n一味追求逸乐的生活方式，只能跟建立在努力工作与乐趣之上的复杂文化共生。\n如果文化不能或不愿意再支持这批没有生产力的享乐主义者，他们就会变得无依\n无靠。\n天伦之乐\n孩子必须知道，父母对他们有某些期望，不听话就要面对特定的后果。但他们也\n该知道，不论发生什么事，父母对他们的关怀都不会改变。\n家庭成员之间的完全信赖、无条件接纳，只有在毫不吝惜投入注意力时才有意义，\n否则它不过是空洞的姿态与做作罢了。\n朋友之乐\n真正的朋友偶尔会陪我们疯狂一下，但他们不会期望我们一味任性到底；他们能\n与我们分享实现自我的目标，也愿意分担提升复杂性的风险。\n第九章 挫折中如何自得其乐？\n扭转悲剧\n我像一只刚孵出来的雏鸟，展开这场旅程，从此我就能自由地飞翔。每个人都应\n该了解自己，亲自体验生命的每个形式。我也可能还是在老家的床上呼呼大睡，\n或到镇上谋一份现成的工作，但我选择跟穷人在一起，因为每个人都必须受过苦\n才能成为一个真正的人。结婚、做爱，并不能让你成为男子汉；做男子汉就得负\n责，知道什么时候该说话、说些什么，什么时候又该保持沉默。\n化腐朽为神奇\n自我的完整取决于把中立或破坏性事件，转变为对自己有利状态的能力。\n为了成功，可以遵守一套并非出于自己选择的游戏规则，往往是强者必备的特征。\n第十章 追寻生命的意义\n下定决心\n我真的想做这件事吗？做这件事会有乐趣吗？在可预见的将来，我仍然能从中得\n到乐趣吗？我和其他人，必须为它付出的代价值得吗？完成这件事以后，我还会\n喜欢自己吗？\n重获内心和谐\n生活中不可避免的意外事故，都会使小孩儿痛苦，但小孩儿不会没来由地不快乐。\n很多人怀念童年时光，并非事出无因；"},"2020/李小龙—生活的艺术家":{"slug":"2020/李小龙—生活的艺术家","filePath":"2020/李小龙—生活的艺术家.md","title":"李小龙—生活的艺术家","links":[],"tags":["书/划线笔记","书/传记"],"content":"第一章 功夫之道\n\n习武者并不依凭他人的观点而生活。由于他们完全独立，所以不必担忧不被他\n人尊重。他们真正的追求在于不断地充实自我，他们的快乐之源不依赖于他人\n的外在评价。\n\n1.4 功夫的悟\n\n功夫修为越高，越趋于质朴无华。而越是境界不够的人，就越喜欢装饰自己。\n\n第二章 功夫入门\n\n你必须要接受的一点建议是，如果对手的攻击势如破竹，你就有必要先忘却疼\n痛------至少这时应该这样做。这不是放弃，而是让疼痛激励自己，作出反击，去\n获得胜利。记住这一点，被流氓恶棍袭击的时候，要想到他只会思考一样东西，\n那就是一心一意地要击垮你，打败你，他几乎不会考虑你会做出什么反应。如\n果你的行为出乎他的意料，他就会丧失一大半的自信。这会让他的袭击变得无\n力无效，在这种情况下，你就会占有心理优势\n\n2.4 刚柔并济\n\n动作真正的流动性在于其内部的交替性。\n\n第三章 截拳道之道\n\n\n重要的并不是一个人积累了多少墨守成规的知识，而是如何将这些知识灵活地\n运用到实际中。“实用”绝对比”招式”重要。\n\n\n进入一种模式而不受制于它，遵守规则，以达到从心所欲而不逾矩。\n\n\n3.2 截拳道：走向自我解放之道\n\n\n实战的”情形”是完整的，它包括那些在场的和不在场的因素。它没有偏好的线\n条、角度，不存在边界，总是充满活力和生命力。它并非一成不变，而是瞬息\n万变。\n\n\n生命并不意味着停滞、偏见和受限制的框架。生命是有节奏和无节奏的不断运\n动。生命也是不断变化的过程。\n\n\n3.3 截拳道的终极源泉\n\n\n忘记输赢，忘记光荣和痛苦：让对手抓破你的皮肤，而你还击以重拳。让对手\n还击以重拳，而你打断他的骨头；让对手打断你的骨头，而你要他的小命！不\n要想着安全地退却，义无反顾，视死如归。\n\n\n精神是控制我们生存的关键因素（我们无从知晓它的详细情况），它超越了肉\n体的境界，是一种整体的存在\n\n\n3.5 精湛的技艺\n\n心境宁静，胸有成竹，完全与自己的节奏和环境保持和谐。只有在此刻，人才\n能真正了解自己。\n\n第四章 哲学与功夫\n4.5 道家\n\n简单的生活平淡无奇，不在乎利益，不耍小聪明，没有自私，也没有欲望，涤\n除玄览。这就是”大成若缺”和”大盈若冲”的生活。这样的生活像光一样明亮，\n但并不晃眼。简而言之，这样的生活和谐统一，美满平静。它持久，带给人启\n迪、和平以及长久的生命。\n\n4.14 “我要的颜色”\n\n中国人放弃对真理的理性追寻，绝圣弃智，停止所有的心理活动，紧紧抓住自\n我意识，以获得精神上的收获。人就是简简单单的人。\n\n第五章 心理学与功夫\n\n真正的快乐是要实实在在地生活、有自己的立场观点、培养自己的兴趣、有健\n全的性格、放松自如。一点不错，确实如此。\n\n \n\n我认为，最富有、效率最高、最有创造力的人就是那种没有性格的人，这听起\n来是一种悖论，但却不一定是错的。在我们的社会里，我们总是要求一个人要\n有性格，特别是要有一个”优秀的”品格。因为那样的话，他做的任何事情就可\n以预测了。人们就可以将他分门别类，加以管理。\n\n5.5 胜利者和失败者\n\n我们对自己越没有信心，与自己、与整个世界的接触就越少，我们就越想控制\n他人。\n\n5.7 思考即是角色演练\n\n成熟是从依赖环境发展到自立的过程。不管神经质的孩子怎样运用他的潜能，\n他都不是为了自立，而是在扮演假的角色。这些假的角色只是为了调动依赖的\n环境，而不是调动他的潜能。在角色扮演中，人们用无依无助、装傻、求教、\n拍马屁等手段来操纵环境，结果是却遇到了问题的症结点或陷入僵局。\n\n5.8 学习过程\n\n对于任何事物都随意猜测，依靠从外界得到信息和帮助，这一切都不能让你变\n得成熟。\n\n5.11 赫塞论自我意志\n\n\n一个有自我意志的人除了追求自我发展以外，别无他求。他只在乎一件事情------\n自身的神秘力量，这可以帮助他生存和成长。\n\n\n当一个人对自己有信心时，他在世上追求的仅仅是，自由而单纯地完成命运赋\n予自身的使命。他认为，所有那些过分夸大其辞的东西和价格昂贵的东西，都\n是身外之物，拥有和利用它们或许是快乐的，但这些不是生命的本质所在。\n\n\n他一生中唯一追求就是无言的、不可否定的内心法则。\n\n\n第六章 武学手记\n6.2 笔记二\n\n\n生命没有答案，它需要用每时每刻来理解。我们所得到的答案，不可避免地遵\n从我们所熟悉的模式。\n\n\n不要把活生生的现实缩减为静止的东西，然后发明能阐明这类事物的各种方法。\n\n\n第七章 表演艺术\n7.4 一位演员的心声\n\n\n我应该对自己负责，做一个正直的人。剧本必须健康向上，导演也应该正派，\n表演的时候自己也应该全身心地投入到角色中去。所有这一切处理好了之后，\n赚钱也就是自然而然的事。\n\n\n所谓的”大明星”并不一定都是素质最优秀的演员。但现在麻烦的问题是，有许\n多人不是想做一名演员，而是想当明星。“明星”这个地位象征显得很天真幼稚，\n这样的明星只喜欢听到自己喜欢听的话，他们天真地认为，即使自己某一天突\n然成为一件无用的产品，也就是卖不出去的产品的时候，自己身后还会跟着一\n大批唯唯诺诺的”影迷”。\n&gt;&gt;\n在70年代就看到了这种现象，可惜的是这种想法越来越多，到今天就演变\n成了现在的流量明星\n\n\n第八章 自我发现\n8.2 自我发现过程（一）\n\n每日通过无偏见的观察去发现，全心全意尽力而为；坚持不懈的、偏执的敬业\n精神；最重要的是意识到对这些东西的追求是没有终点和界限的，因为生活是\n一种不断演进、不断更新的过程。我个人认为人的责任是：胸怀坦荡、踏踏实\n实、简简单单地做人。\n\n8.4 自我发现过程（三）\n\n问题在于有些人心中只有自我，而更多人心里是茫然的，因为他们整天忙忙碌\n碌，花费大量的精力把自己塑造成这样或那样的人。他们的一生致力于实现一\n个概念，就是他们应该是什么样的人，而不是实现一个人不断增长的潜能。\n\n8.10 充满激情的心境\n\n\n根植于我们内心的根本信念，我们缺乏一种绝对的信心。在无依无靠、孤立无\n援之时，往往会产生最强烈的不安全感。而当我们跟随众人趋之若鹜地模仿之\n时，我们就不会觉得孤单。这就是我们大多数人心里的想法，我们做人往往按\n照别人说的去做。我们主要通过造谣惑众的宣传来了解自己。\n\n\n行动对大多数人来说没什么困难，回报又十分丰厚。但人们很少自发性地采取\n行动，且要培养这种精神决非易事。\n\n\n我们每一天都需要重新证明自己的价值，证实我们存在的理由。无论出于什么\n原因，当自律的个体得不到自尊的时候，他很可能成为极其危险的炸药包。\n\n\n充满激情的追求过程中，追求的过程往往比追求的目标更重要\n\n\n对自己的控制就像转动保险柜上的一系列组合数字一样。转动保险柜上的按钮\n很少能一下子将门打开。每一次前进和退却都是通往最后目标的必要步骤。\n\n\n附录一\n李小龙诗歌译作\nDo you not see That you and I Are as the branches Of one tree? With your\nrejoicing， Comes my laughter; With your sadness Start my tears. Love，\nCould life be otherwise With you and me?\n附录二 书信\n\n\n良好的谋生手段有两种。一种是勤奋工作，另外一种是靠想象力（当然也是一\n件费劲的事）。事实上，劳动和节俭产生能力，但是幸福，比如说积累财富，\n则是要敢于想前人没有想过的事，这样才能获得报赏。在美国，每一个行业、\n每一个专业领域都注重创意。创意使美国变得与其他国家不同，同理，一个好\n的创意也会使人实现自己心中的梦想。\n\n\n珍珠，成功只属于那些想成功的人。如果你没有确立目标，那么，你如何能实\n现目标呢？\n\n\n境由心造\n如果你认为自己会败，你已败了。 如果你认为自己不敢，你已退缩了。\n如果你想赢，却又没有把握。 几乎可以断定你没有胜算。  \n如果你认为自己会输，你已输了。 四海宇内我们会发现，\n成功开始于人的坚强意志。 一切都是境由心造。  \n如果你认为人家超过了你，那就是这样， 要攀登高峰，你必须志存高远。\n只有对自己充满信心， 才能赢得胜利和嘉奖。   人生的搏击并非总是偏向\n那些人------更快或更强的人。 而更青睐于胜利者 勇于自信，敢于那样想的人。"},"2021/深度工作":{"slug":"2021/深度工作","filePath":"2021/深度工作.md","title":"深度工作","links":[],"tags":["书/划线笔记","书/效率"],"content":"所有者\n在这种新经济形势下，有三种人将获得特别的优势\n\n可以利用智能机器把工作做得漂亮并具有创造性的，\n在所处行业中最优秀的，\n还有那些拥有资本的。\n\n如何在新经济形势下成为赢家\n如果你不产出，就不会成功，不管你的技艺多么纯熟，天资多么聪颖。\n第2章 深度工作是少见的\n总结说来，当今商业世界的主要潮流大幅降低了人们深度工作的能力，尽管经论证这些潮流可期许的利益明显小于专注于深度工作所带来的利益。\n最小阻力原则\n最小阻力原则（The Principle of Least Resistance）：在工作环境下，若各种行为对于底线的影响没有得到明确的反馈意见，我们倾向于采用当下最简单易行的行为。\n对于很多人而言，这些例行会议是一种简单的（但同时也是笨拙的）人员管理形式。他们不愿自己去管理时间和工作任务，而是让每周迫近的例会迫使他们在给定项目上采取一些行动，或者提供一种取得进展的可视幻象。\n最小阻力原则受到度量黑洞的保护，少有人对其加以审视，在这种原则支配下的工作文化，免去了我们短期内对保持专注和做计划的忧虑，却牺牲了长期的满足感和真实价值的产出。这样一来，最小阻力原则就驱使我们在深度工作愈发受到青睐的经济形势下流于浮浅工作\n忙碌代表生产能力\n忙碌代表生产能力（Busyness as Proxy for Productivity）：在工作中，对于生产能力和价值没有明确的指标时，很多知识工作者都会采用工业时代关于生产能力的指标，以可视的方式完成很多事情。\n知识工作并非生产线，从信息中提取价值的行为往往并不忙碌，也并非靠忙碌支撑。\n对互联网的顶礼膜拜\n我们不再权衡新科技的利弊，不再平衡新增效益和新引入的问题之间的关系。我们开始自以为是地认定，只要是高科技就是好的，而不用再做探讨。\n第三章 深度工作是有意义的\n从神经学角度论证深度\n游手好闲是万恶之源’…当你失去关注点时，头脑不会想着生活中的好事，而会纠缠于生活中可能出现的问题。“从神经学角度来看，靠浮浅事务度过的一天很可能会是枯燥、令人沮丧的一天，即使抓住你注意力的浮浅事务看似无害甚至有趣。\n从哲学角度论证深度\n这种思想剥夺了世界的秩序和神圣感，而这种秩序和神圣感恰是创造生命意义所必需的。在后启蒙时代的世界里，我们为自己安排了一项任务，辨别何为有意义的，何为无意义的，这种做法很随意，恐会带来令人毛骨悚然的虚无主义。\n并非产出意义，而是培养内在技能，辨别本已存在的意义\n你不需要一种稀缺的工作，你需要的是用世间少有的方式完成工作。\n深度智人\n就像我们这个种群进化到一个阶段，在深度中繁荣，在浅薄中沉沦，成为一种可以称作”深度智人”（Homo Sapiens Deepensis）的物种。\n准则1 工作要深入\n选定你的深度哲学\n克努特采用的是我所谓的禁欲主义哲学的深度工作日程安排。这种哲学通过摒弃或最小化浮浅职责，从而实现深度工作的最大化\n将荣格这种方式称作双峰哲学的深度工作。这种哲学要求你将个人时间分成两块，将某一段明确的时间用于深度追求，余下的时间做其他所有事情。在深度时间里，双峰工作者会像禁欲主义者一般工作------追求高强度、无干扰的专注。在浮浅时间里，专注并非首要目标。\n节奏哲学。这种哲学认为轻松启动深度工作的最好方法就是将其转化成一种简单的常规习惯。换言之，其目标是创造一种工作节奏，让你不需要你投入精力便可以决定是否需要以及何时需要进入深度状态。链条法是节奏哲学深度工作日程安排的典型例子，因为这种方法结合了一种简单的启发式调度（每天都要做这项工作）和一种提醒你做这项工作的简单方法：日历上的大红X。\n只要有空闲时间，他就能立刻转入深度工作模式，苦心打磨他那本书。\n记者哲学的深度工作日程安排是很难办到的。如果你对自己从事的工作价值有足够的信心，实现深度工作的技能也足够熟练（我们将在后续策略中继续探究这种技能），记者哲学将是一种出乎寻常的好办法，能帮助你在紧密的日程安排中挤出大量的深度工作时间。\n习惯化\n\n你将在何处工作，工作时间多长。\n工作开始之后你将如何继续工作。\n你如何支持自己的工作。\n\n像经商一样执行\n找出实现某个目标的战略往往很简单，但是真正引领公司上行的反而是确定了战\n略之后该如何实施战略。\n\n原则1：关注点放到极端重要的事情上\n原则2：抓住引领性指标\n原则3：准备一个醒目的计分板\n原则4：定期问责\n\n准则2 拥抱无聊\n一旦你的大脑习惯了随时分心，即使在你想要专注的时候，也很难摆脱这种积习。\n准则3 远离社交媒体\n一个人的意志力是有限的，你的工具对你越有吸引力，你就越难在重要的事情上集中注意力。因此，要掌握深度工作的艺术，你必须摆脱各种各样的诱惑，重新掌控自己的时间和注意力。\n认识到这些工具并不完全是邪恶的，有些甚至对你的成功和幸福是十分重要的；然而与此同时，也意识到应该对那些能够经常占用你时间和注意力（更不要说个人信息）的网站设立一个严格的限制标准，大部分人应该更少地使用此类工具。\n如果你不努力权衡利弊，一看到可能的益处就决定不加限制地使用某种工具，那么你就可能在不知不觉中失掉了在知识工作世界里取得成功的能力。\n网络工具并没有那么特别，它们只是工具，并不异于铁匠的锤子或者是画家的刷子，只是熟练劳动力用来更好地完成工作的工具（并且偶尔能增添乐趣）。\n戒掉社交媒体\n我认为社交媒体大行其道的一个原因，就是它打破了努力创作有实际价值的作品和吸引到人们注意力之间的正相关关系。相反的，它用浅薄的集体主义式交换取代了永恒的资本主义交换：如果你注意我说了什么，我就会注意你说了什么，不管这话语有无价值。\n结论\n脱离思想不集中的大众，加入那些能集中精力的少数人群，我认为这是一个能让你脱胎换骨的转变。"},"2022/1927中执会告诫工人书":{"slug":"2022/1927中执会告诫工人书","filePath":"2022/1927中执会告诫工人书.md","title":"1927中执会告诫工人书","links":["2022/1927评中执会告诫工人书"],"tags":["Reference","政治经济/民国政治"],"content":"\n\n                  \n                  评论 \n                  \n                \n\n这是当年上海邮政工人罢工，国民党发表的批评文章，文章主要在于偷换概念，将工人被剥削的遭遇归结帝国主义的剥削，要反抗应该提升国力以消灭帝国主义的剥削，而不是本国资本主义的剥削，其中还有一句认为本国资本主义目前小到没有剥削，反倒是工人罢工导致资本破产，损害了资本与工人自己。其次把工人的处境于农民，士兵，失业者对比，比惨，把工人阶级于这些阶级对立，得出有人比你还惨，凭什么你不满足的逻辑，在这里资本的阶级又消失了，似乎国力增强只在于工人阶级努力，而资本阶级可以正大光明的窃取工人成果。最后把国家兴亡责任全归于工人阶级，确实，工人阶级的关乎国之存亡，但资本阶级就全无责任，工人罢工明明是分配问题，却被文章偷换为国家发展问题，并在此基础上指责工人不努力就是叛国。\n读下来，文章的逻辑确实与现今资本的嘴脸相同，公司发展了你们打工的就提升了，公司是 500 强，你们打工的就是 500 强打工人，不受其他公司剥削了，只受公司自己剥削，公司赚的多了，干死了别的公司，获得超额利润，分你们打工人的渣滓自然就多了。看你们比那些在街上送快递外卖的人好多了，凭什么不努力，凭什么不加班？\n以上是我的观点，另外当年《红旗》上发表了对该文的批驳文章，让我们看看当年的无产阶级革命者是如何批判这些逻辑的1927 评中执会告诫工人书\n\n\n\n\n                  \n                  录入信息 \n                  \n                \n\n录入者：吴季\n收录文献： 《政治：国民党的”民众运动”与工农学各界的斗争 1》\n录入时间：1928 年 10 月\n录入者按：这篇《告诫书》缘于上海邮务工人罢工事件，告诫范围则是全体中国工人（及工会），就像批评者说的：“没有半点改良主义”。“扶助农工”的虚文都丢在一边，只有训诫+恐吓，声称工人有业可就，有吃有住，比农民士兵失业者强多了，应该知足并努力生产，把蛋糕做大；公用事业的工人更不得采取”对资本主义的工业行为”，云云。至于群众的困苦，是帝国主义侵略及商品倾销所致，尚待国府解决。虽然态度不免粗暴，但行文挺高雅…\n此文的摘录散见于各报刊杂志，“以广周知”。标题各不相同。全文较少见，录自《政治：国民党的”民众运动”与工农学各界的斗争》一书，题为《国民党中央委员会禁止工人罢工的”告诫书”》。\n\n\n正文\n中国国民党依总理孙中山先生之三民主义与革命方略，努力奋斗。迄于今兹，既已扫平军阀，统一全国，开始训政，蕲求建设，方将总摄纲纪，利导国民，相与抚绥乱余，涤除浇伪，共向心理、社会、政治、物质四大建设之目标而前进。乃者，上海邮务工人不幸以不明自身地位及责任之故，猝起罢业，资奸人以流言，召社会之反感。以我政府进行收回邮权之中，扶植邮工组织之不易，方在萌芽，而妄试罢工行动，摘瓜抱蔓，实为可惜。中央念国家生产之落后，与工人组织之幼稚，不加苛责，而于此次罢业者生活之要求，有为邮政前途安全与一般经济现状所许者，由交通部负责与谋解决，毋使延累。惟一隅邮工罢业之错误，其事犹小，而一般工人运动缺乏正确之观念，实足为民族前途之隐忧。本党过去十数年军政时期中，革命工作，重在扫除国内之障碍，故于民众运动，唯在唤起全国人民共同救国之精神，与北方军阀奋斗。然两年以来，共产党则因乘利便，从而分析整个民族之革命力量，运农离农，运工离工，而酿成暴动反动，以致与国民革命为敌。人民初不察革命与反革命分野之所在，致令威虐肆扬，苛暴细民，焚掠所至，闾阎为墟。今则人人皆知共产党之凶残虐毒而深恶痛绝之矣。然犹末辩本党对于工人工会所持之原则为何若，即党员亦多茫然无所知，甚或瞑行妄作，以个人主义指挥工人团体，致工会既不属于工人，又不属于全党，更不属于国家。形式上指导工人团体，而遇事则往往发生离开党与国家利益之个人活动。由是党国之系统与权力不能确立，革命之主义，不能深入于人心，而人民对于革命，虽欲贡献其总合的能力，亦因之不能集合于党中以作有组织有步骤之三民主义的战斗。长此以往，不待革命之传统的敌人死灰复燃，而中国民族亦必无幸！须知国民革命，距完成之期望尚远，盖军阀虽已翦除，帝国主义之积患犹烈，人民喘息初定，而全民族之恫瘝实深。继今以往，本党负训政之大任，必当振起整个民族忍耐刻苦，勤俭沉毅，通力合作之精神，造成一颠扑不破百折不挠之伟力，以之解除国家之锁缚，发展经济之事业，然后大多数人民之生计，始有进步之可言。为欲求其有成，则必于过去党员实际工作之错误，予以纠正，于本党对于工人工会之原则，加以阐明。工人为建设中国民族经济新生命之主力，若不认清本身与国家相关之地位，及其在完成国民革命目的上应有之责任，唯知舍本逐末，因小误大，国家犹是覆巢，一己欲求完卵，万众未脱水火，一己欲登衽席，剜肉补疮，疮未补而肉已腐；则其结果非至使全国人民生计之根株皆绝不止。惟此义之不可以逾，而不可不剀切昌明，俾作教条，庶几全国工友，知所告勉。\n一、当知工友皆国民一份子，欲求个人之幸福，必先尽救国之任务。总理于民国十三年五月一日对全国工人曾有沉痛之遗训，谓中国工人地位之低落乃由于中国国家地位之低落，工人所受之苦痛，乃由于整个国家受各国帝国主义种种压迫所生之苦痛。盖一百年来，列强皆恃不平等条约剥削中国人民之权利。我国民为此等”卖身契”所東缚，无形中早已变为列强之奴隶，凡尽失其改革政治发展实业之能力与自由。辛亥革命，虽经多少先烈之肝脑涂地，推翻满清之专制，脱却一种之奴隶，然各种不平等条约尚未废除，即全国人之卖身契犹未收回。元年而后，军阀展转相承，吾人继续努力于国民革命与帝国主义之工具搏战，经数年来苦战恶斗之结果，全国工友已觉悟帝国主义之不可不并力驱除。徒以复受共产党人自私自利之诱惑，致使革命发生障碍，我国民之卖身契转得延长时效，而帝国主义亦得保持其将绝之寿命。今军阀既已驱除，此后之任务，厥为收回近百年来积留之卖身契，以解除我国民最后一重之奴隶。全国工友，须知一切不平等条约之存在，实使帝国主义扼锁我国之咽喉，管理我国之产业，垄断我国之金融，吸收我国之膏血，掠夺我国之治权。夫国家处此危亡之地位，则国民之地位，当然低落，工人之地位，乃更低落。故今日中国工人欲为自己争地位，若从自己地位设想，必愈争愈坏，必须从全体国民之地位设想，为国家争地位，始能愈争愈高。自今以后，必须人人下一卧薪尝胆、忍辱负重之决心，作出十年生聚十年教训之成绩，始能解脱国家之桎梏，抬高国家之地位。\n总理孙中山先生有言：“工人不但是对于自己团体之中有责任，在自己团体之外还有更大之责任。此种更重大之责任是什么呢？就是国民的责任，就是要担任抬高国家地位的责任。如果不能担任这个责任，诸君便要做外国的奴隶。若能够担任这个责任，把中国变成世界上头一等强国，诸君便是世界上头一等工人！“谚亦有言，“水涨船高，水落船低。“国家与人民之地位亦然。使国家之地位增高，工人之地位自然随之而高。中国受列强之压迫已至极点，工人如不以国家之利益为重，而欲独求自身利益之增进，必无是理。又使一国之人，农工商学，各顾其私，不念国家共同之利益，则其结果必如驶孤舟于大海，同舟之人，互相残害，非至同归陷落不止。故凡我工人，当知中国实如大海一孤舟，不可再以怠工罢工及其他阶级斗争之手段，破坏本国人民之产业与秩序，以自取覆亡。吾人于工商各种职业之任务外，实有救国救民之大任，国愈危，民愈弱，则此大任必随之加重。若处处但求满足一己之物欲，稍有不满，则不惜举社会国家之公利破坏之以泄愤，曾不思物欲未满而已不成其为中国人，且亦不成其为含灵负智之人类，此军阀官僚土豪劣绅守财奴辈所以为世诟病，而我全国工人所万万不可踵蹈之覆辙也。\n二、凡我工人，当知人类之所以能生存，民族之所以能绵续，社会之所以能进步，皆恃人人具有一个继往开来的精神。此种精神，即谚语所谓”前人种树后人乘凉”之精神，我皇炎远祖，本此精神以拓疆土，以建中国，使子子孙孙，绵绵延延，生于斯，长于斯，衣食于斯。则吾子孙当共守而勿替。我革命先烈亦唯本此精神以除旧恶，以造新命，则吾后死者当继此精神，以勉以教，以建千百年后中国民族之伟基。个人之生命不过数十年，而此数十年生命之价值，则唯有赖于为未来子孙造永久之福利而延长。吾侪工人，得吾民族远祖烈宗之遗传，既土广而物富\n天府之国利赖无穷，只须吾人秉刻苦勤劳之精神，合全国同胞所有之聪明才智，殊途合辙，以事生产，则人人之福利可立致，而工人未来之享受亦必无限。若不存刻苦勤劳之决心，忍现在之牺牲，谋未来之幸福，而妄思目前经济能力以外之享受，则结果唯有使目前一切皆陷于厄境，未来之福利无可期盼。甚至中国民族之子孙，亦遭绝灭。故凡我工友，必须切实猛省，不可贪目前之享受，而辜负从前祖宗创业之辛劳；尤不可贪目前逾量之需求，而妄却对于未来子孙之责任，此是人类生存，社会延续，文化继进之唯一关键，凡我工友急宜于此立定脚根，不可再受一般对时间空间而皆不负责任者之诱惑！\n三、中国工人，当深切明瞭国家现在经济之现状，而与全国上下共谋正当之解决。总理有言：中国之经济现状，实是全国皆穷。穷之最大原因，厥为各国帝国主义以不平等条约加诸我国，而外国资本家则复凭藉不平等条约，以吸尽我国之经济的命脉。五年以前，各国以舶来品剥削我国之金钱，每年五万万，而今亦必倍之。故只以经济而言，中国人民实全体备受列强帝国主义与资本家之压迫，无或幸免。加以中国机器生产落后，迄今尚无与外国相等之大资本家与压迫工人之现象。吾人之所最痛心戚首者，唯外国帝国主义之压迫与外国资本主义之剥削。至于本国，则尚无何种强大之资本家足以压迫我工人。就年来之工潮事实言之，反而小实业受工人之压迫，小工厂为工潮所摧毁，而其终极，则复转使小实业之工人，流离失所，造成工人之压迫人者，转而压迫自己之恶现象。以此可知在生产未发达之国家，施用怠工罢工种种阶级斗争之方法于工人，其弊不独败坏社会之生计，抑且增加工人自身之痛苦。我工友切尝自身所受之经验，洞察国家经济之情况，当知解决工人生计问题，与解决国家经济问题，二者实有同一之利害，应本同一之原则。原则维何？即增加生产是也。盖外国货品充斥于我国中，吸收我国人民之膏髓，则我国人民唯有制造本国货品以抵制之，始能保障吾人之膏血。外国资本雄厚，以其大规模生产压迫我中国，且以其大银行之纸币压倒我国之金融与财政，则我国人民唯有勤劳节俭，提倡积蓄，将国民自己之积资，投诸国家大生产事业，以发展交通，开辟富源，始足以排除外国之资本主义及其货币之侵略。总而言之，我国民今后救国自救之道，只有全国上下共同努力于”增加生产”四字，乃为根本之图。欲求增加生产，国家则宜取消不平等条约，收回海关，保护实业，鼓励储蓄，制定劳动法。而工人则宜增加一己之技术与能力，养成勤俭耐劳之习惯，使工作之效能增多，然后生产额因之而增多。如是，则国家富力始能勃兴，工人生计亦自能充裕，较之在大贫小贫之社会中求不彻底之生活解决者迥不侔矣。\n四、全国工友，当知目前工人之生活已有较其他职业界中人之生活为优裕者。中国为一患贫之国家，固已尽人皆知。吾人试一反省：中国人民大多数为农民，而农民之生活，则披星戴月，整日勤劳，刻苦操作，寒暑无间；加以我国科学落后，农具不良，耕种方法，简陋不堪，以致生产状况，毫无进步，又况农乡组织未备，政治不宁，匪祸遍地，偶有天灾，益增其苦。幸而勤劳有获，则纳赋偿债，犹恐不足，此农民之贫苦也！其次，则为士兵之生活，饷银既少，忍饥耐寒，为国服务，平时训练操作，日必在十数小时以上，一旦有事，则呼吸存亡不能自主，幸得生还，亦且断肢折股，缪为废人，此士兵之牺牲也。又其次，则为一般失业者之生活，室无积储，独身漂泊，到处既无可寻之工，几何不易沦为饥殍之鬼。此又一般失业细民之厄运也。是故举目一衡，全国大多数人之苦况，工人之生活，其贫苦不如农民，其牺牲不如士兵，其凄惨不如一般失业之众庶。以一般社会之情形如此，而工人岂尚不满于日有定业、夜有定所之生活，反欲向全国大多数穷苦达于极点之同胞以求增益乎？有人心者必不出此也。兹且竭诚以告我全国工友曰：国民今日救穷之责任，当先救其所急，而徐谋其可缓。本党深信此后之天职，在于努力奠定社会之安宁，消除一切害民之伏莽，同时，以国家现有之能力，开发实业，为民造产，使农民得所增益，失业者得所归宿，而一切流亡废疾者，庶有救死扶伤之望。我全国工友，当于此时作平心静气之自省，宜如何以有余之力量，尽同类相爱之情，协助政府，恪守秩序，努力国家社会之建设，以昭苏大多数同胞？如其不顾全国人民之生活为何若，误信共产党人”阶级意识”之莠言，则一阶级生，而全国大多数之同胞死，一阶级存，而全中国民族之生机绝，未见何阶级果能独存也。\n五、抑我国工友所当知者，中国民族之生路，舍坚信孙中山先生之遗教末由，工人之生路，尤其舍坚信孙中山先生之遗教末由。孙先生之遗教，乃整个中国民族由建国以进于大同之唯一大道，广而言之，则须人人朝夕研求而不能尽，扼要举之，即吾人必须唤起全国人之救民救国之精神，团结于三民主义之理论与方略之下，以求全民族之独立生存，建设全民族之政治秩序，发展全民族之经济事业。本党今后，必须提挈全国人民，运用强国之政权，制定良善之法律，本建国大纲建国方略之计划，以全力为国民建设工作之后盾，而达人尽其才，地尽其利，物尽其用，货畅其流之目的。在本党向此目的进行期间，政府必须使之有负荷建设之能力，法令规章，必须使之能保障国民生活之稳固与安宁；绝不使任何部分人民遭受遗亡或偏视。维我工友，当知政府在此建设之时期间，凡铁道、邮政、电\n机及其他交通事业，乃至各省地方政府经营之基本工业，皆为国家之公用事业。凡在公用事业作工之工人，即为国家服务人员，其地位则优良，其责任则重大，万不可自等于寻常自私自利之辈，叫人诱惑，以蹈怠工罢工之歧路。须知所谓公用事业者，非个人资本主义之事业，不得以对付个人资本主义之手段与方法对付之。反是者，即谓之背弃国民之义务，反抗政府，反叛国家。详言之，公用事业，乃合于民生主义之事业，其作用，在于供给人民全体之需求；其关系，在于维持人民全体之安宁，其目的，在于增进整个社会之福利，而万万不得以对资本主义的工业行为之行动以对待之。反是者，即谓之反人民、反社会，而其结果则必受社会严格之制裁。明此二义，则知政府对于公用事业工人之处置，无论采用任何方式，均为国家治权所许，而为适应社会要求与人民需要之正当行为。\n呜呼！我国民数十年来遗大投艰，苦战恶斗，至今已稍见民国前途一线之光明，后此之责任，视以往为重大；而其艰难，必且过之，维我工友，于确实了解以上各条意义之余，当念及民族生存竞争之不易，人人应以知耻雪耻之精神，起三民主义之信仰，依本党之指导，为政府之后盾，作建设之前驱：必当企求工业技术之娴熟，生产效能之增高，与企业组织之完备。然后国家生产始能期其发展，而使中国得与帝国主义决未来百年之胜负，为中国民族雪已往百年之耻辱。我全国工人，其深念之！\n中国国民党中央执行委员会\n中华民国十七年十月十八日\n[国民党中央执行委员会秘书处档案]"},"2022/1927评中执会告诫工人书":{"slug":"2022/1927评中执会告诫工人书","filePath":"2022/1927评中执会告诫工人书.md","title":"1927评中执会告诫工人书","links":["2022/1927中执会告诫工人书"],"tags":["Reference","政治经济/民国政治"],"content":"\n\n                  \n                  评论 \n                  \n                \n\n这是对1927中执会告诫工人书的回应，和我读完之后的感想很像，对当今也有现实意义，我们应该如何认识现今互联网行业盛行的 996，如何看待马云，刘强东对超时加班的辩护，都可以从这里面找到启发。\n\n\n\n\n                  \n                  录入信息 \n                  \n                \n\n录入者：吴季\n录入时间：1928 年 11 月\n录入者按：此文是当时《红旗》杂志的批驳文章（所批的《告诫书》全文本次已一同发布），颇为有力，毫无阶级调和的内容。可惜这种”政治正确”被用来服务于大革命失败后的盲动…而后来的党领袖们在批判这时期的盲动的同时，把这些”政治正确”的内容也顺带批判掉了，从而得出事实上的结论：马克思主义很好，但是”不要盲目照搬”，阶级斗争”过火了”，更加不行。）\n\n\n正文\n登贤\n现时工人阶级斗争日趋剧烈，无论是代表豪绅地主的或代表资产阶级的国民党都感觉异常的不安，虽然他们的政策并不一致。蒋介石方面，有所谓合法运动的宣言。宣言的内容主要的是，工人罢工，要得党部政府的许可，如果工人遵照这个原则，蒋介石说，我们国民党可以同情与援助。呵！工人罢工要得资产阶级的许可，不是与虎谋皮吗？这是代表资产阶级说的话，非常好听，但是完全欺骗的。\n豪绅地主现在站在于在朝领导的地位，自然又是另一种面目。“中执会告诫全国工会工人书”，就是他们的宣言。这个告诫书的内容，不但没有半点改良主义的宣传，完全是复古的彻底反革命的文章。\n在第一段说：“工人所受的痛苦乃由整个国家受各国帝国主义种种压迫所生之痛苦”。\n原来工人所受的痛苦，完全与国民党无关，真是洗脱得干净！从国民党背叛革命以后，我们到处都见：封闭工会；捕杀工人及其领袖，不断施行历史所未有的白色恐怖，工人在”共产时代”斗争得来的一切条件均下令取消无效，甚至在铁路兵工厂…等作工，不准工人谈话，并且武装监视与检查工人；言论集会结社罢工一切自由全被剥削净尽；无穷的苛捐杂税，工人的负担日益繁重。北伐成功了，工人得到什么？只有在长期反动统治下苦痛呻吟！一切的一切，不是国民党压迫屠杀工人阶级的事实吗？只有卖阶级的七大工会的领袖们才会认贼作父！工友们的眼睛到底掩盖不住的！固然，工人阶级的革命任务，必须要推翻帝国主义的统治，没收其在华一切财产，才能从帝国主义的政治经济侵略之下解放出来。但是要彻底打倒帝国主义，必须同时推翻豪绅资产阶级国民党的政权。国民党是帝国主义的忠实奴仆，屠杀群众的刽子手。工人阶级在过去的反帝运动，都受国民党的摧残与压迫。这数年来，由”五卅”至”五三”的反帝运动，都是国民党无耻投降帝国主义，镇压革命群众的直接反帝运动。\n那告诫书上第一段又说：“工人如不以国家之利益为重，而求自己利益之增进，必无是理。…若处处但求满足一己之物欲，稍有不满，则不惜举社会国家之公共利益破坏之以泄愤，曾不思物欲未满，而已不成其为中国人，且亦不成其为含灵负智之人类”。\n呵！什么是国民党的”国家利益”？这无异说工人的生活无论怎样痛苦，可不要出声，好好地更加努力做工，最好连饭也不食，更不要问工资多少。等中国变成资本主义的国家，国民党的反革命政权巩固后，工人的生活也自然会好的。否则，要提出条件，罢工斗争，就是破坏公共利益。（即是资本家的利益），就不成为中国人，更不是人类。我国民党为保卫资本家的安宁必要制裁的，要枪毙的。工友们！看呵！你们要求条件，就不是中国人，更不是人类了。大概国民党天天增加苛捐杂税，屠杀革命群众，封闭工会，才算天人呢！\n第二段说：“社会之所以进步，皆恃人人具有一个继往的精神。“要”存刻苦的决心，忍现在之牺牲谋未来的幸福”。更”不可贪目前之享受，而辜负从前祖宗创业之辛劳”。\n真难为了他说得出口！工人阶级不能维持最低限度的生活，一切自由都被剥夺，资本家日益激烈进攻，开除工人，减少工资，增加工作时间，成为资本家的家常便饭。工人阶级无日不在失业与不能过活的恐慌中。但是，国民党却叫工人”不可贪目前之享受，而辜负从前祖宗创业之辛劳”，“忍现在的牺牲，以谋将来的幸福”。这是什么意思？不外要工人阶级对此比牛马不如的生活好好地容忍着，因为你们的祖宗比你们更苦，他所创下来的痛苦生活，不要将他抛弃，应继续祖宗创业的辛劳，不可辜负祖宗的遗产！永远做资产阶级的奴隶，不可反抗。这是你们（工人）应当明白，千万怪资本家不得。因为你们的祖宗本已如此，而你们现在最要紧的是”继往之精神”，还是如此罢！工人阶级目前的痛苦，他认为是你们祖宗的创业呵！\n第三段说：“至于本国，则尚无何种强大的资本家足以压迫工人。就两年来之工潮言之，反而小实业受工人之压迫，小工厂为工潮所摧毁，造成工人之压迫者”。所以”解决工人生计问题，即增加生产是也。救国与自救之道，只有上下共同努力于增加生产，而工人…养成勤俭耐劳之习惯…然后生产额因之增加”。\n国民党只见工人压迫资本家，但我们却到处看见任意开除工人，减薪加时，在国民党掩护之下推翻一切工人拚死命争来的条件。关厂拒绝工人工作，工人做工要店铺担保，店员出入都不能自由…。不知这些是工人压迫资本家呢，抑还是资本家压迫工人？他说中国没有强大的资本家足以压迫工人，大概还嫌现在的压迫仍不够，并不利害，所以要做出些足以压迫工人的大资本家来。然而你们说没有强大的资本家也是该死，应该遵照并非资本家的冯少山的意旨：“至于资本家云者，此乃共产党分裂…乃有斯不祥之名，似非可出诸我党之口”，来下一个训令，说中国完全没有半个资本家，岂不更好么？\n再说到小工厂为工潮所摧毁一层，我们只见各地反苛捐杂税的运动（资产阶级全国商民临时代表大会的呈文），最近芜湖商民的罢市，军阀混战中的摧残，水陆交通的重征与梗塞，盗匪抢劫，官吏搜刮…，这些事实聋子亦能听闻，瞎子也可见着，国民党乃委之于工人阶级身上，企图掩蔽自己滔天的罪恶。并且更进一步要工人替资本家”增加生产”。工人每天应做十八小时工作，自动请求减轻工钱，或者简直可以不要工钱，这样才合乎国民党的”训政时期的建设”大计呵！\n第四段说：“目前工人之生活已有较其他职业界中人之生活为优裕者。试一反省，农民戴星披月，…幸而勤劳有获，则田赋偿债犹恐不足。…士兵忍饥忍寒…幸得生还，亦且断肢折股，僇为废人。…失业者…几何不沦为饿莩之鬼。…工人之生活，其贫苦不如农民，其牺牲不如士兵，其凄惨不如一般失业之众庶。以一般社会之情形如此，而工人岂尚不满于日有定业，夜有定所之生活，…有人心者必不出此也”。工友们！你们的生活真好极了！至少要比”纳赋偿债犹恐不足”的农民，“断肢折股僇为废人”的士兵，“沦为饿莩之鬼”的失业者好得多了。总之，在你们还没有荷包内的钱不够纳税，没有僇为废人，没有沦为饿莩之前，还应该替资本家做工，努力增加生产；总之，你们还没有完全断气之前，是反对不得资本家的，等到你们断了三寸气，装入四块板的时候，要反对也来不及了！所以资本家可以无愁无虑的享福！不过国民党还没有说出资本家豪绅地主的生活怎样，也许比工人亦不如了罢？否则，为什么要工人替他们增加生产呢？然而他不说，却抬出要死不得的农民，断肢折股的士兵，沦为饿莩的失业者来，反映工人是如何地得意！国民党果然聪明！可是工人如果联合农民土兵失业者一齐起来革你的狗命时，你又拿出什么东西来抵挡呢？\n第五段说：“当知政府建设之时期间…凡在公用事业做工之工人，即为国家服务之人员…听人诱惑，以蹈怠工罢工之歧路…即谓之背弃国民之义务，反抗政府，反叛国家。详言之，公用事业乃合于民生主义之事业…以对付资本主义的工业行为之行动以对待之…即反人民，反社会…必受社会严格之制裁。…政府对于公用事业工人之处置，无论任何方式，均为国家政府权所许”。\n这简直是宣布工友们的死刑书！所谓任何方式，自然包含捕拿监禁枪毙砍头腰斩各种方式在内，而且又为国家政权所许，而我们工人所犯的罪又是反人民，反社会。总之，比什么罪恶都利害。不图工友们为家庭为衣食而要求加薪，因和平要求不遂而罢工，乃有这么许多了不得的罪状！记得当打刘震寰、杨希闵时，广九、广三、粤汉三路工人同时罢工，欢喜得国民党眉开眼笑，下令褒奖。岂知到国民党得了政权，工友们肚子饿要食饭的时候，动一动就要砍头！\n就全篇来说，这个”告诫书”的内容，完全是豪绅地主更反动的表现。用一万倍的显微镜也不照出半点改良主义的影子。这个”告诫书”发出以后，全国商民临时代表大会首先决议拥护，并要求国民党政府坚决的来执行。工友们！你们也拥护这”告诫书”么？\n全国的工友们！国民党现在要拿”训政时期”四个字，又来再演斩杀的把戏了。反抗国民党的白色恐怖和资本家的进攻，是群众目前最迫切的要求与任务。比较落后的北方的群众也开始抬头了。\n工人阶级最后的出路，只有用武装暴动推翻豪绅资产阶级的统治，建立工农兵代表会------苏维埃，才能获得一切的自由！\n（原载《红旗》第 2 期，1928 年 11 月 27 日出版）\n《中国工运史料》1982 年第 3 期总 20 期。中华全国总工会中国工人运动史研究室编，工人出版社 1982 年 12 月第 1 版"},"2022/Applicative":{"slug":"2022/Applicative","filePath":"2022/Applicative.md","title":"Applicative","links":["2022/Functor","2022/Monad"],"tags":["Programming/Haskell","Programming/Typeclass"],"content":"应用函子（Applicative） 是函子的子类型，虽然可以使用应用函子来定义函子。应用函子是介于 Functor 和 Monad 之间的抽象。函子的 fmap 提供的功能是将 a -&gt; b 的函数 f 升格为 f a -&gt; f b ，而应用函子的功能是将包含在盒子中的函数 f (a -&gt; b) 应用到同样装在盒子中的参数之上 f a。\n应用函子的 Haskell 定义\nclass Functor f =&gt; Applicative f where\npure :: a -&gt; f a\n \ninfixl 4 &lt;*&gt;, *&gt;, &lt;*\n \n(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b\n \n(*&gt;) :: f a -&gt; f b -&gt; f b\na1 *&gt; a2 = (id &lt;$ a1) &lt;*&gt; a2\n \n(&lt;*) :: f a -&gt; f b -&gt; f a\n(&lt;*) = liftA2 const\n\n\npure 函数表示接受一个参数，并把它放入到一个不影响计算语义的盒子中去，可以理解为为参数添加最小上文 (minimum context) ，虽然看起来添加最小上下文的解释有点模糊，但因为本身 Applicative 需要满足四个条件，一般的实现中几乎都只有一种实现可以满足所有限制。\n\n\n(&lt;*&gt;) 是 Applicative 的核心函数，它接受一个已经升格的函数，将函数应用到同样升格的参数上，并且返回升格之后的计算结果。\n\n\n值得注意的是，函数 (*&gt;), (&lt;*) 看起来像是将右边或者左边的参数直接扔掉了，但实际这样的理解是不对的，实际上，函数将尖括号指向的盒子的内容重新打包到了另一个参数的盒子中，所以盒子的形状（上下文）由一个参数决定，内容由另一个参数决定。举个例子：\n\n\n Prelude&gt; [1, 2] \\*&gt; [1, 2, 3]\n [1, 2, 3, 1, 2, 3]\n应用函子应当满足的条件\n\n单位律 (identity)\n\npure id &lt;*&gt; v = v\n\n同态律 (homomorphism)\n\npure f &lt;*&gt; pure x = pure (f x)\n在没有任何副作用的盒子 pure 的包装下，用盒子计算的结果应该和不用没有盒子的计算之后再放入盒子相同。\n\n交换律 (interchange)\n\nu &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u\n将一个有状态的函数应用到一个无状态的参数时，不管是先应用函数，还是先计算参数再应用函数，最终的结果应该相同。\n\n结合律 (composition)\n\nu &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w\n使用应用函子来定义函子\nfmap g x = pure g &lt;*&gt; x\ng &lt;$&gt; x = pure g &lt;*&gt; x\n从定义可以看出来函子的 fmap 其实做了两步事情，第一步将函数 g 放入一个没有状态的盒子中，第二步将得到的带盒子的函数应用到带盒子的参数之上。\n应用函子的实例\n基本上标准库中所有的函子(Functor) 都是应用函子，以 Maybe 函子为例我们来实现它的应用函子。\ninstance Applicative Maybe where\npure :: a -&gt; Maybe a\npure = Just\n \n(&lt;*&gt;) :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b\n(Just f) &lt;*&gt; (Just x) = Just $ f x\n_ &lt;*&gt; _ = Nothing\n对于类型 [] 我们有两种方式来实现其应用函子，取决于我们如何理解列表中的元素。具体的实现参考这里。\n\n将列表看作是某种元素的集合\n将列表看作一个包含了多个未确定的计算过程的环境（标准库中的实现采用的是这个理解）\n"},"2022/Const-Functor":{"slug":"2022/Const-Functor","filePath":"2022/Const Functor.md","title":"Const Functor","links":["2022/Identity-Functor","2022/Functor"],"tags":["Programming/Haskell"],"content":"newtype Const a b = Const { getConst :: a }\n \ninstance Functor (Const a) where\nfmap f c = c\n同 Identity Functor 一样 , (Const a) 也是一个 Functor 的实例。不同的是 Const a 这个盒子中存在一个幻影类型 b 。代表了盒子抽象的另一个极 端，是个什么都没有装的盒子。盒子中 Const a b 的类型 b{.verbatim} 可以通过 fmap 被转换为任何其它类型 c 。因为我们并不关心盒子当中存的是什么。"},"2022/Emacs-Plugin---Paredit":{"slug":"2022/Emacs-Plugin---Paredit","filePath":"2022/Emacs Plugin - Paredit.md","title":"Emacs Plugin - Paredit","links":[],"tags":["Software/Editor/Emacs"],"content":"Paredit is a package that help you write lisp-like language. It helps you keep the parentheses balanced in writing code, that is said, you can not delete the ) without delete the paired ( in front. When enable it’s hard to mess your code with only unbalanced S-exp, so it is a very helpful tool for writing lisp-like code.\nparedit vs smartparens\nSmartparens is a newer package that provides more function than paredit, it works more like a modern code editor. and there are more activities in development, but both package are very stable, and the function is limited, so it is okay they are not developed for a period of time. The major reason I choose paredit is that it is a very small package and provides the most useful function to help me in writing lisp. It follows the UNIX philosophy: Do one thing and do it well. The smartparens is much bigger than paredit, it aims to provide more usage in other coding languages, somehow I find it useless even in coding lisp in the end.\nMost usefull command\nI change some most often used keybinding in my config.\nSplice sexp\n: M-&lt;up&gt; binding to paredit-splice-sexp which original binded to M-s.\n(foo (bar| baz) quux)\n---&gt;\n(foo bar| baz quux)\nWrap sexp\n: M-&lt;down&gt; binding to paredit-wrap-round which original binded to M-(.\n(foo |bar baz)\n---&gt;\n(foo (|bar) baz)\nBarfage &amp;&amp; Slurpage\n: They are two paired action, one group working forward, one group working backward. but group by direction always confused me when editing, so I change the binding and group them in action. C for slurage, and C-M for barfage. and my intuition of the action movement is base on the position changes of ) or (, so the\nSlurpage forward\n: C-&lt;right&gt; binding to paredit-forward-slurp-sexp.\n(foo (bar |baz) quux zot)\n---&gt;\n(foo (bar |baz quux) zot)\n \n(a b ((c| d)) e f)\n---&gt;\n(a b ((c| d) e) f)\nSlurpage backward\n: C-&lt;left&gt; binding to paredit-backward-slurp-sexp which original binded to C-M-&lt;left&gt;.\n(foo bar (baz| quux) zot)\n---&gt;\n(foo (bar baz| quux) zot)\n \n(a b ((c| d)) e f)\n---&gt;\n(a (b (c| d)) e f)\nBarfage forward\n: M-&lt;right&gt; binding to paredit-forward-barf-sexp, notice: the movement of ) is reversed to the fuction name, it move backward, the same as pressed arrow key. Original binded to C-&lt;left&gt;.\n(foo (bar |baz quux) zot)\n---&gt;\n(foo (bar |baz) quux zot)\nBarfage backward\n: M-&lt;left&gt; binding to paredit-backward-barf-sexp.\n(foo (bar baz |quux) zot)\n---&gt;\n(foo bar (baz |quux) zot)"},"2022/Golang-Empty-Interface":{"slug":"2022/Golang-Empty-Interface","filePath":"2022/Golang Empty Interface.md","title":"Golang Empty Interface","links":[],"tags":["Programming/Golang"],"content":"Golang 中有一个表面上看起来很奇怪的的问题，如下的代码中的函数会始终返回一个不等于 nil 的 error.\nfunc returnsError() error {\n\tvar p *MyError = nil\n\tif bad() {\n\t\tp = ErrBad\n\t}\n\treturn p // Will always return a non-nil error.\n}\n \nfunc main() {\n\tif err = returnsError(); err != nil {\n\t\t// Will always print\n\t\tfmt.Println(&quot;ERROR&quot;)\n\t}\n}\n要解释这个问题的原因，我们需要了解 Golang 中 interface 的内部实现。对于 interface 的实例 Golang 内部分为两个实现，iface 与 eface, 对应的代码在 runtime/runtime2.go 中。\ntype iface struct {\n\ttab  *itab\n\tdata unsafe.Pointer\n}\n \ntype eface struct {\n\t_type *_type\n\tdata  unsafe.Pointer\n}\n\neface 用于表示没有方法的空接口（ empty interface ）类型变量，即 interface{} 类型的变量。\niface 用于表示其余拥有方法的接口类型变量。\n\n我们可以理解为 interface 的内部实现中包含两个字段 (T, V) ,只有当 T 和 V 同时为 nil 时 (T=nil, v=nil) ，才能被判断为与 nil 相等。\n在上面的例子中 var p *MyError = nil 相当于 var p *MyError = &amp;MyError(nil) ，p 被初始化为了 (T=*MyError, V=nil) 的内部表示，所以始终不等于 nil 。所以对于声明为 AnyNonEmptyInterfaceType 的变量来说，始终会被初始化为非 nil 。而对声明为 interface{} 的变量来说，p interface{} = nil 的情况下，可以被判断为 nil。\n所以 Golang 建议在所有有返回 error 的函数声明中都使用 error 类型来作 为函数的签名，如下：\nfunc returnError() error {} // good\nfunc returnError1() *MyError {} // bad\nGolang 官方 FAQ 中对于该问题的解释 Golang FAQ 。"},"2022/Haskell-Programming-Language":{"slug":"2022/Haskell-Programming-Language","filePath":"2022/Haskell Programming Language.md","title":"Haskell Programming Language","links":[],"tags":["Programming/Haskell"],"content":"Haskell is a general-purpose, statically-typed, purely functional programming language with type inference and lazy evaluation. Designed for teaching, research and industrial application, Haskell has pioneered a number of advanced programming language features such as type classes, which enable type-safe operator overloading. Haskell’s main implementation is the Glasgow Haskell Compiler (GHC). It is named after logician Haskell Curry.\n\nWiki: haskell wiki\nWebsite: haskell.org\nGithub Repos: haskell group\n\nToolchains\n\nInstallation management ghcup\nThe compiler implemention ghc\nThe package/build system cabal-install, hackage\nThe toolchain manage: stack\n\nWhat’s the differnce between cabal-install, stack\n\nCabal is a sepcification for defining how Haskell\napplication and libraries should be built, defining denpendencies,\netc.\n.cabalis the file format used to write down te\naforementioned definitions for sepcific package.\ncabal-install stackboth implemented with\nCaballibrary, they are the frontend of\nCabal, but has different strategy to resolve\ndependencies.\ncabal-install using an approach called as “Nix-style local  builds”.\nstack use resolver to find the proper  package, with snapshot, which is a subset of Hackage packages with fixed versions.\nBesides, stack aims at providing a complete build  environment, with features such as GHC installation and Docker integration.\nDiscussions online.\nSee. haskell discourse\nSee. stackoverflow question\nSee. github gist\n"},"2022/How-to-Read---Luhmann":{"slug":"2022/How-to-Read---Luhmann","filePath":"2022/How to Read - Luhmann.md","title":"How to Read - Luhmann","links":["2022/卡片笔记"],"tags":["Reference","Zettelkasten"],"content":"这是卡片笔记的发明人 Niklas Luhmann 一篇关于应该如何阅读的文章中的内容。\n我们阅读的内容可以大致分为三类，诗歌、叙事、理论。文章主要讨论如何阅读理论型的文章。但在讨论如何阅读之前，我们先解释三类文章有什么不同。\n对于叙事型的文章，如小说，科幻文章，文章要求读者不断的回溯已经读过的内容，未来的内容都建立在读者已知过去文字的内容的基础之上，读者不断的被给予他应该还未知的内容。\n对于诗歌来说，一般来说诗歌不是一行一行的读到结尾。读者需要充足的短期记忆和多层次的推理能来理解诗歌中的音律元素，不常用的词汇，隐藏在表义之下，通过反义词，比较手法和不同韵律来表现的深意。\n对于理论性的文章，除去一些专业的数学逻辑符号，都是通过普通语言撰写，对于撰写文章的作者来说，为了表述某一种概念，他可能有许多中词汇可以选择，但如何选择合适的词汇来表达存在着巨大的随机性，造成文章中可能出现不同的词汇表现相同的概念的问题，即使作者在写作的时候十分小心的用同样的词汇来强调同一概念，也会因为这种一致性的词汇太少而很难让读者分清哪些是真正重要的概念，哪些是一大堆意义不大的辞藻。\n这个问题会对从事翻译工作的人和初学者造成困扰，如果一个翻译并不具备和作者相同的理论水平，很可能就无法将原文的意思翻译准确；对于初学者来说，因为不具备很深的理论基础，可能很难分清哪些是重点，哪些不重要，再读过几章之后就很难记得前几章的内容了。\n读理论文章不仅需要短期记忆来理解当前内容，同时需要长期记忆来分辨内容的重要程度，判断哪些是新出现的，哪些是过去章节理论的重复。换句换说读者需要选择性的找出重点并且和之前已经出现的理论网络建立链接，这点光靠脑子记是不太可能的，我们最好的办法就是 记笔记 ，通过不断的压缩重新组织以经阅读的内容来形成知识网络，再将阅读到的重要内容加入到这个网络当中来巩固知识与网络。"},"2022/Identity-Functor":{"slug":"2022/Identity-Functor","filePath":"2022/Identity Functor.md","title":"Identity Functor","links":["2022/Functor"],"tags":["Programming/Haskell"],"content":"Identity 是个 Functor 的实例。从定义上看，只是用了个盒子把值包了起来， fmap 相当于什么都没有做，简单的将里面的值拿出来，然后应用 f ，再把 结果放回到盒子中。代表了一个不含任何额外上下文信息的盒子。\nnewtype Identity a = Identity { runIdentity :: a }\n \ninstance Functor Identity where\n\tfmap f = Identity . f . runIdentity"},"2022/Monad":{"slug":"2022/Monad","filePath":"2022/Monad.md","title":"Monad","links":["2022/Applicative"],"tags":["Programming/Haskell","Programming/Typeclass"],"content":"Monad 是 Applicative 的子类型。\nMonad 的 Haskell 定义\nclass Applicative m =&gt; Monad m where\nreturn :: a -&gt; m a\nreturn = pure\n \n(&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b\n \n(&gt;&gt;)   :: m a -&gt; m b -&gt; m b\nm &gt;&gt; n = m &gt;&gt;= \\_ -&gt; n\n \njoin :: m (m a) -&gt; m a\njoin = (&gt;&gt;= id)\nMonad 在 GHC 8.8 之后才被实现为 Applicative 的子类型，区别在于之前的实现中 Monad 还包含一个 fail 的函数。\n在实现中，函数 return和 Applicative 的函数 pure 的定义应该是相同 的，可以理解为早期 Monad 没有被实现为\nApplicative 子类时取了一个错误的名字。同样的原因，函数 (&gt;&gt;) 和 Applicative 的函数 (*&gt;) 相同，并且虽然 (&gt;&gt;) 有默认的实现，但在实现中一般不符合语义，默认实现中直接保留了 m b，也就是第二个参数的盒子和内容，而正确的语义应该是保留 m a 的盒子和 m b 的结果，也就是将第二个参数盒子中的内容取出放入第一个参数的盒子当中，和 Applicative 的 (*&gt;)语义相同。\n(&gt;&gt;=) 函数叫做 bind ，将第一个参数中的值取出，绑定到第二个参数的计算中去。\nMonad 应当满足的条件\nreturn a &gt;&gt;= k = k a\nm &gt;&gt;= return   = m\nm &gt;&gt;= (\\x -&gt; k x &gt;&gt;= h) = (m &gt;&gt;= k) &gt;&gt;= h"},"2022/iproute2-command":{"slug":"2022/iproute2-command","filePath":"2022/iproute2 command.md","title":"iproute2 command","links":["Linux"],"tags":["Linux/Command"],"content":"ipconfig, netstat 等网络命令在最新的 Linux 上已经被废弃, 取而代之的是新的网络工具包 iproute2。新的命令和旧工具之间的对应关系如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLegacy utilityReplacement commandNoteifconfigip addr, ip linkAddress and link configurationrouteip routeRouting tablesarpip neighNeighborsiptunnelip tunnelTunnelsnameif, ifrenameip link set nameRename network interfaceipmaddrip maddrMulticastnetstatss, ip routeShow various networking statisticsbrctlbridgeHandle bridge addresses and devices\n\nRepo: github.com/shemminger/iproute2\n"},"2022/卡片笔记":{"slug":"2022/卡片笔记","filePath":"2022/卡片笔记.md","title":"卡片笔记","links":["2022/如何实现最有抱负的目标","2022/正负反馈"],"tags":["技能/笔记方法"],"content":"**卡片笔记（Zettelkasten）**系统是德国社会学家 Niklas Luhmann 采用的一种不同于一般我们做笔记方法的笔记系统。和一般的按主题线性的记录笔记不同，卡片笔记系统将笔记拆分为一张张卡片，每张卡片的内容不宜过长，这也是使用卡片的原因，一张卡片能承载的信息量有限。卡片和卡片之间是通过某种索引和位置关系来建立链接，在 Luhmann 的实践中是通过卡片的特定编号规则和在卡片盒中的位置来实现，在有软件帮助的情况下，最完美的替代是超链接。\n虽然上文说卡片笔记系统是 Luhmann 采用的笔记系统，但是卡片的笔记方式并不是 Luhmann 发明并推广的，历史上有很多人都采取过与 Luhmann 类似的笔记系统，例如凡尔纳，纳博科夫，钱钟书等等，虽然总体方法上有所差异，但都不约而同的采用了卡片来作为笔记的载体。\n笔记分类\n在 Luhman 的卡片盒笔记系统中，笔记被分为了四种类型(阿伦斯, 2021)，分别为：\n\n闪念笔记\n文献笔记\n永久笔记\n项目笔记\n\n但目前对我来说并没有看到，我主要专注于永久笔记，并不会特别区分各种笔记的类型，在我看来这个系统最重要的点不在于对笔记分类，那是所有的笔记方法都会用到的东西，更重要的是另外两个方面，一是单个卡片的内容长度限制，二是使用超链接连接不同的卡片。\n卡片盒笔记中最为重要的两个点\n\n\n内容长度的限制\n内容长度的限制至少有三个方面，一是强迫我们在记笔记的时候精良的精简我们的语言，同时尽可能的描述我们想要记录的想法；二是写短的笔记的时间和精力消耗小，可以让我们没有负担的随时开始，这里契合了 TED 演讲如何实现最有抱负的目标的观点，积累微小的正确的选择，最终可以带来巨大的成就；三是再回顾笔记时，简洁和清晰的描述有利于我们重新回忆起相关的知识。\n\n\n超链接\n超链接可以说是卡片盒笔记的核心，将各个卡片的粒度细分后，再通过链接的形式重新组织，可以将不同领域中的相似知识观点链接到一起，随着卡片积累的越来越多，知识之间的链接也会越来越多，知识就越容易被链接和回忆，形成一个正反馈的过程。\n\n\n卡片盒笔记的更详细介绍\n申克阿伦斯的《卡片笔记写作法》是一本全面介绍了卡片盒笔记系统和其相关研究的书籍，值得多读几篇，并根据心得重新调整自己的笔记系统。\nZettelkastsen.de 网站有关于方法的介绍，也有时常更新的 blog ，值得关注。"},"2022/如何实现最有抱负的目标":{"slug":"2022/如何实现最有抱负的目标","filePath":"2022/如何实现最有抱负的目标.md","title":"如何实现最有抱负的目标","links":[],"tags":["Learn/SelfImprovement"],"content":"积跬步，至千里, 将远大的目标分解到足够小的步骤，小到每次只需要 5-10 分钟的投入时间，然后将每个步骤都融入到每天的生活当中。达成一个看似无法达到目标就被转换成了一次次小小的正确选择，比如在你掏出手机刷视频时，做出一个小小的正确的选择，关掉视频，去做 10 分钟你目标所需要的一个小步骤。这些边际的正确决策可以逐步累计成看似不可能达成的目标。\n演讲中作者讲述了自己从小就是一个专注力有问题的小孩，每次只能专注 10 分钟，就会忍不住跳到其他事情上。所以后来作者将所需学习了知识分解成 10 分钟的任务，每次学习 10 分钟之后就去做些别的事情，再回来投入另外 10 分钟完成下一个任务。这个方法让他读完了高中，读完了大学，并成为了一个出色的基金经理。不仅如此，同样的策略也帮助他学会了德语，跳伞，一年读 50 本书，完成了 36 个徒步路线，完成世界上最困难的马拉松。所以作者一直在强调每一次小小的正确决策所能带来的巨大改变。\n总结来看，这个简单的方法包含两个部分:\n\n第一，将你远大的目标划分到足够小的目标，一年读 50 本书分解到最小就是翻开书读一个字\n第二，是每次都做出小小的正确选择，在你躺在沙发上准备刷手机时，放下手机，翻开你想读的书，读一个字，读一个字你就会开始读第二个字，这种惯性会拽着我们向自己的最终目标靠近\n\n除了这两个部分，我认为还需要加入另外一个习惯，那就是不断的测试和得到反馈，不断的反馈可以确保我们真的已经掌握了所学的东西，并且可以确保我们没有偏离我们的目标。"},"2022/教育孩子的三原则":{"slug":"2022/教育孩子的三原则","filePath":"2022/教育孩子的三原则.md","title":"教育孩子的三原则","links":["GIRT","GRIT","《娱乐至死》"],"tags":["技能"],"content":"\n\n                  \n                  Summary\n                  \n                \n\n\n培养良好的品格与正确的世界观；\n展示世界的多姿多彩，让小孩发现自己的兴趣所在；\n教会孩子学习的能力。\n\n\n\n培养良好的品格与正确的世界观\n品格和正确的世界观是成为一个正常的有益于社会和自身的人的必要条件，一个性格有缺陷和拥有不正世界观的人容易走上歧途，不仅对自己也对社会产生负面的影响。\n良好的品格应该包括，善良，诚实，开朗，拥抱成长思维而非固定思维 GIRT，懂得尊重，自信，坚强，并遵守已经达成的共识（比如法律规范，道德习俗或集体的规约等）。良好的品格之间也不是孤立的，比如一个诚实的孩子很大概率也是一个遵守规则的孩子。相反一个不诚实的孩子很可能也有其他的不良习惯，所以在教育和培养的过程中应该全面考虑，各种品格的教育应该同时进行，而不是线性的。同时对于孩子体现出的不良习惯应该早发现早治疗，不能溺爱和放任。\n正确的世界观包含对世界和对物质两个方面，在对待世界的方面，应该懂得世界的广大与精英和大众的区别，要明白精英的价值观和生活状态在某种程度上是脱离大众的，而我们只有在融入大众之中才能够看清生活的本质。而物质方面，则应该明白物质的追求是最低层次的追求，是大多数人无法拥有精神追求之后退而求其次的追求，最明显的例子就是现在大多数人都只在乎物质上的富足，而忽略真正可以让我们感到幸福的体验，他们迷信于钱可以买来幸福与健康。\n关于世界观的培养我目前只有目标，却没有想到合适办法，因为太抽象，所以对于小孩子来说可能难以理解，而且其实我们处于一个刚好相反的社会现实中，人们对于精英们及其生活的盲目崇拜，对于物质的偏执追求，都是我们培养过程中的阻碍。\n展示世界的多姿多彩，让小孩子发现自己的兴趣所在\n这里的展示世界的多姿多彩，不是说多给孩子抱几个兴趣特长班之类的，而是要将知识与现实联系起来，比如让孩子明白数学如何在生活中应用的（我对数学有执念是因为我直到工作才逐渐理解数学之美，如果在小时候有良师可以给我展示除了各种公式和证明之外的用处，我数学应该会比现在好很多），比如在旅游过程中给孩子普及地理的知识。除了知识的应用之外，还要展示人生的不同可能性，比如有人靠潜水过一生，有人为了保护非洲野生动物过一生，有人在南极过一生，有人可以在太空看星星。兴趣是最好的老师，同时孩子要见得越多才越可能找到自己真正热爱的事物。另外兴趣的保持也是应该注意的问题，根据《坚毅》一书的研究，应该至少同时保持 1-2 的兴趣 1-2 年，这同时有助于建立小孩坚毅的性格。\n另外其实老师对于孩子的兴趣有着很大的影响，我个人的例子是在高中时我对物理其实很感兴趣，但老师一直对我不感兴趣，是一种有意无意地无视，导致的结果就是我到现在都觉得如果我当时更强大不用在意老师的反应，我对物理的兴趣的热情会更持久些，在大学专业的选择上也会有所不同吧。小孩会遇到什么样的老师，老师会怎样对待小孩是不确定的，而作为家长来说，确定能做的是，充分的和孩子沟通，了解小孩的兴趣，并确定小孩对于老师的感受，如果老师不能帮助孩子，那作为家长也责无旁贷。这里的充分沟通也建立在第一个孩子良好品格的基础之上。\n教会孩子学习的能力\n《娱乐至死》中提到了现在的教育其实有一种危险的倾向，那就是将教育娱乐化。寓教于乐是很流行的一个概念，所以很多教育希望通过各种娱乐中穿插知识的方式，希望孩子能快乐的学到知识。我承认这在低龄的还不能集中自己注意力的孩子教育上有用武之地。但当孩子在大一些，我们应该尽早的让孩子明白，学习不是娱乐，学习是很消耗时间和精力事情，如果要学会某种知识，最好的办法是坐下来，认真的去阅读，思考，内化书本之上的知识，而不是拿着遥控器，躺在沙发上看一些知识类的视频。回归书本，通过文字去获取知识，这点在当今社会显得有些格格不入，因为我们本身处于一个泛娱乐话的时代，我们的时间是碎片话的，我们的学习是碎片话的，所以我们的知识也是碎片化的，所以我们必须有勇气对这种情况说不。"},"2022/正负反馈":{"slug":"2022/正负反馈","filePath":"2022/正负反馈.md","title":"正负反馈","links":[],"tags":["控制论"],"content":"正反馈与负反馈都是控制理论中的名词，但是作用范围可以不用局限于控制论当中，范勇鹏就曾在观视频的年终答案秀中来用正反馈和负反馈来形容政治体制的变化。我这里也是基于他的例子来做的浅显总结，可能需要了解控制论之后才能更进一步的精确描述。\n正反馈\n系统的输出信号，反向输入回系统之后，对系统起促进作用，促使整个系统不断的向外发展，系统会不断的膨胀，一般来说正反馈是一个良性的循环，但是要注意任何系统的不断膨胀最终导致的结果可能是资源枯竭，这么来看持续不断的正反馈可能是系统最终崩溃的原因。\n负反馈\n和正反馈相反，系统的输出信号，重新输入回系统之后，对系统起抑制作用，促使系统的萎缩，同样负反馈表面上看起来是一个恶性的循环，但如果在资源受限的条件下，适当的负反馈可以保持系统的稳定，不会因为资源耗尽而使得系统崩溃。\n辨证关系\n正反馈和负反馈就像中国传统一元哲学的阴阳两面，月满则亏，作为一个系统的两个方面，只在乎正反馈或着负反馈都是不行的。\n这么看来，老祖宗这个一元哲学所蕴含的这种辨证关系真的是很有现实意义的，值得我们花更多时间去研究。"},"2023/Algorithm":{"slug":"2023/Algorithm","filePath":"2023/Algorithm.md","title":"Algorithm","links":[],"tags":["MOC","ComputerScience/Algorithm","Algorithm"],"content":"算法（Algorithm），在数学和计算机科学之中，指一个被定义好的、计算机可施行其指示的有限步骤或次序，常用于计算、数据处理和自动推理。算法可以使用条件语句通过各种途径转移代码执行（称为自动决策），并推导出有效的推论（称为自动推理），最终实现自动化。\n各种算法的层次关系\n各种算法复杂多变，使得学习起来非常困难，好在各种算法与数据结构有递进的层次关系，通过掌握基础的算法逻辑再掌握更高级的算法，有助与我们循序渐进的掌握算法，下面这张图大概列出了各种算法之间的层次关系，可以根据这个顺序去学习。\nflowchart TD\n\n%% nodes\narray-and-hashing(&quot;Array &amp; Hashing&quot;)\ntwo-pointers(&quot;Two Pointers&quot;)\nstack(&quot;Stack&quot;)\n\narray-and-hashing --&gt; two-pointers\narray-and-hashing --&gt; stack\n\nbinary-search(&quot;Binary Search&quot;)\nsliding-window(&quot;Sliding Window&quot;)\nlinked-list(&quot;Linked List&quot;)\n\ntwo-pointers --&gt; binary-search\ntwo-pointers --&gt; sliding-window\ntwo-pointers --&gt; linked-list\n\ntrees(&quot;Trees&quot;)\n\nbinary-search --&gt; trees\nlinked-list --&gt; trees\n\ntries(&quot;Tries&quot;)\nheap-priority-queue(&quot;Heap/Priority Queue&quot;)\nbacktracking(&quot;Backtracking&quot;)\n\ntrees --&gt; tries\ntrees --&gt; heap-priority-queue\ntrees --&gt; backtracking\n\ngraphs(&quot;Graphs&quot;)\n1d-dp(&quot;1-D DP&quot;)\n\nbacktracking --&gt; graphs\nbacktracking --&gt; 1d-dp\n\nintervals(&quot;Intervals&quot;)\ngreedy(&quot;Greedy&quot;)\nadvanced-graphs(&quot;Advanced Graphs&quot;)\n2d-dp(&quot;2-D DP&quot;)\nbit-manipulation(&quot;Bit Manipulation&quot;)\n\nheap-priority-queue --&gt; intervals\nheap-priority-queue --&gt; greedy\nheap-priority-queue --&gt; advanced-graphs\ngraphs --&gt; advanced-graphs\ngraphs --&gt; 2d-dp\n1d-dp --&gt; 2d-dp\n1d-dp --&gt; bit-manipulation\n\nmath-geometry(&quot;Math Geometry&quot;)\n\ngraphs --&gt; math-geometry\nbit-manipulation --&gt; math-geometry\n\nclass array-and-hashing,two-pointers,stack internal-link;\nclass binary-search,sliding-window,linked-list internal-link;\nclass trees,tries,heap-priority-queue internal-link;\nclass backtracking,graphs,1d-dp internal-link;\nclass intervals,greedy,advanced-graphs,2d-dp internal-link;\nclass bit-manipulation,math-geometry internal-link;\n"},"2023/Backtracking":{"slug":"2023/Backtracking","filePath":"2023/Backtracking.md","title":"Backtracking","links":[],"tags":["Algorithm/Backtracking"],"content":"回溯法（英語：backtracking）是暴力搜尋法中的一种。\n对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于約束滿足問題（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。\n在经典的教科书中，八皇后问题展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）\n回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现，现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：\n\n找到一个可能存在的正确的答案\n在尝试了所有可能的分步方法后宣告该问题没有答案\n\n在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。"},"2023/Binary-Heap":{"slug":"2023/Binary-Heap","filePath":"2023/Binary Heap.md","title":"Binary Heap","links":["2024/Complete-Binary-Tree","2024/Heap","2024/Go-Programming-Language","Rust","Python"],"tags":["ComputerScience/DataStructure","DataStructure/Heap"],"content":"二叉堆（Binary Heap） 是使用完全二叉树实现的堆，所以其既满足堆的特性，也满足完全二叉树的特性。 对于任何一个节点，其子节点的值全都大于（或小于）父节点。堆顶为最小值的堆称为小顶堆 (Min Heap)，堆顶为最大值则称为大顶堆 (Max Heap)。\n因为基于完全二叉树，所以二叉堆的实现一般也是基于数组。\n二叉堆各操作的时间复杂度如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperationAverageWorst caseInsertO(1)O(\\log{n})Find-minO(1)O(1)Delete-minO(\\log{n})O(\\log{n})Decrease-keyO(\\log{n})O(\\log{n})MergeO(n)O(n)\n又因为经常用来实现比较常用的优先队列，所以很多语言的标准库中的自带了小顶堆（大顶堆通过自定义比较运算的方式实现）的实现，比如Golang, Rust, Python。"},"2023/Binary-Tree":{"slug":"2023/Binary-Tree","filePath":"2023/Binary Tree.md","title":"Binary Tree","links":["2024/Tree"],"tags":["DataStructure/Tree"],"content":"二叉树（Binary Tree） 是一种每个节点至多有两个子节点的特殊树形数据结构。\n在第 i 层至多有 2^{i+1} 个节点；深度为 k 的二叉树至多总共有 2^{k+1} - 1 (k_0 = 0) 个节点。\n     A\n   /   \\\n  B     C\n / \\   / \\\nD   E F   G\n\n\n                  \n                  Tips \n                  \n                \n\n\n当需要广度优先遍历时（BFS）， 层次顺序访问时，配合储存 Node 的队列进行，按照先左后右的顺序将子节点加入队列当中。\n\n\n\n遍历二叉树\n按照访问父节点的值（不是访问节点，是读取节点中的内容，遍历时始终要先访问节点中的指针）的顺序的不同，可以分为三种不同的遍历方式，以上面的二叉树为例。\n\n\n前序遍历 (Pre-order Traversal)：\n\n访问顺序：根节点 → 左子树 → 右子树\n例子的访问结果是：A -&gt; B -&gt; D -&gt; E -&gt; C -&gt; F -&gt; G\n\n\n\n中序遍历 (In-order Traversal)：\n\n访问顺序：左子树 → 根节点 → 右子树\n例子的遍历结果是：D -&gt; B -&gt; E -&gt; A -&gt; F -&gt; C -&gt; G\n\n\n\n后序遍历 (Post-order Traversal)：\n\n访问顺序：左子树 → 右子树 → 根节点\n例子的遍历结果是：D -&gt; E -&gt; B -&gt; F -&gt; G -&gt; C -&gt; A\n\n\n"},"2023/Brain-Kernighan-比特位计数算法":{"slug":"2023/Brain-Kernighan-比特位计数算法","filePath":"2023/Brain Kernighan 比特位计数算法.md","title":"Brain Kernighan 比特位计数算法","links":["2023/Hamming-Weight"],"tags":["Algorithm/BitOperator"],"content":"Brain Kernighan 算法用来计算数据的 Hamming Weight，即一串 bit 中为 1 的位数，用以提升计算效率。\n我们先来通过普通的办法尝试来计算对一个 32 位整形数的比特位计数，python 的代码如下：\ndef hammingWeight(self, n: int) -&gt; int:\n    ret = 0\n    while n:\n        ret += n % 2\n        n = n &gt;&gt; 1\n    return ret\n我们通过一个循环，不断的考察 n 的最后一位，如果是 1， 则说明最右边 bit 为 1，将结果+1，这个算法的时间复杂度为 O(32), 不错是常数，但我们还有提升空间，比如这样一个数字 1000000001 我们的算法在中间 0 的时候会做多次无用的计算，使用 Brain Kernighan 算法则可以帮我们跳过中间 0 位的循环，可以进一步提高计算的数度，实现代码如下：\ndef hammingWeight(self, n: int) -&gt; int:\n    ret = 0\n    while n:\n        n &amp;= n - 1\n        ret += 1\n    return ret\n这里的原理是，n = n &amp; (n-1) 会去掉 n 中最右边的 1，我们只要不断重复这一操作，当 n 降为 0 时，我们的操作次数就是 n 中 1bit 的数量。考虑以下这个例子：\n// first iteration\nn           = 1001\nn - 1       = 1000\nn &amp; (n - 1) = 1000\nop_times    = 1\n\n// second iteration\nn           = 1000\nn - 1.      = 0111\nn &amp; (n - 1) = 0000\nop_times    = 2\n\n// n = 0 now stop iteration and return op_times as result\n"},"2023/Dynamic-Programming":{"slug":"2023/Dynamic-Programming","filePath":"2023/Dynamic Programming.md","title":"Dynamic Programming","links":["2024/Recursion"],"tags":["Algorithm/DynamicProgramming"],"content":"动态规划（Dynamic Programming） 是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。\n动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费不必要的时间。\n动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。\n动态规划其实就是递归，其解决问题的范围也条件也和递归相同，但在算法实现上却有不同，递归的解法一般符合问题的拆分逻辑，从大到小直到终止条件。而动态规划则是拆分问题之后，从最小解出发，从小到大逐步拓展到最终问题，这样子问题的解可以在拓展过程中保留，从而解决递归中重复计算的问题。"},"2023/Fonts-for-Programming":{"slug":"2023/Fonts-for-Programming","filePath":"2023/Fonts for Programming.md","title":"Fonts for Programming","links":[],"tags":["Programming/Fonts","Programming/Editor"],"content":"宽度为 0.5 的等宽字体\n\nIosevka 提供多种选项可以开关\nFantasque Sans Mono\nM PLUS Code Latin\nMonofur\nUbuntu Mono\nUnifont\nPragmata Pro 很贵，Iosevka 中有提供一个类似的 style\nPragmasevka 基于 Iosevka ss08 加深魔改为 PragmataPro 的版本\n\n宽度为 0.6 的等宽字体\n\nJetBrains Mono\nMonaco / Monego\nJulia Mono 字体中的数学符号很好\nVictor Mono 斜体有像 Operator Mono 那种衬线\nSometype Mono，设计的主要目的是为了在 table 中使用\nSono mono\nNova mono，很圆润\nRecursive，提供了多种 OTF features，字形也不错，但如果使用 Rec Mono，OTF 的选项就没有了\nMonaspace，提供四种字体\n\n其它宽度\n\nFira code，比 0.6 要宽\nEnvy Code R，介于 0.5 到 0.6 之间，粗体很有怀旧的 terminal 的感觉\nSudo Var，这个比 0.5 要小，整体字都显的很小，但还算能看清\nInconsolata\n"},"2023/Hamming-Weight":{"slug":"2023/Hamming-Weight","filePath":"2023/Hamming Weight.md","title":"Hamming Weight","links":["2023/Brain-Kernighan-比特位计数算法"],"tags":["Algorithm/BitOperator"],"content":"**海明权重（Hamming weight）**是指在一个二进制数中，非零位的个数，或者说是二进制数中为 1 的位的数量。如下图所示:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStringHamming weight111014111010004000000000\n海明权重的应用和意义在于，\n\n\n错误检测和纠正： 海明权重被广泛用于错误检测和纠正码的设计。在编码理论中，海明距离是一种度量两个等长二进制串之间的差异的方法，而海明权重则是一个二进制串中非零位的个数。通过在编码中增加冗余信息，可以检测和纠正位错误，从而提高数据的可靠性。\n\n\n密码学： 在密码学中，海明权重可以用于设计和分析一些密码算法。一些密码算法的安全性和性能与输入数据的统计特性相关，而海明权重是其中一个重要的统计量。\n\n\n图像处理： 在图像处理中，海明权重有时被用于图像特征的提取。例如，图像的二值化表示中，每个像素是 0 或 1，海明权重可以用来描述图像中的纹理、边缘等特征。\n\n\n网络通信： 海明权重也可以用于网络通信中的错误检测。在数据传输过程中，可能会发生位翻转或其他错误，通过使用海明权重，可以检测这些错误并采取相应的纠正措施。\n\n\n海明权重可以通过 Brain Kernighan 比特位计数算法快速计算。"},"2023/Linked-List":{"slug":"2023/Linked-List","filePath":"2023/Linked List.md","title":"Linked List","links":["2024/Data-Structure","Lisp","2022/Haskell-Programming-Language"],"tags":["DataStructure/LinkedList"],"content":"链表（Linked List） 是通过指针将一个一个 Node 链接在一起的数据结构，通过下图可以直观感受：\n┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐\n│ Node  │    │ Node  │    │ Node  │    │ Node  │\n│-------│    │-------│    │-------│    │-------│\n│ Data  │    │ Data  │    │ Data  │    │ Data  │\n│       │    │       │    │       │    │       │\n│ Next ----&gt; │ Next ----&gt; │ Next ----&gt; │ None  │\n└───────┘    └───────┘    └───────┘    └───────┘\nHead         Node1       Node2       Tail\n链表由 Node 组成， 每个 Node 包含两部分，数据 (data) 与指向下一节点的指针 (Next) 。\n链表在生成之后我们只需保存一个指向 Head 节点的指针，其他节点需要靠指针遍历来访问，这导致链表的访问时间复杂度为 O(n) ，但插入删除操作的时间复杂度为 O(1) 。\n\n\n                  \n                  Tip\n                  \n                \n\nLisp 和 Haskell 中的列表多为链表实现。\n\n\n链表处理中常用技巧\nDummy Head\n也有叫哨兵技巧的，就是在处理链表的过程中在链表的 Head 之前再加入一个节点 Dummy Head，指向 Head，在处理完之后直接使用 dummy.next 就能拿到最新的 head，不用在处理的过程中一直追踪 head 在哪儿。\ndummy -&gt; elem1(head) -&gt; elem2 -&gt; nil\n\n快慢指针\n用于找寻链表的中点或验证链表中是否存在环，设置两个指针 slow 和 fast, slow每次移动一步， fast 每次移动两步，这样当 fast 移动到队尾时，slow 刚好移动到中点的元素。\n\n对于奇数长度的链表，slow 最后指向的元素为 \\frac{n + 1}{2} .\n对于偶数长度的链表，slow 最后指向的元素为 \\frac{n}{2}.\n\n无论是奇数还是偶数，右半部分的 head 都为 slow.next。"},"2023/RESTful-API-Design":{"slug":"2023/RESTful-API-Design","filePath":"2023/RESTful API Design.md","title":"RESTful API Design","links":["HATEOAS","HTTP-Methods"],"tags":["Programming/DesignPattern"],"content":"REST (Represent State Transfer, 表现层状态转换) 是一种 API 的设计风格，源于 Roy Thomas Fielding 博士于 2000 年的博士论文。\nRESTful API 有下面的这些关键特性和设计原则\n\n资源是由 URI 来指定。\n对资源的操作包括获取、创建、修改和删除，这些操作正好对应 HTTP 协议提供的 GET、POST、PUT 和 DELETE 方法。\n通过操作资源的表现形式来操作资源。\n资源的表现形式则是 XML 或者 HTML，取决于读者是机器还是人、是消费 Web 服务的客户软件还是 Web 浏览器。当然也可以是任何其他的格式，例如 JSON。\n\nStateless\nREST API 一个重要的特性是要求 API 是 stateless （无状态的），\u000e 即要求服务器仅仅依靠当前请求的所给信息来处理请求，不应该依赖任何保存在服务器端的状态信息。\n\n对于一个集群的多个服务器来说，一个请求无论发送到哪一个服务器都应该具有相同的返回，服务器中不应该保存任何和特定用户相关的信息；\n对于单个服务器来说，一个请求的结果不能受到前一个请求的影响。\n\nRESTful API 设计的层次\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLevelFlagLEVEL-3Hypermedia/HATEOASLEVEL-2使用 HTTP Methods 来代表请求的操作LEVEL-1使用以资源名命名的 URL\nRESTful API 的版本管理\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmethodsexampleURLexample/v1/resources实现简单Queryexample/resources?v=2实现简单Headercustom-header:api-version=2更符合 REST 的原则Media TypeAccept: application/resources.v2.json更符合 REST 的原则\nError handling\n以 HTTP code 来表示请求的结果\n\nRFC 7807\n\nReferences\n\nREST API Best Practices\nHow to design REST APIs\nHATEOAS\n"},"2023/Rust---Import-Mod-Using-Abs-Path":{"slug":"2023/Rust---Import-Mod-Using-Abs-Path","filePath":"2023/Rust - Import Mod Using Abs Path.md","title":"Rust - Import Mod Using Abs Path","links":[],"tags":["Programming/Rust"],"content":"在引用标准库或者第三方库时，如果本地有同名的模块，可以在引用前增加 :: 强制 rust 从 crate 的根模块去查找模块，这样可以确保引用到 rust 标准库中的模块，如： use ::std::collections::HashMap ， 而如果使用 use std::collections::HashMap 去引用的话会引用到当前 crate 中的同名模块，如下面这个例子中，_empty 变量通过 :: 将类型申明为了标准库中的 Hashmap， 如果没有 :: ，类型会被解析成当前模块中定义的 HashMap ：\n#[test]\n#[ignore]\nfn type_override() {\n\tmod std {\n\t\tpub mod collections {\n\t\t\tpub struct HashMap;\n \n\t\t\timpl HashMap {\n\t\t\t\t#[allow(dead_code)]\n\t\t\t\tpub fn new() -&gt; Self {\n\t\t\t\t\tpanic!(&quot;Do not allow users to override which HashMap is used&quot;);\n\t\t\t\t}\n \n\t\t\t\t#[allow(dead_code)]\n\t\t\t\tpub fn insert&lt;K, V&gt;(&amp;mut self, _key: K, _val: V) {\n\t\t\t\t\tpanic!(&quot;Do not allow users to override which HashMap is used&quot;);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tlet _empty: ::std::collections::HashMap&lt;(), ()&gt; = hashmap!();\n\tlet _without_comma = hashmap!(1 =&gt; 2, 3 =&gt; 4);\n\tlet _with_trailing = hashmap!(1 =&gt; 2, 3 =&gt; 4,);\n}"},"2023/Rust---Pattern-Match-on-Slice":{"slug":"2023/Rust---Pattern-Match-on-Slice","filePath":"2023/Rust - Pattern Match on Slice.md","title":"Rust - Pattern Match on Slice","links":["Rust","2022/Haskell-Programming-Language","Pattern-Match"],"tags":["Programming/Rust"],"content":"1.42 之后 Rust 拥有了和 Haskell Programming Language 差不多的对 slice 做 pattern match 的能力，要注意的是这里的 match 只能针对的是 slice，如果对象是 Vec 之类的，需要通过切片语法 lst[..] 先转换为 slice 再进行匹配。具体的用法我们参照下面这个例子。\nfn print_words(sentence: &amp;str) {\n\tlet words: Vec&lt;_&gt; = sentence.split_whitespace().collect();\n \n\tmatch words.as_slice() {\n\t\t[] | [_] =&gt; println!(&quot;Ingore one word or no word&quot;),\n\t\t[word, name] =&gt; println!(&quot;Found 2 word: {}, {}&quot;, word, name),\n\t\t[&quot;hello&quot;, name, ..] =&gt; println!(&quot;capture second word name: {}&quot;, name),\n\t\t[&quot;hello&quot; | &quot;hi&quot;, name, rest @ ..] =&gt; println!(&quot;test with | operator, and collect rust, {}, {:?}&quot;, name, rest),\n\t\t[first, middle @ ..., last] if first == last =&gt; println!(&quot;capture middles {}&quot;, middle),\n\t\t_ =&gt; println!(&quot;Found {} words: {:?}&quot;, words.len(), words),\n\t}\n}\n另外 Rust 中 Pattern Match 不止是在 match 中使用，在 let 和函数参数中同样可以使用。\nfn format_coordinates([x, y]: [f32; 2]) -&gt; String {\n\tformat!(&quot;{}|{}&quot;, x, y)\n}\n \nfn main() {\n\tlet point = [3.14, -42.0];\n \n\tprintln!(&quot;{}&quot;, format_coordinates(point));\n \n\tlet [x, y] = point;\n\tprintln!(&quot;x: {}, y: {}&quot;, x, y);\n\t// Much more ergonomic than writing this!\n\t// let x = point[0];\n\t// let y = point[1];\n}\n更多例子可以查看这篇 Daily Rust: Slice Patterns 博客。"},"2023/Sliding-Window":{"slug":"2023/Sliding-Window","filePath":"2023/Sliding Window.md","title":"Sliding Window","links":[],"tags":["Algorithm/SlidingWindow"],"content":"**滑动窗口（Sliding Window）**是一种用于有效解决涉及需要在输入数据上定义一个窗口或范围，并不断的在数据集上移动放大缩小该窗口或范围的问题的方法Geeksforgeeks。经常用于以下的具体问题：查找具有特定总和的子数组、查找具有唯一字符的最长子字符串，或解决需要固定大小窗口来有效处理元素的问题。\n在编写滑动窗口算法时应该注意下面这些点：\n\n滑动窗口的算法一般适用于 List 数据集；\n一般需要左右两个指针指向窗口的两个边界；\n循环的终止条件一般为右指针到达了数据边界；\n每次循环中至少应该保证左右指针中至少一个发生变动；\n一般会对窗口中的数据进行计数的操作，所以滑动窗口和容易于 HashMap 相结合。\n"},"2023/Terminal-File-Manager":{"slug":"2023/Terminal-File-Manager","filePath":"2023/Terminal File Manager.md","title":"Terminal File Manager","links":["Vim","Quick-References/ViFM-Cheatsheet","Emacs"],"tags":["Software"],"content":"比起各种 GUI 的文件管理器，比如各个操作系统自带的文件管理器，或者第三方的像 Total Commander 和 ForkLift 之类的，Terminal File Manager 的优势有两个：\n\n支持所有的操作系统，这样在所有系统中都有相同的体验，特别是可以搭配同样跨平台的 terminal，比如 Wezterm， Alacritty；\n更好的键盘操作支持，有些 GUI 的管理器同样有部分的键盘快捷键支持，但是远远不如 terminal 中的易用和全面，毕竟在 terminal 中是键盘为主，鼠标为辅的操作逻辑。\n\n这两个优势带来的好处就是用户只需熟练使用一种操作逻辑就可以在所有操作系统中高效地完成文件管理工作，而对比 GUI 程序不足的点在于：\n\n不能显示图片，terminal 最大的问题是基于文本的，所以不能在 file manager 中实时的预览图片，Ranger 中有插件可以支持，但似乎已经不再更新了；\n翻页和滚动不如 GUI，terminal 中的滚动是按行来的，而 GUI 中是按像素来的，直观来说就是 GUI 中的滚动会流畅非常非常多；\n打开的可能没有 GUI 快，一般的文件管理器会常驻在系统 Dock 上，可以快速的打开，用户也习惯了通过鼠标快速的点击到目标目录，而 terminal 则要先打开 terminal，再打卡 file manager 再通过键盘操作来进入目录（这里可以通过各种办法跳过），这一点需要看使用场景，如果是已经在 terminal 当中，那打开 file manager 的速度会比 GUI 快很多。\n\n但这些劣势其实并不影响文件管理的核心功能，所以大部分时间我们可以使用 terminal 来作为主力管理器。\n比起在 Linux 上使用 shell 命令来说，terminal file manager 提供了一种更直观的操作逻辑，在图形界面批量处理选择复制等操作比起使用命令来说会更直观和高效，但在批量处理时可能会不如特别编写的脚本，不过 file manager 在所有操作系统上都有同样的快捷键，而 DOS 和 linux shell 则是完全不同的命令了。\n下面是些我了解的 Terminal File Manager。\nVifm\nVifm 是一个两栏的文件管理器，其最大的优势就是操作逻辑和 Vim 相近，Vim 用户可以使用同样的快捷键进行移动，甚至复制删除等操作也符合 Vim 的逻辑，这里有个 ViFM Cheatsheet 列出了所有常用的快捷键。\n\n项目地址：vifm.info/\n\nMidnight Commander\nMidnight Commander 有点像是个 terminal 版的 total commander，主要操作都绑定在了 FN 键上，移动的快捷键则是 Emacs 风格，比较有特点的是能够方便的对文件进行压缩和解压，可以直接进入 zip 压缩文件，并往 zip 中 copy 文件，但让我最困惑地是它缺少了回到上一级文件夹的快捷键，只有点击 /.. 目录才行，这让文件浏览的速度大打折扣。\n\n项目地址：midnight-commander.org/\n介绍视频：My FAVORITE File Manager - Complete Midnight Commander Tutorial\n\nRanger\nRanger 也是一个基于 vim 快捷键逻辑的管理器，默认是多级的目录浏览，也可以配置成 Midnight Commander 类似的双栏的显示效果，主要的优势可能是用的人数要多些，插件更多，教程可能也更多一点，但 ranger 是 python 写的，所以安装时要安装 python 的依赖，内存消耗上也会比上面两个要大。\n\n项目地址：ranger.github.io/\n\nLF\n类似 Ranger，但是用 golang 写成。\n\n项目地址：github.com/gokcehan/lf\n\nYazi\n用 Rust 写的 LF, 比起 LF 来说，最大的好处就是内置了针对各种 terminal app 的图片显示支持，基本不用配置，开箱就能用。\n\n项目地址：github.com/sxyazi/yazi\n"},"2023/Topological-Sorting":{"slug":"2023/Topological-Sorting","filePath":"2023/Topological Sorting.md","title":"Topological Sorting","links":["2024/Graph","2024/Depth-First-Search"],"tags":["Algorithm/Sorting"],"content":"拓扑排序是一种对有向无环图（DAG）进行排序的算法，其目的是将图中的所有顶点线性排列，使得对于每一条有向边 u \\to v，顶点 u 在顶点 v 之前。换句话说，拓扑排序确保了所有的依赖关系都被满足。\n拓扑排序的应用场景包括：\n\n任务调度：在有依赖关系的任务中，确保先完成依赖的任务再进行后续任务。\n编译顺序：在编译程序时，确保先编译依赖的模块。\n课程安排：在学习课程时，确保先学习先修课程。\n\n拓扑排序的常用算法有两种：\n\n\nKahn 算法：通过计算每个顶点的入度，逐步将入度为 0 的顶点加入排序结果，并更新其邻接顶点的入度。\nL ← 包含已排序的元素的列表，目前为空\nS ← 入度为零的节点的集合\n当 S 非空时：\n    将节点n从S移走\n    将n加到L尾部\n    选出任意起点为n的边e = (n,m)，移除e。如m没有其它入边，则将m加入S。\n    重复上一步。\n如图中有剩余的边则：\n    return error   (图中至少有一个环)\n否则：\n    return L   (L为图的拓扑排序)\n\n\n\n深度优先搜索（DFS）：通过对图进行DFS遍历，记录每个顶点的完成时间，最后反转完成时间的顺序得到拓扑排序。\nL ← 一个空的 用来存放已排序的节点的列表\n当图中存在未永久标记的节点时：\n    选出任何未永久标记的节点n\n    visit(n)\n\nfunction visit(节点 n)\n    如n被永久标记：\n        return\n    如n被临时标记：\n        stop   (不是定向无环图，至少有一个环)\n\n    将n临时标记\n\n    对于每一个以n为起点的边(n,m)：\n        visit(m)\n\n    去掉n的临时标记\n    将n永久标记\n    在L的起始位置插入n（如L已有内容 后移它们以空出起始位置）\n\n\n"},"2023/Tries":{"slug":"2023/Tries","filePath":"2023/Tries.md","title":"Tries","links":["2024/Tree","2024/Data-Structure","LC212-单词搜索-II"],"tags":["DataStructure/Tree","DataStructure/Tries"],"content":"前缀树（Tries） 是将字符串中的各个字符按顺序存入到树形结构当中，这样可以高效的检索给定单词和前缀是否存在于集合当中的树形数据结构。具体的结构可以参考下图：\nflowchart TD\n\ns((&quot; &quot;)) -- t --&gt; t((t))\ns -- A --&gt; a((A))\ns -- i --&gt; i((i))\n\nt -- o --&gt; to((to))\nt -- e --&gt; te((te))\ni -- n --&gt; in((in))\n\nte -- a --&gt; tea((tea))\nte -- d --&gt; ted((ted))\nte -- n --&gt; ten((ten))\nin -- n --&gt; inn((inn))\nin -- t --&gt; int((int))\n\n在实际实现中 Node 中不需要额外存储字符信息，字符在 Children 的字段中作为 key 存在。为了判断当前节点是否可以作为一个单词还是只是前缀，需要存储当前 Node 是否是一个单词的标志位。为了快速的得到对应路径的单词，也可以在节点额外存储一个单词信息，像在 Leetcode 题目212 中做的那样。\n复杂度\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorithmAverageWorst caseSpaceO(n)O(n)SearchO(n)O(n)InsertO(n)O(n)DeleteO(n)O(n)\nCode example\nstruct TrieNode {\n    pub children: HashMap&lt;Char, Box&lt;TrieNode&gt;&gt;,\n    pub is_word: Bool,\n    pub word: Option&lt;String&gt;,\n}"},"2023/Union-Find":{"slug":"2023/Union-Find","filePath":"2023/Union Find.md","title":"Union Find","links":["2024/Graph","LC547-省份数量","LC684-冗余连接"],"tags":["Algorithm/UnionFind"],"content":"并查集（Union Find） 是一种图的算法，用于处理图中的不相交的节点的合并与查询问题。从中文语义来理解，Union Find → Find Union → 查找并集。其主要算法过程由三部分组成：\n\n添加： 添加一个元素到某一集合，一开始基本为将元素添加到自身一个元素的集合中。\n查找： 查询一个元素属于哪个集合，一般返回集合内的一个根元素，集合中所有元素都与该根元素相连。\n合并： 对于相连的两个节点，如果其处在不同集合中，则合并两个集合，一般为每个集合维持一个 Ranks 的变量，表示集合中节点的数量，将节点数较少的集合合并到节点数较多的集合当中，即将较少节点数的集合的根元素的根设置为较多节点数的集合的根元素，并更新对于的 Ranks。\n\n添加操作的伪码：\n function MakeSet(x)\n     x.parent := x\n     x.rank := 0\n end function\n\n查找操作的伪码：\n function Find(x)\n     if x.parent = x then\n         return x\n     else\n         x.parent := Find(x.parent) // 路径压缩，缩短 x 到根的距离\n         return x.parent\n     end if\n end function\n\n按照 Rank 大小合并的伪码：\n function Union(x, y)\n     xRoot := Find(x)\n     yRoot := Find(y)\n\n     if xRoot != yRoot then\n         if xRoot.rank &lt; yRoot.rank then\n             large := yRoot\n             small := xRoot\n         else\n             large := xRoot\n             small := yRoot\n         end if\n\n         small.parent := large\n         large.rank = large.rank + small.rank\n     end if\n end function\n\n并查集运用的具体例子可参看：LC547 省份数量，LC684 冗余连接。"},"2023/异或":{"slug":"2023/异或","filePath":"2023/异或.md","title":"异或","links":["逻辑与","逻辑或","逻辑代数","LC268-丢失的数字"],"tags":["Algorithm/BitOperator","Mathematic/LogicalAlgebra"],"content":"异或与逻辑与和逻辑或一样是逻辑代数中的一种逻辑运算符，其运算逻辑为两两相同为假，反之，两两不同则为真。\n对于命题 p 和 q 其异或操作 p \\oplus q 计算机中写做 p ^ q 的真值表为：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npqp \\oplus qTrueTrueFalseTrueFalseTrueFalseTrueTrueFalseFalseFalse\n异或运算满足如下数学性质：\n\n交换律：p \\oplus q = q \\oplus p\n结合律：p \\oplus (q \\oplus r) = (p \\oplus q) \\oplus r\n恒等律：p \\oplus 0 = p\n归零律：p \\oplus p = 0\n对合运算：p \\oplus q \\oplus q = p \\oplus 0 = p\n\n在计算机中的实际运用中，可以利用异或的性质，快速的交换两个变量的值。\nvoid swap(int *a, int *b) {\n    *a ^= *b;\n    *b ^= *a;\n    *a ^= *b;\n}\n也可以用来解决特定的算法问题，比如这道Leetcode题目：LC268 丢失的数字。\n参考\n\nWiki\n"},"2023/敏捷开发":{"slug":"2023/敏捷开发","filePath":"2023/敏捷开发.md","title":"敏捷开发","links":["2023/敏捷开发的问题"],"tags":["ComputerScience/Development/Agile","ComputerScience/ProjectManagement"],"content":"敏捷开发的原则\n\n传递消息最有效率效果最后的方式是面对面的交谈，而不是通过流程和工具\n一个能用的软件好过一个详尽的文档\n和客户的持续合作和沟通好过合同谈判\n用灵活的计划面对快速的需求变化\n\n如何实行\n第一重要的原则就是事实求是，结合开发团队的现状去实践敏捷开发的原则，符合就用，不符合就无需按照原则去强行改造，我们应该通过实践去改造理论，而不能照着理论去改变实践，而大多数的 SCRUM 培训做的正好就是强化理论，而不管实践。\n第二重要的原则，软件开发的目的是开发出符合需求的能运行的软件，所以产出是衡量一个团队效率的最终标准，而不是 SCRUM 和 Sprint 中产出的各种文档和数据。\nAgile is not scrum or sprint\nScrum 和 sprint 都不是 Agile， 只是一种管理的方法论，所以在实践 Agile 的过程中应该去其糟粕，取其精华。\n在实践 Agile 的过程中也应当努力避免Transclude of 敏捷开发的问题\n参考链接\n\nYou’re doing agile wrong\nagile manifesto\n"},"2023/敏捷开发的问题":{"slug":"2023/敏捷开发的问题","filePath":"2023/敏捷开发的问题.md","title":"敏捷开发的问题","links":[],"tags":["ComputerScience/Development","ComputerScience/Development/Agile"],"content":"\n相对于传统的瀑布开发模型，敏捷编程产生的原因是基于更注重编程人员，而轻流程的原则而诞生的，但是经过这么多年的发展，敏捷编程逐渐的偏离的其原本产生的原因，现在的 Scrum 更多的是重流程而轻人力，所有成员每天都要参与繁琐流程。\nScrum 中有很多没有必要的流程，比如每日早晨的站会，对于一些团队来说，取消站会可以增加开发人员的效率，因为他们可以随时开始一天的工作，并且不担心会被打断。\nSprint Review 在很多团队中都是不需要的，Story holder 可以每天从团队得到反馈，而不需要在 Sprint 结束时专门空出时间来展示。对于有完整的自动化 CI 的团队，Story holder 完全可以通过自己查看最新的未发布版本来知道开发进度。\nSprint 将本来就是持续集成的开发流程切割成了一段段的时间段，这一点并不是特别的符合现在最新的开发模式，毕竟 Scrum 概念兴起的时候，持续集成的概念和工具还未提出。\nAgile 之所以变成重流程而轻人力的原因是因为开发团队的不断壮大，有了更多的层级结构之后，上层的管理人员需要通过这个流程去获取管理团队的数据，比如 Jira 可以通过简单的配置生成复杂的报表，所以整个流程变的更多是面向上层管理的工具，而轻视了真正的开发人员。\n\n那该如何改进？\n\n尽量的减少 Scrum 中团队不适合当前团队的流程\n如果上层管理者需要数据，更多的通过自动化的方式去获取，比如分析项目的 Commits ，自动化测试的报告等\n\n参考连接\n\nHow Agile failed software developers and why SCRUM is a bad idea\nYou’re doing agile wrong\nScrum.org\u000e\n"},"2023/潮汐锁定":{"slug":"2023/潮汐锁定","filePath":"2023/潮汐锁定.md","title":"潮汐锁定","links":[],"tags":["天文物理"],"content":"潮汐锁定（或同步自转、受俘自转）发生在重力梯度使天体永远以同一面对着另一个天体；例如，月球永远以同一面朝向着地球。潮汐锁定的天体绕自身的轴旋转一圈要花上绕着同伴公转一圈相同的时间。这种同步自转导致一个半球固定不变的朝向伙伴。通常，在给定的任何时间里，只有卫星会被所环绕的更大天体潮汐锁定，但是如果两个天体的物理性质和质量的差异都不大时，各自都会被对方潮汐锁定，这种情况就像冥王星与卡戎。理论上，较小的天体也可以潮汐锁定比自身大数倍的天体，但需要十分长的时间，大多数情况下，在两个天体被摧毁前也无法实现。\n这种效应被使用在一些人造卫星的稳定上。\n参考连接\nWiki"},"2023/用-Scheme-简单解释停机问题":{"slug":"2023/用-Scheme-简单解释停机问题","filePath":"2023/用 Scheme 简单解释停机问题.md","title":"用 Scheme 简单解释停机问题","links":["2024/The-Little-Schemer---Ten-Commandments"],"tags":["Programming/Scheme","ComputerScience/ComputationalTheory"],"content":"在「The Little Schemer」书中的第九章中给出了一个简单的为什么无法定义 will-stop? 函数的解释。\n首先我们定义一个不会停机的函数：\n(define eternity\n  (lambda (x)\n    (eternity x)))\n假设我们可以定义一个函数来判断输入的函数是否会停止，当输入的函数会停止时 will-stop? 返回 #t 否则返回 #f ：\n(define will-stop?\n  (lambda (f)\n    ...))\n \n(will-stop? eternity) ;; return #f\n我们试着使用定义好的 will-stop? 函数来测试如下函数是否会停止：\n(define last-try\n  (lambda (x)\n    (and (will-stop? last-try)   ;; INNER\n         (eternity x))))\n \n(will-stop? last-try)            ;; OUTER\n我们仔细观察函数调用 (will-stop? last-try) 就会发现其中存在悖论。\n\n\n如果 last-try 会停止，那么 INNER 行的调用应该返回 #t ，意味着 and 条件中的 (eternity x)会执行，导致 last-try 函数不会停止。\n\n\n如果 last-try不会停止，那么 INNER 行的调用返回 #f，意味着 last-try 函数不会执行 (eternity x)，那么 last-try 就会停止。\n\n\n所以无论 last-try 是否停止都会产生悖论。will-stop? 是一个我们可以准确描述，但是无法用我们的变成语言来定义的函数。\n参考连接：\n\nWiki:Halting problem\n「The Little Schemer」Chapter 9\n"},"2023/空战博弈的关键因素":{"slug":"2023/空战博弈的关键因素","filePath":"2023/空战博弈的关键因素.md","title":"空战博弈的关键因素","links":[],"tags":["军事"],"content":"空战发展中空战博弈的关键因素也在发生改变，其主要影响因素为空战使用的武器（机炮，导弹等），主要总结为三个阶段：\n\n机动为王\n机炮和近距离格斗格斗弹为主的时代，空战中要获得优势首要的是通过飞机的机动能力在狗斗中获取到优势位置，对手飞机的尾部，所以战机设计强调的是飞机本身的机动能力。\n这时的格斗弹需要先用火控雷达锁定地方才能发射。\n信息为王\n超视距空空弹，雷达技术的发展使得先发现敌方的战机有绝对的优势，空战比的是谁能更先发现对方，雷达和电子战为盾矛两面，雷达用于发现敌机，但敌机在被雷达照射时也会对等获得己方信息。\n超视距的空空弹，可以先通过后方的雷达标记地方大概位置，在导弹到达大概位置后在自动开启导弹的火控雷达以锁定目标。\n智能为王\n信息体系继续拓展，所有的战斗单位都能参与到目标搜寻与侦查的过程中，可以在离敌机较远的 A 上发现目标，再在离目标较近的 B 单位上发射导弹；有人战机与无人战机协同工作；因为集合了各种信息，所以单个飞行员处理的信息速度不够快，需要智能的辅助系统。\n\n美国未来趋势:\n\n扩大隐身机队\n加速发展六代机\n加速研制新一代轰炸机 B-21\n构建 4+1 作战体系\n"},"2023/设置-neovim-透明背景":{"slug":"2023/设置-neovim-透明背景","filePath":"2023/设置 neovim 透明背景.md","title":"设置 neovim 透明背景","links":["Vim","Neovim"],"tags":["Software/Editor/Vim"],"content":"Vim/Neovim 中简单的让背景变透明的办法是设置 highlight group，具体而言通过下面这条命令就行。\nhi Normal guibg=None\n稍微解释下，hi 是设置 Vim highlight 的命令，这里我们调整 Normal Highlight Group 的设置，将其背景色设置为无。\nVim 中可以通过命令 :h highlight-groups 查询到所有的 builtin highlight group。\nSee Also: StackOverflow"},"2024/2024经济国九条":{"slug":"2024/2024经济国九条","filePath":"2024/2024经济国九条.md","title":"2024经济国九条","links":[],"tags":["Reference","政治经济/中央政策"],"content":"国务院关于加强监管防范风险推动资本市场高质量发展的若干意见\n国发〔2024〕10 号\n各省、自治区、直辖市人民政府，国务院各部委、各直属机构：\n党的十八大以来，我国资本市场快速发展，在促进资源优化配置、推动经济快速发展和社会长期稳定、支持科技创新等方面发挥了重要作用。为深入贯彻中央金融工作会议精神，进一步推动资本市场高质量发展，现提出以下意见。\n一、总体要求\n以习近平新时代中国特色社会主义思想为指导，全面贯彻党的二十大和二十届二中全会精神，贯彻新发展理念，紧紧围绕打造安全、规范、透明、开放、有活力、有韧性的资本市场，坚持把资本市场的一般规律同中国国情市情相结合，坚守资本市场工作的政治性、人民性，以强监管、防风险、促高质量发展为主线，以完善资本市场基础制度为重点，更好发挥资本市场功能作用，推进金融强国建设，服务中国式现代化大局。\n深刻把握资本市场高质量发展的主要内涵，在服务国家重大战略和推动经济社会高质量发展中实现资本市场稳定健康发展。必须坚持和加强党的领导，充分发挥党的政治优势、组织优势、制度优势，确保资本市场始终保持正确的发展方向；必须始终践行金融为民的理念，突出以人民为中心的价值取向，更加有效保护投资者特别是中小投资者合法权益，助力更好满足人民群众日益增长的财富管理需求；必须全面加强监管、有效防范化解风险，稳为基调、严字当头，确保监管“长牙带刺”、有棱有角；必须始终坚持市场化法治化原则，突出目标导向、问题导向，进一步全面深化资本市场改革，统筹好开放和安全；必须牢牢把握高质量发展的主题，守正创新，更加有力服务国民经济重点领域和现代化产业体系建设。\n未来 5 年，基本形成资本市场高质量发展的总体框架。投资者保护的制度机制更加完善。上市公司质量和结构明显优化，证券基金期货机构实力和服务能力持续增强。资本市场监管能力和有效性大幅提高。资本市场良好生态加快形成。到 2035 年，基本建成具有高度适应性、竞争力、普惠性的资本市场，投资者合法权益得到更加有效的保护。投融资结构趋于合理，上市公司质量显著提高，一流投资银行和投资机构建设取得明显进展。资本市场监管体制机制更加完备。到本世纪中叶，资本市场治理体系和治理能力现代化水平进一步提高，建成与金融强国相匹配的高质量资本市场。\n二、严把发行上市准入关\n进一步完善发行上市制度。提高主板、创业板上市标准，完善科创板科创属性评价标准。提高发行上市辅导质效，扩大对在审企业及相关中介机构现场检查覆盖面。明确上市时要披露分红政策。将上市前突击“清仓式”分红等情形纳入发行上市负面清单。从严监管分拆上市。严格再融资审核把关。\n强化发行上市全链条责任。进一步压实交易所审核主体责任，完善股票上市委员会组建方式和运行机制，加强对委员履职的全过程监督。建立审核回溯问责追责机制。进一步压实发行人第一责任和中介机构“看门人”责任，建立中介机构“黑名单”制度。坚持“申报即担责”，严查欺诈发行等违法违规问题。\n加大发行承销监管力度。强化新股发行询价定价配售各环节监管，整治高价超募、抱团压价等市场乱象。从严加强募投项目信息披露监管。依法规范和引导资本健康发展，加强穿透式监管和监管协同，严厉打击违规代持、以异常价格突击入股、利益输送等行为。\n三、严格上市公司持续监管\n加强信息披露和公司治理监管。构建资本市场防假打假综合惩防体系，严肃整治财务造假、资金占用等重点领域违法违规行为。督促上市公司完善内控体系。切实发挥独立董事监督作用，强化履职保障约束。\n全面完善减持规则体系。出台上市公司减持管理办法，对不同类型股东分类施策。严格规范大股东尤其是控股股东、实际控制人减持，按照实质重于形式的原则坚决防范各类绕道减持。责令违规主体购回违规减持股份并上缴价差。严厉打击各类违规减持。\n强化上市公司现金分红监管。对多年未分红或分红比例偏低的公司，限制大股东减持、实施风险警示。加大对分红优质公司的激励力度，多措并举推动提高股息率。增强分红稳定性、持续性和可预期性，推动一年多次分红、预分红、春节前分红。\n推动上市公司提升投资价值。制定上市公司市值管理指引。研究将上市公司市值管理纳入企业内外部考核评价体系。引导上市公司回购股份后依法注销。鼓励上市公司聚焦主业，综合运用并购重组、股权激励等方式提高发展质量。依法从严打击以市值管理为名的操纵市场、内幕交易等违法违规行为。\n四、加大退市监管力度\n深化退市制度改革，加快形成应退尽退、及时出清的常态化退市格局。进一步严格强制退市标准。建立健全不同板块差异化的退市标准体系。科学设置重大违法退市适用范围。收紧财务类退市指标。完善市值标准等交易类退市指标。加大规范类退市实施力度。进一步畅通多元退市渠道。完善吸收合并等政策规定，鼓励引导头部公司立足主业加大对产业链上市公司的整合力度。进一步削减“壳”资源价值。加强并购重组监管，强化主业相关性，严把注入资产质量关，加大对“借壳上市”的监管力度，精准打击各类违规“保壳”行为。进一步强化退市监管。严格退市执行，严厉打击财务造假、操纵市场等恶意规避退市的违法行为。健全退市过程中的投资者赔偿救济机制，对重大违法退市负有责任的控股股东、实际控制人、董事、高管等要依法赔偿投资者损失。\n五、加强证券基金机构监管，推动行业回归本源、做优做强\n推动证券基金机构高质量发展。引导行业机构树立正确经营理念，处理好功能性和盈利性关系。加强行业机构股东、业务准入管理，完善高管人员任职条件与备案管理制度。完善对衍生品、融资融券等重点业务的监管制度。推动行业机构加强投行能力和财富管理能力建设。支持头部机构通过并购重组、组织创新等方式提升核心竞争力，鼓励中小机构差异化发展、特色化经营。\n积极培育良好的行业文化和投资文化。完善与经营绩效、业务性质、贡献水平、合规风控、社会文化相适应的证券基金行业薪酬管理制度。持续开展行业文化综合治理，建立健全从业人员分类名单制度和执业声誉管理机制，坚决纠治拜金主义、奢靡享乐、急功近利、“炫富”等不良风气。\n六、加强交易监管，增强资本市场内在稳定性\n促进市场平稳运行。强化股市风险综合研判。加强战略性力量储备和稳定机制建设。集中整治私募基金领域突出风险隐患。完善市场化法治化多元化的债券违约风险处置机制，坚决打击逃废债行为。探索适应中国发展阶段的期货监管制度和业务模式。做好跨市场跨行业跨境风险监测应对。\n加强交易监管。完善对异常交易、操纵市场的监管标准。出台程序化交易监管规定，加强对高频量化交易监管。制定私募证券基金运作规则。强化底线思维，完善极端情形的应对措施。严肃查处操纵市场恶意做空等违法违规行为，强化震慑警示。\n健全预期管理机制。将重大经济或非经济政策对资本市场的影响评估内容纳入宏观政策取向一致性评估框架，建立重大政策信息发布协调机制。\n七、大力推动中长期资金入市，持续壮大长期投资力量\n建立培育长期投资的市场生态，完善适配长期投资的基础制度，构建支持“长钱长投”的政策体系。大力发展权益类公募基金，大幅提升权益类基金占比。建立交易型开放式指数基金（ETF）快速审批通道，推动指数化投资发展。全面加强基金公司投研能力建设，丰富公募基金可投资产类别和投资组合，从规模导向向投资者回报导向转变。稳步降低公募基金行业综合费率，研究规范基金经理薪酬制度。修订基金管理人分类评价制度，督促树牢理性投资、价值投资、长期投资理念。支持私募证券投资基金和私募资管业务稳健发展，提升投资行为稳定性。\n优化保险资金权益投资政策环境，落实并完善国有保险公司绩效评价办法，更好鼓励开展长期权益投资。完善保险资金权益投资监管制度，优化上市保险公司信息披露要求。完善全国社会保障基金、基本养老保险基金投资政策。提升企业年金、个人养老金投资灵活度。鼓励银行理财和信托资金积极参与资本市场，提升权益投资规模。\n八、进一步全面深化改革开放，更好服务高质量发展\n着力做好科技金融、绿色金融、普惠金融、养老金融、数字金融五篇大文章。推动股票发行注册制走深走实，增强资本市场制度竞争力，提升对新产业新业态新技术的包容性，更好服务科技创新、绿色发展、国资国企改革等国家战略实施和中小企业、民营企业发展壮大，促进新质生产力发展。加大对符合国家产业政策导向、突破关键核心技术企业的股债融资支持。加大并购重组改革力度，多措并举活跃并购重组市场。健全上市公司可持续信息披露制度。\n完善多层次资本市场体系。坚持主板、科创板、创业板和北交所错位发展，深化新三板改革，促进区域性股权市场规范发展。进一步畅通“募投管退”循环，发挥好创业投资、私募股权投资支持科技创新作用。推动债券和不动产投资信托基金（REITs）市场高质量发展。稳慎有序发展期货和衍生品市场。\n坚持统筹资本市场高水平制度型开放和安全。拓展优化资本市场跨境互联互通机制。拓宽企业境外上市融资渠道，提升境外上市备案管理质效。加强开放条件下的监管能力建设。深化国际证券监管合作。\n九、推动形成促进资本市场高质量发展的合力\n推动加强资本市场法治建设，大幅提升违法违规成本。推动修订证券投资基金法。出台上市公司监督管理条例，修订证券公司监督管理条例，加快制定公司债券管理条例，研究制定不动产投资信托基金管理条例。推动出台背信损害上市公司利益罪的司法解释、内幕交易和操纵市场等民事赔偿的司法解释，以及打击挪用私募基金资金、背信运用受托财产等犯罪行为的司法文件。\n加大对证券期货违法犯罪的联合打击力度。健全线索发现、举报奖励等机制。完善证券执法司法体制机制，提高行政刑事衔接效率。强化行政监管、行政审判、行政检察之间的高效协同。加大行政、民事、刑事立体化追责力度，依法从严查处各类违法违规行为。加大证券纠纷特别代表人诉讼制度适用力度，完善行政执法当事人承诺制度。探索开展检察机关提起证券民事公益诉讼试点。进一步加强资本市场诚信体系建设。\n深化央地、部际协调联动。强化宏观政策协同，促进实体经济和产业高质量发展，为资本市场健康发展营造良好的环境。落实并完善上市公司股权激励、中长期资金、私募股权创投基金、不动产投资信托基金等税收政策，健全有利于创新资本形成和活跃市场的财税体系。建立央地和跨部门监管数据信息共享机制。压实地方政府在提高上市公司质量以及化解处置债券违约、私募机构风险等方面的责任。\n打造政治过硬、能力过硬、作风过硬的监管铁军。把政治建设放在更加突出位置，深入推进全面从严治党，锻造忠诚干净担当的高素质专业化的资本市场干部人才队伍。坚决破除“例外论”、“精英论”、“特殊论”等错误思想。从严从紧完善离职人员管理，整治“影子股东”、不当入股、政商“旋转门”、“逃逸式辞职”等问题。铲除腐败问题产生的土壤和条件，坚决惩治腐败与风险交织、资本与权力勾连等腐败问题，营造风清气正的政治生态。\n国务院\n2024 年 4 月 4 日"},"2024/Abstract-Data-Type":{"slug":"2024/Abstract-Data-Type","filePath":"2024/Abstract Data Type.md","title":"Abstract Data Type","links":["Computer-Science","2024/Data-Structure","Programming-Language","2024/Stack","2024/Queue","2024/Tree","2024/Graph","Set"],"tags":["ComputerScience/DataStructure"],"content":"抽象数据类型（英语：Abstract data type，缩写：ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。\n就像是编程语言中的接口，只定义了操作的方法，而不规定实际的具体实现。比较明显的例子有：\n\n栈\n队列\n树\n图\n集合\n"},"2024/Access-types-in-solidity":{"slug":"2024/Access-types-in-solidity","filePath":"2024/Access types in solidity.md","title":"Access types in solidity","links":[],"tags":["Programming/Solidity"],"content":"There are four types of access in solidity:\n\npublic - can be used when contract was deployed, can be used in inherited contract\nexternal - can be used when contract was deployed , can NOT be used in inherited contract\ninternal - can NOT be used when contract was deployed , can be used in inherited contract\nprivate - can NOT be used when contract was deployed, can NOT be used in inherited contract\n\npragma solidity ^0.8;\n \ncontract Parent {\n    bool internal internalProperty;\n    bool private privateProperty;\n}\n \ncontract Child is Parent {\n    function foo() external {\n        // ok\n        internalProperty = true;\n \n        // error, not visible\n        privateProperty = true;\n    }\n}"},"2024/Binary-Search-Tree":{"slug":"2024/Binary-Search-Tree","filePath":"2024/Binary Search Tree.md","title":"Binary Search Tree","links":["2023/Binary-Tree"],"tags":["DataStructure/Tree"],"content":"二叉搜索树（Binary Search Tree） 是一种特殊的二叉树，除了满足二叉树的定义，它还需要满足以下的条件：\n\n节点的左子树中所有节点的值都小于当前节点\n节点的右子树中所有节点的值都大于当前节点\n左子树和右子树本身也是二叉搜索树 (BST)\n\n对于一个二叉搜索树来说，其中序遍历的结果是一个升序的列表。"},"2024/Breadth-First-Search":{"slug":"2024/Breadth-First-Search","filePath":"2024/Breadth First Search.md","title":"Breadth First Search","links":["2024/Tree","2024/Graph","2024/Depth-First-Search","2024/Queue"],"tags":["Algorithm/Trees"],"content":"广度优先搜索（Breadth-First Search, BFS） 是一种用于遍历或搜索树或图的算法。不同于DFS，它从一个起始节点开始，首先访问所有相邻的节点，然后再逐层向外扩展，访问下一个层级的节点，直到所有节点都被访问或找到目标节点为止。\nBFS 基本步骤:\n\n初始化：创建一个队列来存储待访问的节点，并将起始节点加入队列。同时，创建一个集合或数组来记录已访问的节点，以避免重复访问。\n访问节点：\n\n从队列中取出一个节点，标记为已访问。\n访问该节点并处理（例如，打印节点值或检查是否为目标节点）。\n将所有未被访问的相邻节点加入队列。\n\n\n重复：重复步骤 2，直到队列为空或找到目标节点。\n\nBFS 的特点\n\n层次遍历：BFS 按层次访问节点，适合用于寻找最短路径（在无权图中）。\n使用队列：BFS 使用队列来管理待访问的节点，确保先访问的节点先被处理。\n时间复杂度：对于图的 BFS，时间复杂度为 O(V + E) ，其中 V 是节点数，E 是边数。\n空间复杂度：空间复杂度通常为 O(V)，用于存储队列和已访问节点。\n\nBFS 的应用\n\n最短路径：在无权图中，BFS 可以用于寻找从起始节点到目标节点的最短路径。\n图的连通性：可以用来检查图的连通性。\n层次遍历：在树结构中，BFS 可以用于层次遍历，输出每一层的节点。\n网络流：在网络流问题中，BFS 用于寻找增广路径。\n"},"2024/Change-Default-Shell-in-Linux":{"slug":"2024/Change-Default-Shell-in-Linux","filePath":"2024/Change Default Shell in Linux.md","title":"Change Default Shell in Linux","links":[],"tags":["Linux/Command"],"content":"使用 chsh 命令（这个办法同样适用于 macOS）\n$ sudo chsh -S NEW_SHELL USERNAME\n例如：\n$ sudo chsh -S /usr/bin/fish max\n或者直接使用文本编辑器编辑 /etc/passwd 文件，找到要修改的用户名，将最后的字段修改为新的 shell 路径即可。\n\n\n                  \n                  Tips \n                  \n                \n\n如果不确定要使用的 shell 的路径，可以通过 which 命令查看\n$ which fish\n/usr/bin/fish\n\n"},"2024/Complete-Binary-Tree":{"slug":"2024/Complete-Binary-Tree","filePath":"2024/Complete Binary Tree.md","title":"Complete Binary Tree","links":["2023/Binary-Tree","2023/Binary-Heap"],"tags":["DataStructure/Tree"],"content":"一颗二叉树中，除了最后一层外其余层节点都是满的，并且最后一层要么是满的，要么在右边连续缺少若干叶子节点的二叉树称为 完全二叉树（Complete Binary Tree）。\n完全二叉树有个重要的特点是可以通过数组来顺序存储，对于索引为 i 节点，它的左子节点为 2(i+1) - 1 \\to 2i + 1 ， 右子节点为 2(i + 1) +1 - 1 \\to 2i + 2 ，父节点为 \\left\\lfloor\\frac{i+1}{2}\\right\\rfloor - 1 。\n\n这种存储结构常被用于实现 Binary Heap (完全二叉树的一种), 并用于实现堆排序。"},"2024/Concurrent--and--Parallel":{"slug":"2024/Concurrent--and--Parallel","filePath":"2024/Concurrent & Parallel.md","title":"Concurrent & Parallel","links":[],"tags":["ComputerScience/OperatingSystem"],"content":"并发（Concurrent）是轮流处理，并行（Parallel）是同时处理。参考下面这张 Joe Armstrong (Erlang creator) 画的图。\n\n\n\n并发(Concurrent) 是多个队列使用同一个咖啡机，然后两个队列轮换着使用（未必是 1:1 轮换，也可能是其它轮换规则），最终每个人都能接到咖啡\n\n\n并行(Parallel) 是每个队列都拥有一个咖啡机，最终也是每个人都能接到咖啡，但是效率更高，因为同时可以有两个人在接咖啡\n\n"},"2024/Data-Structure":{"slug":"2024/Data-Structure","filePath":"2024/Data Structure.md","title":"Data Structure","links":["2024/Array","2023/Linked-List","2024/Stack","2024/Queue","2024/Tree","2024/Graph"],"tags":["DataStructure","MOC"],"content":"数据结构 是计算机科学中的一种基本概念，它指的是数据在计算机中的组织和存储方式。数据结构决定了数据如何被存储、检索和操作，从而影响着程序的效率和性能。\n有以下的几个基本类型：\n线性数据结构:\n\n数组\n链表\n栈\n队列\n\n非线性数据结构：\n\n树\n图\n"},"2024/Depth-First-Search":{"slug":"2024/Depth-First-Search","filePath":"2024/Depth First Search.md","title":"Depth First Search","links":["2024/Tree","2024/Graph","2024/Breadth-First-Search","2024/Stack"],"tags":["Algorithm/Trees"],"content":"深度优先搜索（Depth-First Search, DFS） 是一种用于遍历或搜索树或图的算法。和BFS相反，它从一个起始节点开始，尽可能深入地探索每个分支，直到达到一个没有未访问子节点的节点，然后回溯到上一个节点，继续探索其他分支。DFS 可以使用递归或栈来实现。\nDFS 的基本步骤\n\n\n初始化：选择一个起始节点，并将其标记为已访问。可以使用一个栈或递归来管理待访问的节点。\n\n\n访问节点：\n\n访问当前节点并处理（例如，打印节点值或检查是否为目标节点）。\n遍历当前节点的所有未被访问的相邻节点，依次进行 DFS。\n\n\n\n回溯：当所有相邻节点都被访问后，回溯到上一个节点，继续探索其他未访问的分支。\n\n\nDFS 的特点\n\n深度优先：DFS 尽可能深入每个分支，适合用于寻找路径或解决问题的深层结构。\n使用栈：DFS 可以使用显式的栈来管理待访问的节点，或者使用递归调用栈。\n时间复杂度：对于图的 DFS，时间复杂度为 O(V + E) ，其中 V 是节点数，E 是边数。\n空间复杂度：空间复杂度通常为 O(V)，用于存储已访问节点和栈。\n"},"2024/Double-Linked-List":{"slug":"2024/Double-Linked-List","filePath":"2024/Double Linked List.md","title":"Double Linked List","links":["2023/Linked-List","2024/Go-Programming-Language"],"tags":["DataStructure/LinkedList"],"content":"双向链表（Double Linked List） 是链表的一个子类，顾名思义，比起链表中每个元素中有一个指向下一个元素的指针，双向链表中还多包含一个指向上一个元素的指针，这使得双向链表既可以向后，也可以向前遍历。\n┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐\n│  Node  │    │  Node  │    │  Node  │    │  Node  │\n│--------│    │--------│    │--------│    │--------│\n│  Data  │    │  Data  │    │  Data  │    │  Data  │\n│        │    │        │    │        │    │        │\n│  Next ----&gt; │  Next ----&gt; │  Next ----&gt; │  None  │\n|  None  | &lt;---- Prev  | &lt;---- Prev  | &lt;---- Prev  |\n└────────┘    └────────┘    └────────┘    └────────┘\nHead         Node1       Node2       Tail\n除了可以向两个方向遍历，双向链表在删除元素时也可以直接通过指向该元素的指针直接操作，而不需要重新找寻上一个元素。\n这些特性使得双向链表虽然比链表更加复杂，但更适合特定的场景，比如 LRU Cache。\n也因为更加复杂和实用，很多编程语言都在标准库中提供对双向链表的支持，比如Golang 内置的包 container/list。所以在自己实现之前可以先参考语言文档，不需要重复造轮子。"},"2024/Fix-flatpak-gnome-proxy":{"slug":"2024/Fix-flatpak-gnome-proxy","filePath":"2024/Fix flatpak gnome proxy.md","title":"Fix flatpak gnome proxy","links":[],"tags":["Linux","Linux/Gnome"],"content":"问题\nGnome 环境下，flatpak 的程序不会继承 Settings 里面或 shell 环境变量设置的代理，导致程序无法连接网络。\n解决办法\n使用命令：\nflatpak run --command=sh 包名\n进入沙箱环境的 shell。然后在这个 shell 里设置系统代理：\n# 系统代理模式设置为手动\ngsettings set org.gnome.system.proxy mode manual\n# 设置 HTTP 代理\ngsettings set org.gnome.system.proxy.http host 127.0.0.1\ngsettings set org.gnome.system.proxy.http port 7890\n# 设置 HTTPS 代理\ngsettings set org.gnome.system.proxy.https host 127.0.0.1\ngsettings set org.gnome.system.proxy.https port 7890\n# 设置 Socks 代理\ngsettings set org.gnome.system.proxy.socks host 127.0.0.1\ngsettings set org.gnome.system.proxy.socks port 7891"},"2024/Floyd-判圈算法":{"slug":"2024/Floyd-判圈算法","filePath":"2024/Floyd 判圈算法.md","title":"Floyd 判圈算法","links":["2023/Linked-List"],"tags":["Algorithm","DataStructure/LinkedList"],"content":"在链表的问题中，使用快慢指针的技巧可以解决判断链表中是否存在环的问题，但如果我们需要知道环的入口在哪儿的话该怎们办呢？我们可以更进一步的研究这个问题。\nflowchart LR\n\n%% nodes\n\na((A)) --&gt; b((B)) --&gt; c((C)) --&gt; d((D)) --&gt; e((E)) --&gt; f((F))\nf --&gt; c\n\n以上图的链表所示，我们假设从头到第一个环的距离为 p ，环的长度为 c , 快慢指针相遇时的点距离环入口的距离为 x ，n 和 n&#039; 表示快慢指针在环中走过的圈数，因为快指针走过的距离始终是慢指针的两倍，我们可以得出以下等式：\n2(p + n&#039;c + c - x) = p + nc + c - x\n化简可得：\np = (n - 2n&#039; - 1)c + x\n意味着，从链表头到入环点的距离 p ，恰好等于相遇点距离入环口的距离 x 加上若干圈环的距离，如果我们这时重新设置一个指针指向头，一个指针指向相遇的节点，再以每次一格的速度移动，那两个指针必定在环的入口处相遇，此时我们便找到了环的入口。"},"2024/Golang-Build-Process":{"slug":"2024/Golang-Build-Process","filePath":"2024/Golang Build Process.md","title":"Golang Build Process","links":[],"tags":["Programming/Golang"],"content":"\n\n                  \n                  Attention\n                  \n                \n\n这里的构建过程没有考虑 Golang Build Cache 的影响\n\n\nGolang 的构建过程是典型的静态编译语言的编译过程，分为编译（compile）和链接（link）两个阶段。\n包源码被编译为 .o 文件之后，会被 pack 工具打包成为 .a 文件，生成的 .a 会被放入临时构建文件夹，之后被链接成为可执行文件。\n标准库的构建过程\n标准库的源码存放在 $GOROOT/src 下，标准库编译的 .a 文件存放在 $GOROOT/pkg/ 下，构建时如果已经存在 .a 文件，则会直接链接 .a 文件，否则会从源文件中进行编译。如果想强制从标准库的源码进行重新编译，可以通过两种办法：\n\n删除相应的 .a 的文件\n使用 go build -a 参数，这会将所有的源码重新编译一边，所以构建时间可能很长\n\n非标准库的构建过程\n同标准库的构建过程不同，非标准库在构建的时候都会从源码进行构建。使用 go install 命令可以将包的 .a 文件安装到 $GOPATH/pkg/ 下，但在构建过程中会重新编译源码到 .a，重新编译的文件会被放入构建的临时目录，临时目录的下的 .a 优先级会高于 $GOPATH/pkg/ 中的 .a。\n程序构建过程\n以下面结构的项目的为例，编译是使用命令 go build -x -v 输出详细构建日志：\n$tree -F demo1\ndemo1\n├── cmd/\n│   └── app1/\n│       └── main.go\n└── pkg/\n    └── pkg1/\n        └── pkg1.go\n程序 app1 的构建过程可分为下面几步：\n\n建立临时工作目录，放入环境变量 WORK，之后的工作都已 $WORK 为当前目录\n编译 app1 的依赖包 pkg1，将目标文件打包放入 $WORK/&lt;demo1_pkg_path&gt;/pkg/pkg1.a\n编译 app1 的 main 包， 将目标文件打包后放入 $WORK/&lt;demo1_pkg_path&gt;/cmd/app1.a\n链接器将 app1.a, pkg1.a 链接成为 $WORK/&lt;demo1_pkg_path&gt;/cmd/app1/_obj/exe/a.out\n将 a.out 复制到 go build 命令执行目录，并改名为 app1\n"},"2024/Golang-Design-Philosophy":{"slug":"2024/Golang-Design-Philosophy","filePath":"2024/Golang Design Philosophy.md","title":"Golang Design Philosophy","links":[],"tags":["Programming/Golang"],"content":"追求简单，少即是多\nGo 设计者推崇“最小方式”思维，即一件事情仅有一种方式或数量尽可能少的方式去完成，这大大减少了开发人员在选择路径方式及理解他人所选路径方式上的心智负担。\n偏好组合，正交解耦\n\nGo 语言无类型体系（type hierarchy），类型之间是独立的，没有子类型的概念；\n每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的；\n接口（interface）与其实现之间隐式关联；\n包（package）之间是相对独立的，没有子包的概念。\n\n原生并发，轻量高效\n\nGo 语言为开发者提供的支持并发的语法元素和机制。\nGo 语言采用轻量级协程并发模型，使得 Go 应用在面向多核硬件时更具可扩展性。\n并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让 Go 语言更适应现代计算环境。\n\n面向工程，“自带电池”\n开箱即用的标准库、语言自带原生工具链以及开放的工具链生态。"},"2024/Golang-Init-Function":{"slug":"2024/Golang-Init-Function","filePath":"2024/Golang Init Function.md","title":"Golang Init Function","links":[],"tags":["Programming/Golang"],"content":"init 函数是个无参数，无返回值的函数，其主要作用是做一些包级数据的初始化与初始状态的检查工作。\nfunc init() {\n  ...\n}\nGolang 运行时会在包初始化时调用包中定义的 init 函数，而用户的代码是不能调用 init 函数的，编译时会报错。\n一个包内可以包含多个 init 函数，在初始化时，运行时会按照一定顺序执行所有 init 函数，并且不会并发调用，每个 init 函数都只会被执行一次。\n在一个包中 init 的执行顺序是在其他包级变量之后。\n虽然运行时会按固定的顺序执行 init 函数，但是 Golang 的习惯是不依赖 init 函数的执行次序。\n"},"2024/Golang-Interface-Runtime-Implements":{"slug":"2024/Golang-Interface-Runtime-Implements","filePath":"2024/Golang Interface Runtime Implements.md","title":"Golang Interface Runtime Implements","links":[],"tags":["Programming/Golang"],"content":"底层实现\n// $GOROOT/src/runtime/runtime2.go\ntype iface struct {\n    tab  *itab\n    data unsafe.Pointer\n}\n \ntype eface struct {\n    _type *_type\n    data  unsafe.Pointer\n}\n在 runtime 内部，interface 实际上有两种表示:\n\neface 用于表示没有方法的空接口（ empty interface ）类型变量，即 interface{} 类型的变量。\niface 用于表示其余拥有方法的接口类型变量。\n\neface 表示的空接口类型没有方法列表，所以第一个字段是一个指向当前存储变量的动态类型信息（_type），而 iface 除了存储变量的动态类型信息外，还要包含接口本身的信息，所以第一个字段指向的是一个同时包含这两个信息的结构体 itab 的指针。itab 结构体中也有指向当前存储变量的动态类型结构体（_type）的指针。\nGolang 程序运行时，运行时会为程序中所有的类型都建立只读共享的 _type 信息表，所有拥有相同类型的值会指向同一个 _type 结构体。\n判断接口是否相等\n虽然空接口与非空接口在内部表示上存在差异，可在判断两个 interface 时可以忽略这中结构上的差异，而把所有 interface 的变量内部看作由两部分构成：(T, V) 类型和值。判断是否相等时，只有 (T, V) 都相等时才相等。比如下面这个例子：\ntype MyErr struct {\n    error\n}\n \nfunc returnErr() error {\n    var e *MyErr = (*MyErr)(nil)\n    return e\n}\n \nfunc main() {\n    e := returnErr()\n    fmt.Println(e)\n    fmt.Println(e == nil)\n}\n运行结果为：\n&lt;nil&gt;\nfalse\n原因在于，当我们申明 var e *MyErr，我们实际上同时将 *MyErr 的类型信息放入 e 中(T=*MyErr, V=nil)。所以在 main 中和 nil 比较时相当于 (T=*MyErr, V=nil) == (T=nil, V=nil) 结果就是不相等。\n要解决这个问题，我们可以在 returnErr 中选择直接返回 return nil 就行。另外还要注意，这里 interface 和 struct 的不同，interface 在只是声明没有存值的情况下其内部值相当于 (T=nil, V=nil)，而 struct 在声明之后就带上了类型属性，再转换为 interface 时类型就不再为 nil。\n所以下面这样的 returnErr 的返回值可以正常判 nil：\nfunc returnErr() (e error) {\n  return\n}\n \nfunc returnErr() error {\n  var e error\n  return e\n}\nReference\n\nGolang FAQ\n《Go 语言精进之路：从新手到高手的编程思想、方法和技巧1》，白明，26.2 接口类型变量的内部表示。\n"},"2024/Golang-Interface":{"slug":"2024/Golang-Interface","filePath":"2024/Golang Interface.md","title":"Golang Interface","links":["2024/Golang-Interface-Runtime-Implements"],"tags":["Programming/Golang"],"content":"接口内部实现和判断相等的逻辑\nTransclude of Golang-Interface-Runtime-Implements\n接口的装箱操作\n装箱（Boxing）是编程语言领域的一个基础概念，一般指把值类型转换为引用类型。Golang 中把实际类型转化为接口类型可以看作装箱操作，通过调用 runtime/iface.go 中的 convT 实现，基本逻辑就是读取传入类型的类型信息，再分配内存将原有的数据信息复制过去，所有这里是有性能的损耗的，Golang 也为很多内置的类型都做了优化。\nGolang 尽量定义小接口\nGolang 中推荐定义方法数量一般不超过 3 的小接口，因为小接口有这几个优势。\n\n接口越小，抽象程度越高，被接纳度越高。\n易于实现和测试。\n契约职责单一，易于复用组合。\n"},"2024/Golang-Internal-Package":{"slug":"2024/Golang-Internal-Package","filePath":"2024/Golang Internal Package.md","title":"Golang Internal Package","links":[],"tags":["Programming/Golang"],"content":"Golang 默认暴露项目下所有的包目录给外部使用，如果有的包需要只供当前包使用，则可以将其放入 internal 目录。\n以下面的项目结构为例：\n// 带internal的Go库项目结构\n \n$tree -F ./chapter2/sources/GoLibProj\nGoLibProj\n├── LICENSE\n├── Makefile\n├── README.md\n├── go.mod\n├── internal/\n│  ├── ilib1/\n│  └── ilib2/\n├── lib.go\n├── lib1/\n│  └── lib1.go\n└── lib2/\n      └── lib2.go\nilib1, ilib2 包可以被当前项目的其他包 lib.go, lib1, lib2 引用，但不能其他引用 GoLibProj 的项目引用。\n\n\n                  \n                  Info\n                  \n                \n\ninternal 不止仅仅可以存在与项目的根目录，也可以放入任何的子目录中，其引用范围也会相应缩小。\n\n"},"2024/Golang-Map":{"slug":"2024/Golang-Map","filePath":"2024/Golang Map.md","title":"Golang Map","links":["2024/Golang-Slice"],"tags":["Programming/Golang","DataStructure/Hashmap"],"content":"map 实现与 slice 的不同\nslice 实际是个值类型，其中包含了一个指向底层数组的指针，而 map 可以理解为引用类型， make(map[Type][Type]) 创建的 map 实际包含一个指向实际 hmap 结构的指针，所以在函数调用中对 map 的修改都会对外层可见。\n同时 map 并不支持零值可用，对没有显式赋值的 map 操作会导致 panic。\nmap 的 key 和 value 类型\nmap 对 value 的类型没有要求，但对 key 的类型有要求，key 的类型应该是 comparable 的，其类型严格定义了 == 和 != 操作符行为。所以 function, map, slice 不能作为 map 的 key。\n另外，放入 map 中的 key 和 value 都不可取地址，即不可以用 &amp; 操作符获得其指针。\nmap 遍历的顺序是不确定的\n这是故意设计的，程序不应当依赖 hashmap 的顺序。\nmap 删除 key 时不会自动缩容\n同 slice 一样 map 也不会自动缩容，如果程序中有生命周期长的 map 也应当考虑手动缩容的操作。\n\ngithub.com/golang/go/issues/20135\n\nmap 的内部实现\nmap 的实现在 runtime/map.go 中, 主要的类型为 hmap。\n// A header for a Go map.\ntype hmap struct {\n\tcount     int // # live cells == size of map.  Must be first (used by len() builtin)\n\tflags     uint8\n\tB         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)\n\tnoverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details\n\thash0     uint32 // hash seed\n \n\tbuckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.\n\toldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing\n\tnevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)\n \n\textra *mapextra // optional fields\n}\n具体的实现可以参照下面这张图：\n\n\n\n                  \n                  Tips \n                  \n                \n\ngo 1.24 之后，golang 的 map 采用了新的基于 SwissTable 的实现，显著提升了大型 map 的访问速度\n\n\nconcurrent map\n本身 map 并不支持并发访问，如果需要并发访问，可以使用 sync.Map，其内部是通过 atomic 的原语实现，是无锁实现，会比自己使用 sync.Mutex 来实现效率要高。"},"2024/Golang-Name-Convention":{"slug":"2024/Golang-Name-Convention","filePath":"2024/Golang Name Convention.md","title":"Golang Name Convention","links":[],"tags":["Programming/Golang"],"content":"命名原则\n\n简单且一致\n利用上下文辅助命名\n\n包名\n\n一般建议小写形式的单个单词命名。\n尽量保持与包导入路径的最后一部分保持一致，尽量意味着可以不保持一致，比如：go-nsq 的路径为 go-nsq, 包名为 nsq。\n\n变量、类型、函数和方法\n\n采用驼峰命名 CamelCase。\n首字母大写表示导出。\n不应该有包名的前缀，应为导出的变量都需要使用 package.Export 的方式引用。\n专用的缩写词应该保持大写，比如：HTTP。\n名称中不应该带有类型信息。\n对于上下文明确的变量可以使用简短命名，比如: i, k。\n常量不需要可以的大写。\n\n接口\n对于接口类型优先以单个单词命名。对于拥有唯一方法（method）或通过多个拥有唯一方法的接口组合而成的接口，Go 语言的惯例是用“方法名+er”命名。\n// $GOROOT/src/io/io.go\n \ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n \ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n \ntype Closer interface {\n    Close() error\n}\n \ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}"},"2024/Golang-Package-Search-Path":{"slug":"2024/Golang-Package-Search-Path","filePath":"2024/Golang Package Search Path.md","title":"Golang Package Search Path","links":[],"tags":["Programming/Golang"],"content":"Golang 中有两部分的包搜索路径由两部分主成：\n基础搜索路径 + 包导入路径\n基础的搜索路径首先都包括 $GOROOT/src。在此基础上，按照 GO111MODULE 的设置不同还会增加不同的路径。\n\nGO111MODULE=off 使用传统的 gopath 模式，包基础搜索路径包含 $GOPATH/src/。\nGO111MODULE=on 使用 gomod 模式，包基础搜索路径包含 $GOPATH/pkg/mod/。\n\n包导入路径就是每个源文件头部包导入部分的路径。基础路径组合包导入路径，就构成了源文件所有依赖包的源码搜索路径。以下面的例子为例:\npackage p1\n \nimport (\n    &quot;fmt&quot;\n    &quot;time&quot;\n    &quot;github.com/bigwhite/effective-go-book&quot;\n    &quot;golang.org/x/text&quot;\n    &quot;a/b/c&quot;\n    &quot;./e/f/g&quot;\n)\n该源码包的搜索路径集合在使用 gomod 模式时可以展开为下面这样：\n- $GOROOT/src/fmt/\n- $GOROOT/src/time/\n- $GOROOT/src/github.com/bigwhite/effective-go-book/\n- $GOROOT/src/golang.org/x/text/\n- $GOROOT/src/a/b/c/\n- $GOPATH/pkg/mod/github.com/bigwhite/effective-go-book/\n- $GOPATH/pkg/mod/golang.org/x/text/\n- $GOPATH/pkg/mod/a/b/c/\n- $CWD/e/f/g\n这里也可以看出代码中 import 中的其实是路径名，而不是包名，包名由路径中源文件头部的 package 关键字指定，其可能和路径名不同，只是 Golang 惯例是和路径名保持一致。"},"2024/Golang-Package":{"slug":"2024/Golang-Package","filePath":"2024/Golang Package.md","title":"Golang Package","links":["2024/Golang-Build-Process","2024/Golang-Package-Search-Path"],"tags":["Programming/Golang"],"content":"Transclude of Golang-Build-Process\nTransclude of Golang-Package-Search-Path\n如果一个源码文件中导入两个来源不同包名相同的依赖时，通过设置包的别名来解决冲突。\npackage main\n \nimport (\n  &quot;fmt&quot;\n  myfmt &quot;github.com/q3yi/go/fmt&quot;\n)"},"2024/Golang-Rangefunc":{"slug":"2024/Golang-Rangefunc","filePath":"2024/Golang Rangefunc.md","title":"Golang Rangefunc","links":["python"],"tags":["Programming/Golang"],"content":"Golang 1.22 中加入了实验性功能 Rangefunc，使用环境变量 GOEXPERIMENT=rangefunc 来开启。\n\n\n                  \n                  Updates \n                  \n                \n\n自 Golang 1.23 起，Rangefunc 的功能已经加入了标准库中，无需使用环境变量来开启\n\n\n开启之后，就可以引用 iter 包，包含两个 type 和两个 helper functions.\ntype Seq[V any] func(yield func(V) bool)\ntype Seq2[K, V any] func(yield func(K, V) bool)\n \nfunc Pull[V any](seq Seq[V]) (next func() (V, bool), stop func())\nfunc Pull2[K, V any](seq Seq2[K, V]) (next func() (K, V, bool), stop func())\n具体的使用方法可以参考下面这个简单的例子。\npackage main\n \nimport &quot;fmt&quot;\nimport &quot;iter&quot;\n \nfunc backwards[E any](s []E) iter.Seq[E] {\n    return func(yield func(E) bool) {\n        for i := len(s) - 1; i &gt;= 0; i-- {\n            if !yield(s[i]) {\n                return\n            }\n        }\n    }\n \n}\n \nfunc main() {\n    for x := range backwards([]string{&quot;hello&quot;, &quot;world&quot;}) {\n        fmt.Println(x)\n    }\n}\n方法 iter.Pull 可以从一个 iter 对象中拉取数据，比如下面的 zip 函数。\nfunc zip[T1, T2 any](seq1 iter.Seq[T1], seq2 iter.Seq[T2]) iter.Seq2[T1, T2] {\n\treturn func(yield func(T1, T2) bool) {\n\t\tnext1, stop1 := iter.Pull(seq1)\n\t\tnext2, stop2 := iter.Pull(seq2)\n\t\tdefer stop1()\n\t\tdefer stop2()\n \n\t\tfor {\n\t\t\tv1, flg1 := next1()\n\t\t\tv2, flg2 := next2()\n\t\t\tif !flg1 || !flg2 || !yield(v1, v2) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n在实现上，Golang 实际是通过编译时 rewrite 的方法来实现的对 iter 的支持，在第一个例子中实际的代码会被 rewrite 为下面的形式。\nbackward(s)(func(x string) bool {\n    fmt.Println(x)\n    return true\n})\n这里的 return false 就相当于 break，当然有其他复杂情况需要处理，完整的 rewrite 规则可以参考源码中的注释。\n另外虽然是 rewrite 为 function 来实现，但是在 range loop 中调用 defer 也是和普通的 loop 相同，即在包含该 loop 的 function 结束时执行。\n例如下面这个例子：\npackage main\n \nimport (\n\t&quot;fmt&quot;\n\t&quot;iter&quot;\n)\n \nfunc DeferAfterYield() iter.Seq[int] {\n\tdefer fmt.Println(&quot;defer before range function&quot;)\n\treturn func(yield func(int) bool) {\n\t\tdefer fmt.Println(&quot;defer in range function&quot;)\n \n\t\tfor i := 0; i &lt; 3; i++ {\n\t\t\tyield(i)\n\t\t}\n\t}\n}\n \nfunc main() {\n\tfor x := range DeferAfterYield() {\n\t\tdefer func() {\n\t\t\tfmt.Println(&quot;defer in main loop: &quot;, x)\n\t\t}()\n \n\t\tfmt.Println(x)\n\t}\n\tfmt.Println(&quot;other operation in main&quot;)\n\tdefer func() {\n\t\tfmt.Println(&quot;defer in main&quot;)\n\t}()\n}\n其运行的结果为\ndefer before range function\n0\n1\n2\ndefer in range function\nother operation in main\ndefer in main\ndefer in main loop:  2\ndefer in main loop:  1\ndefer in main loop:  0\n通过这个例子可以发现：\n\ndefer in range function 会在 loop 结束时调用\ndefer in main loop 是在 main 函数结束时调用，同一般 loop 中使用 defer\n变量 x 在每次循环中会生成新的，闭包函数可正常的捕获，不再需要想以前需要使用 var x1 := x 来捕获，这个不是 rangefunc 中提供的功能，而是新版本的 golang 修改的，这里只是提醒一下\n再提醒下 defer 函数的执行顺序，和栈逻辑一致，后进先出\n\n说了这么多，那么 rangefunc 可以用在哪些地方呢？以下是几个例子：\n\n\n                  \n                  和 python 类似的 range 函数\n                  \n                \n\nfunc Range(start, end, step int) iter.Seq[int] {\n\tif step == 0 {\n\t\tstep = 1\n\t}\n \n\treturn func(yield func(int) bool) {\n\t\tif step &gt; 0 {\n\t\t\tfor i := start; i &lt; end; i += step {\n\t\t\t\tif !yield(i) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n \n\t\t} else {\n\t\t\tfor i := start; i &gt; end; i += step {\n\t\t\t\tif !yield(i) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\n                  \n                  用于数据库查询 \n                  \n                \n\nfunc BqQuery[E any](ctx context.Context, query *bigquery.Query) iter.Seq2[*E, error] {\n\treturn func(yield func(*E, error) bool) {\n\t\titer, err := query.Read(ctx)\n\t\tif err != nil {\n\t\t\tyield(nil, err)\n\t\t\treturn\n\t\t}\n \n\t\tfor {\n\t\t\tvar row E\n\t\t\terr := iter.Next(&amp;row)\n\t\t\tif err != nil {\n\t\t\t\tif err != iterator.Done {\n\t\t\t\t\t// call error handler\n\t\t\t\t\tif !yield(nil, err) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n \n\t\t\tif !yield(&amp;row, nil) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\n                  \n                  按行读取文件 \n                  \n                \n\nfunc Readlines(file string) iter.Seq2[[]byte, error] {\n\treturn func(yield func([]byte, error) bool) {\n\t\tf, err := os.Open(file)\n\t\tif err != nil {\n\t\t\tyield(nil, err)\n\t\t\treturn\n\t\t}\n\t\tdefer f.Close()\n \n\t\tscanner := bufio.NewScanner(f)\n\t\tfor scanner.Scan() {\n\t\t\tif !yield(scanner.Bytes(), nil) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n \n\t\tif err := scanner.Err(); err != nil {\n\t\t\tyield(nil, err)\n\t\t}\n\t}\n}\n\n\n参考连接：\nblog.perfects.engineering/go_range_over_funcs"},"2024/Golang-Runtime-Scheduler":{"slug":"2024/Golang-Runtime-Scheduler","filePath":"2024/Golang Runtime Scheduler.md","title":"Golang Runtime Scheduler","links":["2024/Threads"],"tags":["Programming/Golang"],"content":"Golang 的调度器可以描述为 GPM 模型，GPM 的含义如下：\n\nG 代表 groutine\nP 代表 logical processor，逻辑处理器，每个 G 需要运行都需要分配到一个 P\nM 代表 machine 是一个 OS Thread 的抽象，只有绑定了 M 的 P 才能真正的运行\n\nGPM 模型的样子可以抽象为下面这张图：\n\n抢占式调度\n在 go1.14 之前，Golang 的调度器是基于协作的抢占式调度，其工作原理大概如下：\n\n编译器会在调用函数前插入 runtime.morestack\nGo 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 StackPreempt\n当发生函数调度时，可能会执行编译器插入的 runtime.morestack，它调用 runtime.newstack 会检查 Goroutine 的 stackguard0 字段是否为 StackPreempt;\n如果 stackguard0 是 StackPreempt，就会触发抢占让出当前线程\n\n在 go1.14 之后，Golang 实现了基于信号（SIGURG）的抢占式调度，其调度过程大概如下：\n\n程序启动时，在 runtime.sighandler 中注册 SIGURG 信号的处理函数 runtime.doSigPreempt;\n在触发垃圾回收的栈扫描时会调用 runtime.suspendG 挂起 Goroutine，该函数执行两个功能：\n\n将 _Grunning 状态的 Goroutine 标记称可以被抢占，preemptStop 设置为 true；\n调用 runtime.preemptM 触发抢占；\n\n\nruntime.preemptM 会调用 runtime.signalM 向线程发送程序 SIGURG；\n操作系统会中断正在运行的线程并执行预先注册的信号处理函数，(1) 中注册的 runtime.doSigPreempt；\nruntime.doSigPreempt 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 runtime.sigctxt.pushCall；\nruntime.sigctxt.pushCall 会修改寄存器并在程序回到用户态时执行 runtime.asyncPreempt；\n汇编 runtime.asyncPreempt 会调用运行时函数 runtime.asyncPreempt2；\nruntime.asyncPreempt2 会调用 runtime.preemptPark;\nruntime.preemptPark 会修改当前 Goroutine 的状态到 _Gpreempted 并调用 runtime.schedule 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行。\n\nReference\n\nGo 语言设计与实现\n《Go 语言精进之路：从新手到高手的编程思想、方法和技巧 1》，32.2 goroutine 调度模型与演进过程。\n"},"2024/Golang-String":{"slug":"2024/Golang-String","filePath":"2024/Golang String.md","title":"Golang String","links":[],"tags":["Programming/Golang"],"content":"string 类型的数据是不可修改的\n无论常量还是变量，一旦声明了一个 string 类型的标识符，该标识符所指代的数据在整个程序的生命周期内便无法更改。\n这种不可变性是通过内存保护的，底层的数据存储区只能进行只读操作，即使使用 unsafe.Pointer 获取到了底层数据地址，也不能修改。\nstring 的底层表示\n// runtime/string.go\ntype stringStruct struct {\n\tstr unsafe.Pointer\n\tlen int\n}\n从这个结构体可以看出，golang 获取 string 的长度为 O(1) 时间复杂度的操作。\n另外 string 也和 slice 类型类似，类似于值类型，所以即使是巨大的 string 作为参数传递也不会有很大开销。\nstring 以 UTF8 的编码格式存储在内存中\n多行字符串\nconst s = `好雨知时节，当春乃发生。\n随风潜入夜，润物细无声。\n野径云俱黑，江船火独明。\n晓看红湿处，花重锦官城。`\nstring 构造效率\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRank(Fastest to slowest)multiplerstrings.Builder with initial size-bytes.Buffer with initial size~1.14xstrings.Join~1.16xbytes.Buffer~1.9x+ operator~2.1xstrings.Builder~2.2xfmt.Sprintf~10x\n\n\n                  \n                  结论 \n                  \n                \n\n\n做了初始化的 strings.Builder, bytes.Buffer 与 strings.Join 算第一梯队\n未初始化的 bytes.Buffer, strings.Builder 与 + 操作符算第二梯队，大概慢一倍左右\nfmt.Sprintf 最慢，差了近一个数量级\n\n\n\nstring 转换时需要拷贝\n由于 string 类型的不可变性，导致 string 转 []byte 或者 []Rune 时都会需要分配内存再拷贝数据，反之也是。\n同时为了效率，Golang 对某些特定转换做了特殊的优化。\n第一种是由于 []byte 不可比较，而 string 可以比较，所有经常需要将 []byte 转换为 string 做比较，再下面几种情况下调用 string(b) 不会分配新的内存。\n\nstring(b) 用在 map 类型的 key 中\n\nb := []byte{&#039;k&#039;, &#039;e&#039;, &#039;y&#039;}\nm := make(map[string]string)\nm[string(b)] = &quot;value&quot;\nm[[3]string{string(b), &quot;key1&quot;, &quot;key2&quot;}] = &quot;value1&quot;\n\nstring(b) 用在字符串连接语句中\n\nb := []byte{&#039;t&#039;, &#039;o&#039;, &#039;n&#039;, &#039;y&#039;}\ns := &quot;hello &quot; + string(b) + &quot;!&quot;\n\nstring(b) 用在字符串比较中\n\ns := &quot;tom&quot;\nb := []byte{&#039;t&#039;, &#039;o&#039;, &#039;n&#039;, &#039;y&#039;}\n \nif s &lt; string(b) {\n    ...\n}\n第二种情况是在 for _, v := range []byte(str) 的时候，会直接使用 string 底层的字节数组而不会复制拷贝。"},"2024/Golang-defer-function":{"slug":"2024/Golang-defer-function","filePath":"2024/Golang defer function.md","title":"Golang defer function","links":["2024/Golang-defer-usecases"],"tags":["Programming/Golang"],"content":"Golang 中 defer 关键字可以将函数或方法注册到 goroutine 用于存放 deferred 函数的栈数据结构中。之后在函数退出之前（return 或者 panic）按照先进后出（LIFO）的顺序调度执行。\n\ndefer 常用场景\nTransclude of Golang-defer-usecases\ndefer 支持哪些函数\n所有自定义的函数和方法都能支持，对于有返回值的函数在 deferred 调用时返回值会被丢弃。因此对于有些需要接住返回值的内置函数，Golang 编译时候检查到会报错，毕竟这样的调用没有意义。\ndefer 后表达式的求值时机\ndefer 的函数会在 deferred 栈执行的时候调用，但是函数的参数是在 defer 时求值的，比如 Golang defer usecases ❯ 3. 输出调试信息 这个例子。\ndefer 有性能损耗\n在 go1.14 之前 defer 和不使用 defer 性能差可达到 7 倍左右，1.14 之后做了很大优化，差距很小了。"},"2024/Golang-defer-usecases":{"slug":"2024/Golang-defer-usecases","filePath":"2024/Golang defer usecases.md","title":"Golang defer usecases","links":[],"tags":["Programming/Golang"],"content":"1. 拦截 panic\n// $GOROOT/src/bytes/buffer.go\nfunc makeSlice(n int) []byte {\n  // If the make fails, give a known error.\n  defer func() {\n      if recover() != nil {\n          panic(ErrTooLarge) // 触发一个新panic\n      }\n  }()\n  return make([]byte, n)\n}\ndefer function 中是用 recover 是 Golang 中唯一从 panic 中恢复的手段，能够拦截运行时中的 panic，但是对运行时之外触发的崩溃无法捕获，比如调用 C 语言的库，C 语言中发生的崩溃。\n2. 修改函数的具名返回值\n下面是一个标准库中的例子：\n// $GOROOT/src/fmt/scan.go\nfunc (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err error) {\n    defer func() {\n        if e := recover(); e != nil {\n            if se, ok := e.(scanError); ok {\n                err = se.err\n            } else {\n                panic(e)\n            }\n        }\n    }()\n    ...\n}\n3. 输出调试信息\n下面这个例子通过 defer 给函数加上了调用和退出的调试日志。\nfunc trace(s string) string {\n    fmt.Println(&quot;entering:&quot;, s)\n    return s\n}\n \nfunc un(s string) {\n    fmt.Println(&quot;leaving:&quot;, s)\n}\n \nfunc a() {\n    defer un(trace(&quot;a&quot;))\n    fmt.Println(&quot;in a&quot;)\n}\n \nfunc b() {\n    defer un(trace(&quot;b&quot;))\n    fmt.Println(&quot;in b&quot;)\n    a()\n}\n \nfunc main() {\n    b()\n}\n4. 还原变量旧值\n下面同样是一个来自标准库的例子：\n// $GOROOT/src/syscall/fs_nacl.go\nfunc init() {\n    oldFsinit := fsinit\n    defer func() { fsinit = oldFsinit }()\n    fsinit = func() {}\n    Mkdir(&quot;/dev&quot;, 0555)\n    Mkdir(&quot;/tmp&quot;, 0777)\n    mkdev(&quot;/dev/null&quot;, 0666, openNull)\n    mkdev(&quot;/dev/random&quot;, 0444, openRandom)\n    mkdev(&quot;/dev/urandom&quot;, 0444, openRandom)\n    mkdev(&quot;/dev/zero&quot;, 0666, openZero)\n    chdirEnv()\n}"},"2024/Golang-sync-pool":{"slug":"2024/Golang-sync-pool","filePath":"2024/Golang sync pool.md","title":"Golang sync pool","links":[],"tags":["Programming/Golang"],"content":"sync 包中提供了一个线程安全的对象缓冲池，可以降低频繁分配和回收内存对 runtime 的影响。但要注意放入 pool 中的对象的生命周期是不确定的，随时都可能被垃圾回收。sync 也为每个 P(Logical Processor) 建立了独立的缓冲池，降低并发时对锁的争抢。\n在使用 sync.Pool 的过程中有个问题需要特别注意，那就是一但有个被大数据撑大的对象放入池中之后，有可能会因为重复的被使用而导致内存不会被释放导致浪费，如果同时出现多个这样的大对象，可能对内存消耗造成不小的负担。解决这个问题有两个思路：\n\n限制放入回收池中的对象大小，如标准库中 fmt 包中采取的办法。\n\n// $GOROOT/src/fmt/print.go\nfunc (p *pp) free() {\n    // 要正确使用sync.Pool,要求每个条目具有大致相同的内存成本\n    // 若缓存池中存储的类型具有可变大小的缓冲区\n    // 对放回缓存池的对象增加一个最大缓冲区的硬限制(不能大于65 536字节)\n    //\n    // 参见golang.org/issue/23199\n    if cap(p.buf) &gt; 64&lt;&lt;10 {\n        return\n    }\n \n    p.buf = p.buf[:0]\n    p.arg = nil\n    p.value = reflect.Value{}\n    p.wrappedErr = nil\n    ppFree.Put(p)\n}\n\n按照占用内存大小建立多个缓存池，如标准库 http 包中的代码。\n\n// $GOROOT/src/net/http/h2_bundle.go\nvar (\n    http2dataChunkSizeClasses = []int{\n        1 &lt;&lt; 10,\n        2 &lt;&lt; 10,\n        4 &lt;&lt; 10,\n        8 &lt;&lt; 10,\n        16 &lt;&lt; 10,\n    }\n    http2dataChunkPools = [...]sync.Pool{\n        {New: func() interface{} { return make([]byte, 1&lt;&lt;10) }},\n        {New: func() interface{} { return make([]byte, 2&lt;&lt;10) }},\n        {New: func() interface{} { return make([]byte, 4&lt;&lt;10) }},\n        {New: func() interface{} { return make([]byte, 8&lt;&lt;10) }},\n        {New: func() interface{} { return make([]byte, 16&lt;&lt;10) }},\n    }\n)\n \nfunc http2getDataBufferChunk(size int64) []byte {\n    i := 0\n    for ; i &lt; len(http2dataChunkSizeClasses)-1; i++ {\n        if size &lt;= int64(http2dataChunkSizeClasses[i]) {\n            break\n        }\n    }\n    return http2dataChunkPools[i].Get().([]byte)\n}\n \nfunc http2putDataBufferChunk(p []byte) {\n    for i, n := range http2dataChunkSizeClasses {\n        if len(p) == n {\n            http2dataChunkPools[i].Put(p)\n            return\n        }\n    }\n    panic(fmt.Sprintf(&quot;unexpected buffer len=%v&quot;, len(p)))\n}"},"2024/Golang-零值可用":{"slug":"2024/Golang-零值可用","filePath":"2024/Golang 零值可用.md","title":"Golang 零值可用","links":[],"tags":["Programming/Golang"],"content":"Golang 中所有没有显示申明值的变量，都会被初始化为默认值，规范中定义的默认值为：\n\n所有整型类型：0\n浮点类型：0.0\n布尔类型：false\n字符串类型：&quot;&quot;\n指针、interface、切片（slice）、channel、map、function：nil\n\n对于一些类型，虽然默认值为 nil，但可以在不初始的情况下进行调用，这种特性被称作零值可用，例如下面这个例子。\nvar zeroSlice []int\nzeroSlice = append(zeroSlice, 1)\nzeroSlice = append(zeroSlice, 2)\nzeroSlice = append(zeroSlice, 3)\nfmt.Println(zeroSlice) // 输出：[1 2 3]\n这个例子中，并没有使用 make([]int) 来显式的初始 zeroSlice，但是我们仍能直接对其使用 append 方法。\n另外两个标准库的例子是 bytes.Buffer 和 sync.Mutex。\nvar mu sync.Mutex\nmu.Lock()\nmu.Unlock()\n \nvar b bytes.Buffer\nb.Write([]byte(&quot;Effective Go&quot;))\n当然，并不是所有的类型和方法都适用，其实原理也比较简单，Golang 调用方法时会自动的转换指针。对于上面例子中，Mutex 的 Lock, Unlock 和 Buffer 的 Write 都定义在指针上，调用是会自动切换，这样在方法体内可以直接判断如果传入指针为 nil，则对其再进行初始化操作就可以了。比如下面这个例子：\nfunc (a *TCPAddr) String() string {\n    if a == nil {\n        return &quot;&lt;nil&gt;&quot;\n    }\n    ip := ipEmptyString(a.IP)\n    if a.Zone != &quot;&quot; {\n        return JoinHostPort(ip+&quot;%&quot;+a.Zone, itoa(a.Port))\n    }\n    return JoinHostPort(ip, itoa(a.Port))\n}\n这里还透露了 Golang runtime 的一个实现细节，对于 var b bytes.Buffer 这个变量，runtime 不仅存储了 b 这个变量的值，也存储了其类型对应方法的函数表。"},"2024/Graph":{"slug":"2024/Graph","filePath":"2024/Graph.md","title":"Graph","links":["2024/Abstract-Data-Type","2024/Tree"],"tags":["DataStructure/Graph"],"content":"图（Graph） 是一种抽象数据类型，和树不同，图中的节点没有层级结构，所有的节点可以链接到任意的另一个节点，形成一个二维的网状结构。\nflowchart LR\n\nA --&gt; B\nB --&gt; C\nC --&gt; D\nC --&gt; B\nA --&gt; C\nD --&gt; A\nD --&gt; E\n\n图的基本组成部分包括：\n\n顶点（Vertex）：图中的基本单位，表示对象或实体。\n边（Edge）：连接两个顶点的线，表示顶点之间的关系。\n\n根据边的性质，图可以分为以下几种类型：\n\n有向图（Directed Graph）：边有方向，从一个顶点指向另一个顶点，表示单向关系。\n无向图（Undirected Graph）：边没有方向，表示双向关系。\n加权图（Weighted Graph）：边上有权重，表示连接两个顶点的代价或距离。\n无权图（Unweighted Graph）：边没有权重，所有边的权重相同。\n\n图的表示方法主要有两种：\n\n邻接矩阵（Adjacency Matrix）：使用一个二维数组来表示图，数组的行和列分别对应图中的顶点，数组中的元素表示顶点之间是否有边相连（以及边的权重）。\n邻接表（Adjacency List）：使用一个数组或链表来表示每个顶点及其相邻的顶点，适合稀疏图。\n"},"2024/GunPG":{"slug":"2024/GunPG","filePath":"2024/GunPG.md","title":"GunPG","links":[],"tags":["ComputerScience"],"content":"GnuPG 是完整实现了 RFC4880（即PGP）所定义的 OpenPGP 标准的自由软件。GnuPG 可以加密和签名你的数据和通讯信息，包含一个通用的密钥管理系统以及用于各种公钥目录的访问模块。GnuPG，简称 GPG，是一个易于与其它程序整合的命令行工具，拥有很多前端程序和函数库。GnuPG 还支持 S/MIME 和 Secure Shell (ssh)。"},"2024/Hashmap":{"slug":"2024/Hashmap","filePath":"2024/Hashmap.md","title":"Hashmap","links":["2024/Data-Structure"],"tags":["DataStructure/Hashmap"],"content":"哈希表（Hashmap） 是一种数据结构，它使用哈希函数将键（key）映射到值（value）。哈希表的基本思想是将键转换为一个索引值，然后使用这个索引值来存储和检索相应的值。\n哈希表通常由以下几个部分组成：\n\n键（key）：唯一标识每个元素的值。\n值（value）：与键相关联的值。\n哈希函数：将键转换为索引值的函数。\n桶（bucket）：存储值的容器。\n\n哈希表的工作原理如下：\n\n当你插入一个键值对时，哈希函数会将键转换为一个索引值。\n根据索引值，哈希表会将值存储在相应的桶中。\n当你需要检索一个值时，哈希函数会将键转换为索引值，然后哈希表会根据索引值找到相应的桶并返回值。\n\n哈希表的优点包括：\n\n快速查找：哈希表可以在常数时间内查找值。\n高效存储：哈希表可以存储大量数据。\n灵活性：哈希表可以用于各种应用场景。\n\n但是，哈希表也有一些缺点，例如：\n\n碰撞：当两个不同的键映射到同一个索引值时，会发生碰撞。\n空间浪费：哈希表可能会浪费空间，因为桶可能为空。\n\n为了解决这些问题，哈希表通常使用一些技术，例如：\n\n开放寻址：当发生碰撞时，哈希表会寻找下一个空闲桶。\n链表：哈希表会使用链表来存储发生碰撞的值。\n"},"2024/Heap":{"slug":"2024/Heap","filePath":"2024/Heap.md","title":"Heap","links":["2024/Tree","2024/Data-Structure","2024/Complete-Binary-Tree","2023/Binary-Heap"],"tags":["DataStructure/Heap"],"content":"堆（Heap） 是一种基于树的抽象数据结构，在树状的层级结构之上，堆中的父节点与子节点需要满足特定的比较关系。\n对于大顶堆来说，堆中的父节点的值都比子节点中的值要大；对于小顶堆来说，则相反，父节点的值比子节点要小。\n这种特性使得堆一般用来实现优先队列，堆顶始终是最大或着最小值。抽象来说，堆的实现可以是任何形状的树，但通常使用的是基于完全二叉树的二叉堆。"},"2024/How-to-Delete-a-Service-in-Windows-11":{"slug":"2024/How-to-Delete-a-Service-in-Windows-11","filePath":"2024/How to Delete a Service in Windows 11.md","title":"How to Delete a Service in Windows 11","links":[],"tags":["ComputerScience/Windows","Windows/Tips","Windows/Powershell"],"content":"If there’s a service running that you’d rather not have around, here’s how to delete it on Windows 11.\nReaders like you help support MUO. When you make a purchase using links on our site, we may earn an affiliate commission. Read More.\nA service is a special type of program that usually starts when the operating system loads on your computer. The application runs in the background and has no user interface. You don’t see these processes when you use your computer. Instead, you can observe the effects of having them running in the background.\nIf you have identified a service that you no longer require on your computer and want to remove it, then deleting that service is one way to do so. This guide will explain some easy ways to delete a service in Windows 11.\nWhat Is a Service on Windows?\nWindows services are applications that start up with the Windows operating system and perform a specific function. Services can be used to provide functionality for other programs or to perform system-level tasks. It is responsible for tasks such as monitoring the system for changes, interacting with other programs, and carrying out scheduled tasks.\nThere are a number of services running on a typical Windows system, and more can be added as needed. Some services are essential for the proper functioning of the operating system, while others may be added by third-party programs.\nYou can view and manage services from the Windows Tools applet in Control Panel. If a service is not working properly, it can cause problems with other parts of the system. For example, if the Print Spooler service stops responding, you will not be able to print documents.\nCan Disabling Services Improve Windows Performance?\nIt is a common belief that disabling services on Windows can help improve performance, which is indeed true. However, this is not always the case.\nIn some instances, disabling certain services can actually lead to decreased performance and stability. Therefore, it is important to know which services are safe to disable and which you should leave the same way they are.\nHow to Delete a Service in Windows 11\nWhen you delete a service, you are permanently removing it from the Windows operating system. This means that the service will no longer be available to programs that may rely on it, and any associated data will be lost. Before deleting a service, you should ensure that there are no programs that depend on it. You can do this by checking the dependencies tab in the service’s properties window.\nHowever, it’s always a good idea to disable services that you don’t need, which speeds up Windows performance and makes your computer more stable. When it comes to deleting services from Windows, there are three different ways to do it.\nYou can do this either through Command Prompt, Windows PowerShell, or the Registry Editor, depending on how you prefer to do things. Each of them is explained in detail here.\n1. Through the Registry Editor\nIf you’re familiar with the Windows Registry and want to delete a service in Windows 11, you can do so using the Registry Editor. The process is relatively straightforward and only requires a few steps.\nKeep in mind, however, that registry editing is a delicate process and one wrong move can make your computer unusable. In this regard, you should always create a backup of your registry before making any changes.\nThe following instructions will guide you through deleting a Windows service using the Registry Editor, but before you proceed, you need to figure out which one you want to delete. To get started, go through these steps:\n\n\nOpen the Services application.\n\n\nScroll down and locate the service you want to delete in the Services Manager window.\n\n\nOnce you find it, double-click on it to open the Properties window.\n\n\nIn the Properties window, go to the General tab and note down the Service name.\n\n\nAfter you find the Service name, close both the Properties and Services windows. Next, open the Registry Editor and delete the service as follows:\n\n\nRight-click on Start and select Run to open the Run Command dialog box.\n\n\nType “regedit” in the search box and hit Enter to open the Registry Editor.\n\n\nIf the UAC window appears, click Yes to confirm your action.\n\n\nIn the Registry Editor, navigate to the following address:\nComputer\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\n\n\n\nYou should now look up the Service Name that you noted earlier.\n\n\nOnce you’ve found it, right-click on it and choose the Delete option.\n\n\nIf you receive a confirmation message, click Yes to proceed.\n\n\nOnce you have deleted the registry key, restart your computer so that the changes take effect. The next time you start your PC, you won’t have the deleted service available\n2. Using the Command Prompt\nIf you don’t like editing the registry editor, you can also delete the service using the command prompt in Windows 11. In order to proceed with this method, you will need the service name, so please refer to the first method for finding it.\nHere is how to delete services using the command prompt:\n\n\nOpen the Run command dialog box.\n\n\nType “cmd” in the text box and press Ctrl + Shift + Enter to open Command Prompt with admin access.\n\n\nWhen UAC pops up on the screen, click on Yes to continue.\n\n\nOnce you’re in the Command Prompt window, type the below command:\nPS &gt; sc delete &lt;service_name&gt;\n\n\nNow press the Enter key to delete the service.\n\n\nAfter making the above changes, you must restart your computer.\n\n\nWhen you run the above command, replace &lt;service_name&gt; with the name of the service you noted earlier. In addition, if the name of the service you wish to delete contains spaces, you must enclose it in quotes.\n3. Using the Windows PowerShell\nWindows PowerShell is another method you can use to delete services in Windows 11. Here’s how it works:\n\n\nClick the Start Menu and type “PowerShell”.\n\n\nFrom the right pane, select Run as administrator.\n\n\nWhen UAC appears on the screen, click Yes to continue.\n\n\nOnce you’re in the PowerShell window, type the below command:\nGet-Service\n\n\n\nPress Enter and the services list will appear on your screen.\n\n\nNote down the name of the service you want to remove from the service list.\n\n\nNow copy and paste the below command:\nsc delete &lt;service_name&gt;\n\n\n\nPress the Enter key to run the command.\n\n\nOnce you have made these changes, restart your computer and that service won’t appear in the service list.\n\n\nIn the above command, replace  with the name of the service you want to delete."},"2024/Linux-Transparent-Proxy-Support":{"slug":"2024/Linux-Transparent-Proxy-Support","filePath":"2024/Linux Transparent Proxy Support.md","title":"Linux Transparent Proxy Support","links":[],"tags":["Reference","Linux/Network"],"content":"Introduction\nThe Linux kernel contains facilities for performing transparent proxying. In short this means that the operating system functions as a router, but some (or all) traffic gets redirected for userspace processing.\nThis could be used for example to implement a transparent http proxy which could then for example apply policy, scan for viruses etc. There are DNS applications too.\nWhile the kernel does contain a file that describes this functionality, and this file is actually not wrong, it certainly is confusing. Other components required to really make transparent proxying work are described on various Stack Exchange pages. Other flags hang out in a number of manpages.\nThis document attempts to describe everything in one place, with references to the authoritative sources. Note that this documentation is quite at odds with other explanations found online, but it is believed this page is correct.\nSome of the “pseudocode” examples actually compile when used with SimpleSockets. This is used because these examples are easier to read than the somewhat cumbersome raw BSD sockets API equivalent.\nHigh level\nFour components are involved:\n\nA routing table that declares all IP addresses as local\niptables rules marking certain packets for processing by this routing table\n\nAnd optionally map the traffic to a specific local address\n\n\nA socket option IP_TRANSPARENT that marks sockets a suitable for receiving such traffic\nPotentially: ebtables to perform these function in bridging mode\n\nThe routing part\nWhen a packet enters a Linux system it is routed, dropped, or if the destination address matches a local address, accepted for processing by the system itself.\nLocal addresses can be specific, like 192.0.2.1, but can also match whole ranges. This is for example how all of 127.0.0.0/8 is considered as ‘local’.\nIt is entirely possible to tell Linux 0.0.0.0/0 (‘everything’) is local, but this would leave it unable to connect to any remote address.\nHowever, with a separate routing table, we can enable this selectively:\niptables -t mangle -I PREROUTING -p udp --dport 5301 -j MARK --set-mark 1\nip rule add fwmark 1 lookup 100\nip route add local 0.0.0.0/0 dev lo table 100\n\nThis says: mark all UDP packets coming in to the system to port 5301 with ‘1’. The next line sends those marked packets to routing table 100. And finally, the last line declares all of IPv4 as local in routing table 100.\nIntercepting packets: the userspace part\nWith the routing rule and table above, the following simple code intercepts all packets routed through the system destined for 5301, regardless of destination IP address:\n  Socket s(AF_INET, SOCK_DGRAM, 0);\n  ComboAddress local(&quot;0.0.0.0&quot;, 5301);\n  ComboAddress remote(local);\n\n  SBind(s, local);\n\n  for(;;) {\n    string packet=SRecvfrom(s, 1500, remote);\n    cout&lt;&lt;&quot;Received a packet from &quot;&lt;&lt;remote.toStringWithPort()&lt;&lt;endl;\n  }\n\nThe two roles of IP_TRANSPARENT\nThe IP_TRANSPARENT socket option enables:\n\nBinding to addresses that are not (usually) considered local\nReceiving connections and packets from iptables TPROXY redirected sessions\n\nBinding to non-local IP addresses\nRegular sockets are used for transparent proxying, but a special flag, IP_TRANSPARENT, is set to indicate that this socket might receive data destined for a non-local addresses.\nNote: as explained above, we can declare 0.0.0.0/0 as “local” (or ::/0), but if this is not in a default routing table, we still need this flag to convince the kernel we know what we are doing when we bind to a non-local IP address.\nThe following code spoofs a UDP address from 1.2.3.4 to 198.41.0.4:\n  Socket s(AF_INET, SOCK_DGRAM, 0);\n  SSetsockopt(s, IPPROTO_IP, IP_TRANSPARENT, 1);\n  ComboAddress local(&quot;1.2.3.4&quot;, 5300);\n  ComboAddress remote(&quot;198.41.0.4&quot;, 53);\n\n  SBind(s, local);\n  SSendto(s, &quot;hi!&quot;, remote);\n\nNote: this requires root or CAP_NET_ADMIN to work.\nWith tcpdump we can observe that an actual packet leaves the host:\ntcpdump -n host 1.2.3.4\n21:29:41.005856 IP 1.2.3.4.5300 &gt; 198.41.0.4.53: [|domain]\n\nIP_TRANSPARENT is mentioned in ip(7).\nThe iptables part\nIn the code examples above, traffic had to be delivered to a socket bound to the exact port of the intercepted traffic. We also had to bind the socket to 0.0.0.0 (or ::) for it to see all traffic.\niptables has a target called TPROXY which gives us additional flexibility to send intercepted traffic to a specific local IP address and simultaneously mark it too.\nThe basic syntax is:\niptables -t mangle -A PREROUTING -p tcp --dport 25 -j TPROXY \\\n  --tproxy-mark 0x1/0x1 --on-port 10025 --on-ip 127.0.0.1\n\nThis says: take everything destined for a port 25 on TCP and deliver this for a process listening on 127.0.0.1:10025 and mark the packet with 1.\nThis mark then makes sure the packet ends up in the right routing table.\nWith the iptables line above, we can now bind to 127.0.0.1:10025 and receive all traffic destined for port 25. Note that the IP_TRANSPARENT option still needs to be set for this to work, even when we bind to 127.0.0.1.\nGetting the original destination address\nFor TCP sockets, the original destination address and port of a socket is available via getsockname(). This is needed for example to setup a connection to the originally intended destination.\nAn example piece of code:\n  Socket s(AF_INET, SOCK_STREAM, 0);\n  SSetsockopt(s, IPPROTO_IP, IP_TRANSPARENT, 1);\n  ComboAddress local(&quot;127.0.0.1&quot;, 10025);\n\n  SBind(s, local);\n  SListen(s, 128);\n\n  ComboAddress remote(local), orig(local);\n  int client = SAccept(s, remote);\n  cout&lt;&lt;&quot;Got connection from &quot;&lt;&lt;remote.toStringWithPort()&lt;&lt;endl;\n\n  SGetsockname(client, orig);\n  cout&lt;&lt;&quot;Original destination: &quot;&lt;&lt;orig.toStringWithPort()&lt;&lt;endl;\n\nFor UDP, the IP_RECVORIGDSTADDR socket option can be set with setsockopt(). To actually get to that address, recvmsg() must be used which will then pass the original destination as a cmsg with index IP_ORIGDSTADDR containing a struct sockaddr_in.\nNote: as of May 2017, many recently deployed Linux kernels have a bug which breaks IP_RECVORIGDSTADDR.\nCaveats\nNone of this works locally. Packets need to actually enter your system and be routed.\nFirst, make sure that the Linux machine is actually setup to forward packets:\nsysctl net.ipv4.conf.all.forwarding=1\nsysctl net.ipv6.conf.all.forwarding=1\n\nSecondly, in many cases the reverse path filter may decide to drop your intercepted packets. The rp_filter can’t be disabled globally, so for each interface do:\nsysctl net.ipv4.conf.eth0.rp_filter=0\n\nFor reasons, the net.ipv4.conf.all.rp_filter actually can only be used to enable the rp_filter globally, not disable it.\nThe -m socket line you find everywhere\nMany TPROXY iptables examples on the internet contain an unexplained refinement that uses -m socket -p tcp. The socket module of iptables matches patches that correspond to a local socket, which may be more precise or faster than navigating a set of specific rules.\nThe setup you’ll find everywhere sets up a redirect chain which marks and accepts packets:\niptables -t mangle -N DIVERT\niptables -t mangle -A DIVERT -j MARK --set-mark 1\niptables -t mangle -A DIVERT -j ACCEPT\n\nThe following then makes sure that everything that corresponds to an established local socket gets sent there, followed by what should happen to new packets:\niptables -t mangle -A PREROUTING -p tcp -m socket -j DIVERT\niptables -t mangle -A PREROUTING -p tcp --dport 25 -j TPROXY \\\n  --tproxy-mark 0x1/0x1 --on-port 10025 --on-ip 127.0.0.1\niptables -t mangle -A PREROUTING -p tcp --dport 80 -j TPROXY \\\n  --tproxy-mark 0x1/0x1 --on-port 10080 --on-ip 127.0.0.1\n"},"2024/OSI-Model":{"slug":"2024/OSI-Model","filePath":"2024/OSI Model.md","title":"OSI Model","links":["2024/IP","2024/TCP","2024/UDP"],"tags":["ComputerScience/Network"],"content":"开放式系统互联模型（英語：Open System Interconnection Model，縮寫：OSI；簡稱為OSI 模型）是一種概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定義於 ISO/IEC 7498-1。\n该模型将通信系统中的数据流划分为七个层，从分布式应用程序数据的最高层表示到跨通信介质传输数据的物理实现。每个中间层为其上一层提供功能，其自身功能则由其下一层提供。功能的类别通过标准的通信协议在软件中实现。\n7 层模型\n早期的 OSI Model 被定义为 7 层模型，这七层从下到上分别为：\n\n物理层（Physical Layer）： 负责定义物理连接和传输媒体。它涉及电缆、连接器、物理拓扑等硬件细节。\n数据链路层（Data Link Layer）： 主要负责点对点的直接通信。它负责错误检测和纠正，以及数据帧的流控制。\n网络层（Network Layer）： 提供了在不同网络之间传输数据的能力。它涉及路由选择、逻辑寻址和跨网络的数据包转发。\n传输层（Transport Layer）： 提供端到端的通信，确保数据传输的可靠性和完整性。它定义了端口号、流量控制和错误恢复等。\n会话层（Session Layer）： 管理用户会话并提供数据交换服务。它负责建立、维护和终止应用程序之间的通信会话。\n表示层（Presentation Layer）： 负责数据的编码和解码、数据的压缩和解压缩，以确保不同系统上的数据格式能够互相理解。\n应用层（Application Layer）： 提供用户接口和网络服务，是网络中最高层次的层。它定义了用户与网络服务之间的接口，例如电子邮件、文件传输和远程登录。\n\n4 层模型\n之后在 7 层模型之上做近一步简化演变为 4 层模型：\n\n网络接口层，合并了物理层与数据链路层。\n网络层，同 7 层模型中的网络层一样。 IP\n传输层，同 7 层模型相同。TCP, UDP\n应用层，应用层和传输层之间的会话层与表示层被废弃。\n"},"2024/Queue":{"slug":"2024/Queue","filePath":"2024/Queue.md","title":"Queue","links":["2024/Data-Structure"],"tags":["DataStructure/Queue"],"content":"队列（Queue） 是一种抽象数据结构，遵循“先进先出”（FIFO, First In First Out）的原则。这意味着最先被添加到队列中的元素是第一个被移除的元素。可以将队列视为一个水平的容器，元素从一端添加（队尾）并从另一端移除（队头）。\n队列的基本操作：\n\n入队（Enqueue）：将一个元素添加到队列的尾部。\n出队（Dequeue）：移除并返回队列头部的元素。\n查看队头元素（Front/Peek）：返回队列头部的元素，但不移除它。\n检查队列是否为空（IsEmpty）：判断队列中是否还有元素。\n\n队列的特点：\n\n先进先出：最早入队的元素最早出队。\n动态大小：队列的大小可以根据需要动态增长（在使用链表实现时）或固定大小（在使用数组实现时）。\n"},"2024/Quick-Sort":{"slug":"2024/Quick-Sort","filePath":"2024/Quick Sort.md","title":"Quick Sort","links":["分治法","2024/Recursion","双指针","归并排序"],"tags":["Algorithm/Sorting"],"content":"快速排序（Quick Sort） 是一种采用分治法思想的排序算法，其主要过程大概如下：\n\n挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），\n分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，\n递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。\n\n一个可能的简单的伪码实现如下：\nfunction quicksort(q)\n{\n     var list less, pivotList, greater\n     if length(q) ≤ 1\n         return q\n     else\n     {\n         select a pivot value pivot from q\n         for each x in q except the pivot element\n         {\n             if x &lt; pivot then add x to less\n             if x ≥ pivot then add x to greater\n         }\n         add pivot to pivotList\n         return concatenate(quicksort(less), pivotList, quicksort(greater))\n     }\n}\n\n但这样的实现意味着我们需要 O(n) 额外的空间开销，所以一般我们会采用一个无需额外空间，使用双指针，原地分割的版本：\n function partition(a, left, right, pivotIndex)\n {\n     pivotValue = a[pivotIndex]\n     swap(a[pivotIndex], a[right]) // 把pivot移到結尾\n     storeIndex = left\n     for i from left to right-1\n     {\n         if a[i] &lt; pivotValue\n          {\n             swap(a[storeIndex], a[i])\n             storeIndex = storeIndex + 1\n          }\n     }\n     swap(a[right], a[storeIndex]) // 把pivot移到它最後的地方\n     return storeIndex\n }\n\n procedure quicksort(a, left, right)\n     if right &gt; left\n         select a pivot value a[pivotIndex]\n         pivotNewIndex := partition(a, left, right, pivotIndex)\n         quicksort(a, left, pivotNewIndex-1)\n         quicksort(a, pivotNewIndex+1, right)\n\n\n\n                  \n                  Tips: \n                  \n                \n\n特别需要注意这个 partition 函数，要注意双指针的边界问题，在实际实现的过程中要十分小心。不然很容易死循环或者越界。\n\n\n和归并排序不同，快速排序本身是个不稳定排序，其时间复杂度受到数组本身和 pivot 选取的影响，其时间复杂度可以总结为下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n复杂度平均时间复杂度O(n\\log{⁡n})最坏时间复杂度O(n^2)最优时间复杂度O(n\\log{⁡n})\n由于时间复杂度受到 pivot 选取的影响，我们可以考虑对选取过程进行优化。\n第一种是使用随机数来选取 pivot，随机化快速排序可以对于绝大多数输入数据达到 O(n\\log{n}） 的期望时间复杂度。\n第二种是三数取中，假设数组被排序的范围为 left 和 right，center=（left+right/2，对a[left]、a[right] 和 a[center] 进行适当排序，取中值为中轴，将最小者放 a[left] ，最大者放在 a[right]，把中轴元与 a[right-1] 交换，并在分割阶段将i和j初始化为 left+1 和 right-2。然后使用双向便利法，进行快排。\n参考：\n\n快排优化\n双向快排\n"},"2024/Recursion":{"slug":"2024/Recursion","filePath":"2024/Recursion.md","title":"Recursion","links":["2023/Dynamic-Programming"],"tags":["Algorithm/Recursion"],"content":"递归是一种编程和数学中的技术，其中一个函数直接或间接地调用自身以解决问题。递归通常用于将一个复杂的问题分解为更简单的子问题，直到达到一个基本情况（基准情况），这个基本情况可以直接解决。\n递归有两个基本的组成部分：\n\n\n基准情况：这是递归的终止条件，指明何时停止递归调用。没有基准情况，递归将无限进行下去，导致栈溢出错误。\n\n\n递归步骤：这是函数调用自身的部分，通常会将问题规模缩小，逐步接近基准情况。\n\n\n递归的思想同动态规划的思想有一致性，如果回忆大学的算法课程，动态规划的起点一般是从讨论某一个递归算法的重复计算问题开始的。两者的实际差别在具体的算法代码实现上，递归的代码基本就是递归的基准情况和步骤的自然组合；动态规划在拆分问题时可以使用递归的思想，但在实现时，却是从小到大，和从大大小拆分的思想相反。\n以下是一个计算阶乘的递归示例：\ndef factorial(n):\n    # 基准情况\n    if n == 0 or n == 1:\n        return 1\n    # 递归步骤\n    else:\n        return n * factorial(n - 1)\n \n# 使用示例\nprint(factorial(5))  # 输出 120\n递归的优点：\n\n代码简洁：递归可以使代码更简洁和易于理解，特别是在处理树形结构或分治算法时。\n自然表达：某些问题（如树遍历、图遍历等）用递归表达更自然。\n\n递归的缺点：\n\n性能：递归可能导致较高的时间复杂度，尤其是在没有优化的情况下（如重复计算）。但这点并不是绝对的，还是应该以实际的性能测试为准。\n空间消耗：每次递归调用都会在调用栈上占用空间，深度递归可能导致栈溢出。\n"},"2024/Stack":{"slug":"2024/Stack","filePath":"2024/Stack.md","title":"Stack","links":["2024/Data-Structure"],"tags":["DataStructure/Stack"],"content":"栈（Stack） 是一种抽象的数据结构，遵循“后进先出”（LIFO, Last In First Out）的原则。这意味着最后被添加到栈中的元素是第一个被移除的元素。栈可以被视为一个垂直的容器，元素从顶部添加和移除。\n栈的基本操作:\n\n压栈（Push）：将一个元素添加到栈的顶部。\n弹栈（Pop）：移除并返回栈顶部的元素。\n查看栈顶元素（Peek/Top）：返回栈顶部的元素，但不移除它。\n检查栈是否为空（IsEmpty）：判断栈中是否还有元素。\n\n栈的特点:\n\n后进先出：最后压入栈的元素最先被弹出。\n动态大小：栈的大小可以根据需要动态增长（在使用链表实现时）或固定大小（在使用数组实现时）。\n"},"2024/System-Latency":{"slug":"2024/System-Latency","filePath":"2024/System Latency.md","title":"System Latency","links":[],"tags":["ComputerScience/SystemDesign"],"content":"系统设计时需要考虑计算机运行时的系统时延，下表列出了一些常用的时延，用以在估算系统性能时作为估算的参考。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作耗时查询 L1 cahe0.5 ns分支预测错误5 ns查询 L2 cahe7 ns互斥锁定/解锁100 ns查询内存100 ns用 zippy 压缩 1kb 数据10,000 ns = 10 us通过带宽为 1Gb/s 的网络发送 2kb 数据20,000 ns = 20 us从内存中顺序读取 1mb 数据250,000 ns = 250 us数据在同一数据中心往返一次500,000 ns = 500 us从硬盘中查找数据（非固态）10,000,000 ns = 10 ms从网络中顺序读取 1mb 数据10,000,000 ns = 10 ms从硬盘中顺序读取 1mb 数据30,000,000 ns = 30 ms将数据包从加州发到荷兰再返回加州150,000,000 ns = 150 ms\n时延也会随着时间的变化系统的进步而变化，这个网站有个动态显示的页面，更新到 2020 年。"},"2024/TCP-Connection-Termination":{"slug":"2024/TCP-Connection-Termination","filePath":"2024/TCP Connection Termination.md","title":"TCP Connection Termination","links":["TCP-MSL","2024/TCP-Handshake"],"tags":["Network/TCP"],"content":"sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client: ESTABLISHED\n    Note over Server: ESTABLISHED\n\n    Client-&gt;&gt;Server: FIN (seq=u)\n    Note over Client: FIN_WAIT_1\n\n    Server--&gt;&gt;Client: ACK (seq=v, ack=u+1)\n    Note over Server: CLOSE_WAIT\n    Note over Client: FIN_WAIT_2\n\n    Server-&gt;&gt;Client: FIN (seq=w, ack=u+1)\n    Note over Server: LAST_ACK\n\n    Client--&gt;&gt;Server: ACK (seq=u+1, ack=w+1)\n    Note over Client: TIME_WAIT\n    Note over Server: CLOSED\n\n    Note over Client: CLOSED (after 2MSL)\n\n挥手过程\n\n客户端发送 FIN 包，进入 FIN_WAIT_1 状态；\n服务器回复 ACK 包，进入 CLOSE_WAIT 状态；\n服务器没有数据需要发送后，发送 FIN 包，进入 LAST_ACK 状态；\n客户端收到 FIN 包后，回复 ACK，进入 TIME_WAIT 的状态；\n服务器收到 ACK 后关闭连接，进入 CLOSED 状态；\n客户端在 TIME_WAIT 状态等待 2MSL 后，关闭连接。\n\n同时关闭\nTCP 的关闭连接不是只能一方发起，双方都可一发起这一过程，如果双方同时发起，在收到对方发送的 FIN 包后，会从 FIN_WAIT_1 变为 CLOSING 状态，发送 FIN 包的 ACK 之后进入 TIME_WAIT 状态，经过 2MSL 之后关闭连接。\n为什么需要 TIME_WAIT\n\n可靠的实现 TCP 全双工的连接终止（处理最后 ACK 丢失的情况）\n避免当前关闭连接与后续连接混淆（让旧连接的包在网络中消逝）\n\n减少服务器 TIME_WAIT 的影响\n使用 TCP 头部时间戳选项（TCP Options, TSopt），有点像个不会溢出的 SEQ+ACK 双方在通信时不断更新 TSval，TSecr 字段。需要在 TCP 握手时双方同时开启。\n有了这个之后 Linux 上可以开启两个选项：\n\nnet.ipv4.tcp_tw_reused\nnet.ipv4.tcp_tw_recycle\n\n这两个选项都依赖 TSopt 来判断当前包是之前连接为成功关闭，还是发起了新的连接。"},"2024/TCP-Handshake":{"slug":"2024/TCP-Handshake","filePath":"2024/TCP Handshake.md","title":"TCP Handshake","links":[],"tags":["Network/TCP"],"content":"sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Server: CLOSED\n    Note over Client: CLOSED\n    Note over Server: LISTEN\n\n    Client-&gt;&gt;Server: SYN (seq=x)\n    Note over Client: SYN_SENT\n\n    Server--&gt;&gt;Client: SYN-ACK (seq=y, ack=x+1)\n    Note over Server: SYN_RCVD\n\n    Client-&gt;&gt;Server: ACK (seq=x+1, ack=y+1)\n    Note over Client: ESTABLISHED\n    Note over Server: ESTABLISHED\n\n握手过程\n\n客户端向服务器发送 SYN 包（包中指定自己的初始 seq)，进入 SYN_SENT 状态；\n服务端收到 SYN 包，回复自己的 SYN 包（包中包含自己的初始 seq 和对客户端 SYN 包的 ACK），进入 SYN_RCVD 状态；\n客服端收到 SYN+ACK 回复 ACK，自己进入 ESTABLISHED 状态，同时这个包是可以带要发送的数据的；\n服务器收到 ACK，进入 ESTABLISHED 状态，如果包有数据，则开始接收数据。\n"},"2024/TCP-Segment-Structure":{"slug":"2024/TCP-Segment-Structure","filePath":"2024/TCP Segment Structure.md","title":"TCP Segment Structure","links":["2024/TCP","2024/IP"],"tags":["Network/TCP"],"content":"TCP 包头不包含 options 字段为 128bit(16byte) 的固定长度，其结构如下图所示：\n---\ntitle: &quot;TCP Packet&quot;\n---\npacket-beta\n\n0-15: &quot;Source Port&quot;\n16-31: &quot;Destination Port&quot;\n32-63: &quot;Sequence Number&quot;\n64-95: &quot;Acknowledgment Number&quot;\n96-99: &quot;Data Offset&quot;\n100-103: &quot;Reserved&quot;\n104: &quot;CWR&quot;\n105: &quot;ECE&quot;\n106: &quot;URG&quot;\n107: &quot;ACK&quot;\n108: &quot;PSH&quot;\n109: &quot;RST&quot;\n110: &quot;SYN&quot;\n111: &quot;FIN&quot;\n112-127: &quot;Window&quot;\n128-143: &quot;Checksum&quot;\n144-159: &quot;Urgent Pointer&quot;\n160-191: &quot;(Options and Padding)&quot;\n192-255: &quot;Data (variable length)&quot;\n\n端口号 Port\n包头前 4 bytes 分别为源端口号和目标端口号。TCP 中是没有源 IP 和目标 IP 地址的，因为那是 IP 协议的事情，整个 TCP 报文是被包在 IP 报文中的。\n序列号 Sequence Number\n序列号指的是当前报文数据中第一个字节的序列号。序列号加上当前报文长度就可以确认当前报文传输的是哪一段数据。本身为一个 uint32，溢出后会循环到 0。\n在握手阶段双方发送 SYN 报文时，会选择自己的初始序列号。\n确认号 ACK\nTCP 利用确认号告诉对方，自己期望的接受下一个序列号是多少，确认这个序列号之前的数据已经全部接受。\n\n\n                  \n                  注意 \n                  \n                \n\n\n不是所有的包都需要确认的\n不是收到了数据包就立马需要确认的，可以延迟一会再确认\nACK 包本身不需要被确认，否则就会无穷无尽死循环了\n确认号永远是表示小于此确认号的字节都已经收到\n\n\n\n标志位 Flags\n标志位用来标识当前 TCP 包用做什么作用，将对应的 bit 置为 1 即表示标志开启，常用的有：\n\nSYN：用于发起连接同步初始序列号\nACK：确认数据包\nRST：强制断开连接\nFIN：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了\nPSH：告知对方这些数据包收到以后应该马上交给上层应用，不能缓存起来\n\n窗口大小 Window\n窗口大小用来表示自己的还能接受数据量，发送方发送的数据长度不能超过这个数值。\n最初 TCP 设计时只预留了 2bytes 的空间给窗口大小，最大只能支持 64KB，为了解决这个问题，TCP 可以在握手时在选项中通过窗口缩放选项（Window Scale Option）协商缩放因子，范围为 [0, 14]。开启之后实际的窗口大小为 Window * (2^factor)。\n可选项 Options\n正如在窗口大小中看到的一样，Options 用来对 TCP 链接进行协商设置，用于开启或关闭某些功能与特性。\n常用的有：\n\nMSS：最大段大小选项，是 TCP 允许的从对方接收的最大报文段\nSACK：选择确认选项\nWindow Scale：窗口缩放选项\n"},"2024/The-Little-Schemer---Five-Rules":{"slug":"2024/The-Little-Schemer---Five-Rules","filePath":"2024/The Little Schemer - Five Rules.md","title":"The Little Schemer - Five Rules","links":[],"tags":["Reference","Programming/Scheme"],"content":"The Five Rules\n\n\nThe Law of Car\n\nThe primitive car is defined only for non-empty lists.\n\n\n\nThe Law of Cdr\n\nThe primitive cdr is defined only for non-empty lists.\nThe cdr of any non-empty list is always another list.\n\n\n\nThe Law of Cons\n\nThe primitive cons takes two arguments.\nThe second argument to cons must be a list.\nThe result is a list.\n\n\n\nThe Law of Null?\n\nThe primitive null? is defined only for lists.\n\n\n\nThe Law of Eq?\n\nThe primitive eq? takes two arguments.\nEach must be a non-numeric atom.\n\n\n"},"2024/The-Little-Schemer---Ten-Commandments":{"slug":"2024/The-Little-Schemer---Ten-Commandments","filePath":"2024/The Little Schemer - Ten Commandments.md","title":"The Little Schemer - Ten Commandments","links":[],"tags":["Reference","Programming/Scheme"],"content":"The Ten Commandments\n\n\nWhen recurring on a list of atoms, lat , ask two questions about it: (null? lat) and else . When recurring on a number, n, ask two questions about it: (zero? n) and else . When recurring on a list of S-expressions, l, ask three questions about it: (null? l) , (atom? (car l)) , and else .\n\n\nUse cons to build lists.\n\n\nWhen building a list, describe the first typical element, and then cons it onto the natural recursion.\n\n\nAlways change at least one argument while recurring. When recurring on a list of atoms, lat , use (cdr lat) . When recurring on a number, n , use (sub1 n) . And when recurring on a list of S-expressions, l, use (car l) and (cdr l) if neither (null? l) nor (atom? (car l)) are true. It must be changed to be closer to termination. The changing argument must be tested in the termination condition:\n\nwhen using cdr, test termination with null?.\nwhen using sub1, test termination with zero?.\n\n\n\nWhen building a value with +, always use 0 for the value of terminating line, for add 0 does not change the value of an addition. When building a value with *, always use 1 for the value of terminating line, for multiplying by 1 does not change the value of multiplication. When building a value with cons, always consider () for the value of the value of the terminating line.\n\n\nSimplify only after the function is correct.\n\n\nRecur on the subparts that are of the same nature:\n\nOn the sublists of a list.\nOn the subexpressions of an arithmetic expression.\n\n\n\nUse help function to abstract from representations.\n\n\nAbstract common patterns with a new function.\n\n\nBuild functions to collect more than one value at a time.\n\n"},"2024/Threads":{"slug":"2024/Threads","filePath":"2024/Threads.md","title":"Threads","links":["2024/Coroutine"],"tags":["ComputerScience/OperatingSystem"],"content":"线程在计算机科学中，是将进程划分为两个或多个线程（实例）或子进程，由单处理器（单线程）或多处理器（多线程）或多核处理系统并发执行。\n与存在于用户空间的协程不同，线程实际上是操作系统能调用的最小单元，其生命周期是操作系统管理。每个 thread 有自己独立的栈，调度也需要通过系统中断。\nReferences\n\nWiki\n"},"2024/Tree":{"slug":"2024/Tree","filePath":"2024/Tree.md","title":"Tree","links":["2024/Data-Structure"],"tags":["DataStructure/Tree"],"content":"树（Tree） 是一种抽象的数据结构，表示一种由多个节点组成的类似树干与叶子的层级结构。树中的每个节点可以有多个子节点，但最多只能有一个父节点，没有父节点只有子节点的节点被称作根节点（root）。\n计算机中的文件系统就是个典型的树结构。\nflowchart TD\n\n%% nodes\n\nA(((A))) --&gt; B(((B)))\nA --&gt; C(((C)))\nA --&gt; D(((D)))\n\nB --&gt; F(((F)))\nB --&gt; E(((E)))\n\nF --&gt; K(((K)))\nF --&gt; L(((L)))\n\nC --&gt; H(((H)))\nC --&gt; G(((G)))\nC --&gt; N(((N)))\n\nD --&gt; I(((I)))\nD --&gt; J(((J)))\nD --&gt; O(((O)))\nD --&gt; P(((P)))\n\nJ --&gt; M(((M)))\n"},"2024/使用自引用与闭包实现优美的多参数配置":{"slug":"2024/使用自引用与闭包实现优美的多参数配置","filePath":"2024/使用自引用与闭包实现优美的多参数配置.md","title":"使用自引用与闭包实现优美的多参数配置","links":[],"tags":["Programming/Golang","Programming/Rust","Programming/DesignPattern"],"content":"\n\n                  \n                  Info\n                  \n                \n\n以下说明以 Golang 为例，但设计逻辑可以运用于所有支持闭包和函数参数的编程语言\n\n\n一个常用的例子：\ntype option func(*Foo)\n \n// Option sets the options specified.\nfunc (f *Foo) Option(opts ...option) {\n    for _, opt := range opts {\n        opt(f)\n    }\n}\n \n// Verbosity sets Foo&#039;s verbosity level to v.\nfunc Verbosity(v int) option {\n    return func(f *Foo) {\n        f.verbosity = v\n    }\n}\n \nfoo.Option(pkg.Verbosity(3))\n这个例子可以适用于大部分的情况，不过如果希望只是临时的调整某个设置，然后在调用之后恢复到之前的设置，可以考虑更进一步:\ntype option func(f *Foo) option\n \n// Option sets the options specified.\n// It returns an option to restore the last arg&#039;s previous value.\nfunc (f *Foo) Option(opts ...option) (previous option) {\n    for _, opt := range opts {\n        previous = opt(f)\n    }\n    return previous\n}\n \n// Verbosity sets Foo&#039;s verbosity level to v.\nfunc Verbosity(v int) option {\n    return func(f *Foo) option {\n        previous := f.verbosity\n        f.verbosity = v\n        return Verbosity(previous)\n    }\n}\n \nfunc DoSomethingVerbosely(foo *Foo, verbosity int) {\n    // Could combine the next two lines,\n    // with some loss of readability.\n    prev := foo.Option(pkg.Verbosity(verbosity))\n    defer foo.Option(prev)\n    // ... do some stuff with foo under high verbosity.\n}\n参考链接\n\nRob Pike’s Blog\n《Go 语言精进之路：从新手到高手的编程思想、方法和技巧1》，白明，25.4 实现功能选项模式。\n"},"2024/囚犯盒子问题":{"slug":"2024/囚犯盒子问题","filePath":"2024/囚犯盒子问题.md","title":"囚犯盒子问题","links":["2023/Linked-List"],"tags":["DataStructure/LinkedList","思维实验"],"content":"问题\n假设有一百名囚犯，编号 1-100，你是监狱的典狱长，决定给这一百个犯人一个机会，让他们玩一个游戏，如果能通过，他们能够重获自由。\n游戏的规则是这样的，首先将 1-100 编号的纸条随机的放入盖子上有 1-100 编号的 100 个盒子里，将这 100 个盒子放入到一个单独的房间中。游戏开始，每次一个犯人单独进入房间，他有打开 50 次不同盒子的机会寻找自己对应号码的机会，找完之后无论他是否找到自己的编号，都从另一扇门离开，所有打开的盒子都会被关上，全程他无法与其他囚犯交流，也不能在盒子上做标记。这样依次类推，直到所有的犯人都找寻完毕。在第一个犯人进入房间之前，所有的犯人可以在一起商量对策。如果一百个犯人全部都找到了自己的号码，那么所有犯人都会被释放；反之，如果有任何一个人没有找到自己的号码，那么所有的犯人会被立刻处决。\n问题是，犯人是否可以采取什么样的策略可以提高所有人的生还机会咧？\n策略\n如果犯人不采取任何策略，那么所有人能够生还的概率为 P = (\\frac{1}{2})^{100} ，基本等于就地处决了，但天无绝人之路，有一个策略可以使的所有犯人生存概率提升到 31%。\n这一策略利用了链表中的环的知识，具体的步骤是这样的，犯人首先打开有自己编号的盒子，如果里面纸条的号码为自己的号码，则可以直接离开，如果不是，那么就去打开里面纸条号码对应的盒子，如果还不是，那去打开该盒子中纸条编号对应的盒子，依次类推，直到找到自己的号码，或者打开了 50 个盒子。\n我们仔细思考一下这个策略就会发现，他是链表中环的应用，首先纸条和盒子的编号都是 1-100，意味着他们一定会形成一个或多个的环；从自己编号的的盒子开始，意味着犯人进入了有自己号码的那个特定的环，只要这个环的长度没有超过 50，那犯人一定可以找到自己的号码，不仅如此，这环里的其他人也一定能在 50 次以内找到自己的号码。\n这样问题就转换成了100个盒子和纸条随即分配形成的环不超过 50 的概率，而这个概率算出来大约在 31%。\n参考\n\nGal, Anna, and Peter Bro Miltersen. “The Cell Probe Complexity of Succinct Data Structures,” n.d. doi.org/doi:10.1016/j.tcs.2007.02.047.\n"},"2024/女性问题之社会基础":{"slug":"2024/女性问题之社会基础","filePath":"2024/女性问题之社会基础.md","title":"女性问题之社会基础","links":[],"tags":["政治经济/共产主义","Reference/Literature"],"content":"\n\n                  \n                   编者按：\n                  \n                \n\n柯伦泰是早期布尔什维克的领袖，国际共运中女权脉流之重要一人。诚然，作为一个世纪前的“女性主义者”（她十分反对“女性主义”一词），她的文章不如后现代派般“华丽”，甚或有些“政治不正确”。但她的文章于当代女性主义，尤其是如何理解、处理性别与阶级关系的问题上，依旧意义重大。更重要者，她是布尔什维克妇女部（Zhenotdel）之创立者，是一度使苏联在世上于女性权益走得最前的人。若要使女性主义回归到其革命根源，让女性主义真正成为解放政治的一部分，这段历史，这些思想资源，仍值得承继。\n《女性问题之社会基础》是柯伦泰在 1909 年所著的一本小册子，是她首篇马克思主义女性主义作品。要理解这篇文章，先应了解当时沙俄女权运动。\n俄国的女性解放运动肇始于 1861 年的农奴解放。当时的启蒙贵族与中产女性争赴外国（主要是瑞士）留学，深受社会主义思潮——尤其是巴枯宁（Mikhail Bakunin）无政府主义的影响。她们回国后，有的投身俄国民粹派，有的加入当时方兴未艾的社会民主党。简的来说，起初俄国的女性运动是具明显工农倾向的。然而，自 1904 年后，中产女权派眼见芬兰女性普选权运动的成功，开始投向主张君主立宪的自由派，成立了妇女平等联盟（Union for Women’s Equality），尝试推动一个“统一女性运动”。参与者不仅有社会显达、慈善家与中产专业人士，亦有不少社会民主党人。这篇文章不单尝试建立一种马克思主义的性别政治理论，亦是对运动的双重批判：一方面，批判资产阶级女性主义的“普世女性”观念；另一方面，批判于女性问题上与“女性主义者”合流，鼓吹阶级合作的党内人士，借此抗击当时于俄国影响力日增的修正主义潮流。时至今日，文中不少对自由派女性主义批评依然十分合时。\n\n\n让资产阶级学者在那些关于性别优越性，或是较量男女大脑重量和心理结构的讨论中自得其乐吧。历史唯物主义的追随者完全接受每种性别的自然分殊，只要求每个人，或男或女，享有最完全和最自由的自决，以及最广泛地发展及实现他们的自然倾向。\n历史唯物主义的追随者拒绝承认有任何独立于当下普遍社会问题而存的特别女性问题。女性之从属地位背后的是特殊之经济成因，而自然属性只是这个过程的次要原因。只有这些成因彻底消失，只有在过去某些节点征服女性的力量更迭，才可根本地影响和改变女性的社会地位。换言之，只有在一个基于新的社会及生产路线组织的世界之中，女性才能变得真正自由和平等。\n然而这并不代表不可能在现代体制框架下局部改善女性的生活。工人问题的激进解决方案只在完全重构现代生产关系时才有可能实现，但这是否必然意味着我们不可以着手推动那些满足无产者最迫切利益的改革吗？相反，工人阶级的每一战果都代表着人类迈向自由王国与社会平等的一步：每一项女性争得的权利都使她们接近全面解放的目标。\n社会民主党破天荒的于其纲领内要求女性平权；党何时何地也在演说和出版物中要求取消一切对女性的限制；正是党的影响力使其他政党和政府都推行利于女性的改革。而在俄国，这个党并不只在理论立场上捍卫女性，它在每一方面也奉行女性平等的原则。\n那是什么令我们的“平权份子”无法接受这个强大且久经历练的党的支持呢？事实是，不论这些平权运动份子有多“激进”，他们依旧忠诚他们所属的资产阶级。政治自由现正是俄国资产阶级成长和力量的必要前提，没有了它，后者的经济福祉之基础便会极为脆弱。对女性而言，对政治平等的诉求是脱胎自生活的必然性。\n“专业就业”的口号已不再足够；只有全国直接参与政府事务才能保证对提高女性经济境况的支援。因而中层资产阶级的女性才如此渴望获得公民权，亦因而她们如此敌视现代的官僚制度。\n但是，我们的女性主义者在要求政治平等时就像她们的外国姊妹般，对社会民主知识所拓展的广阔视野依旧十分陌生和不明所以。女性主义者在现有阶级社会的框架下寻求平等，她们绝不攻击这个社会的根基。她们为自己争取特权，而不挑战现有的特权和优裕。我们不会因为资产阶级女性运动的代表无法理解这个问题而指责她们，她们对事物的观点无可避免的从其阶级立场派生。\n经济独立之斗争\n首先我们一定要问问自己，究竟在一个基于阶级矛盾的社会以内，是否可能存在一个联合的女性运动。每个不带偏见的看倌都很清楚，参与解放运动的女性并不代表一个同质的群众。\n正如男性的世界，女性的世界也是分为两个阵营的；其中一组女性的利益与目标使她们向资产阶级靠拢，而另一组与无产者有着紧密的联系，其对解放的要求包含了彻底解决女性问题的方案。因而即使两者都跟随着“女性解放”这普通的口号，她们的目标与利益是不同的。每一群人也无意识地以其所属的阶级利益作为其她们的出发点，这使她们自我设定的目标和任务无不染上特殊的阶级色彩。\n无论女性主义者的诉求怎样貌似激进，都不能忽视因其阶级立场，女性主义者不能为当代社会的经济与社会结构之根本转化而战——而这正是彻底的女性解放所必须的。\n即便在某些环境下各阶级的女性的短期要务一致，两个阵营的终极目标最终亦会因为长期上受其决定的运动方向及策略而南辕北辙。当女性主义者视于当代资本主义世界框架下达至与男人同等权益为已足够具体的自足目标时，对无产阶级女性而言，现时的平等权益不过是推进工人阶级与经济奴隶制斗争的一种手段。女性主义者视男性为主要敌人，因为男性为着自己不公地夺去了一切权利与特权，除了锁链和责任，再没为女性留下什么。对她们而言，只要把此前仅为男性享有的特权让与女性，这已算取得胜利了。无产阶级女性有着另一种态度。她们并不视男性为敌人与压迫者；相反，她们视男性为与她们共负每天苦差，与她们一起为一个更好的未来而奋斗的同志。女性和她的男性同志被同样的社会条件奴役；他们所痛恨的资本主义锁链压迫着他们的意志，剥夺他们生命中欢乐和美好之处。诚然，当代体制在某些特殊方面使女性担负了双重的压力，而雇佣劳动的条件亦有时把女工变为男性的竞争者和对手。但在这些不利的境况之下，工人阶级深知错在谁身上。\n女性工人的苦况并不比她们的兄弟少，她们痛恨那头利牙镀金的怪物——它对男性、女性和孩子同样贪婪，只想从受害者吸干一切，牺牲几百万条人命来壮大自身。千条万绪使劳动者互相走近。另一方面，资产阶级女性的目标却看起来十分奇怪、难以理解。她们没打动无产者的心；她们并不向无产阶级女性许诺一个所有被剥削者青眼相看的光明未来。\n当然，无产阶级女性的最终目标并不阻止她们改善其地位，哪怕是在现行的资产阶级体制框架内，但这些欲求之实现却经常被由资本主义本质的衍生问题所窒碍。女人只有在一个社会化劳动、和谐和正义的世界中才能拥有平等权益和自由。女性主义者不愿，亦不能理解这一点；于她们看来，当法律在形式化的一纸空文接受平等时，她们便可以在充满压迫、奴役、束缚、血泪与苦难的旧世界中赢得安身之所。而这于某程度上亦是正确的。因为对大多数的无产阶级女性而言，与男性平权只意味着平等地共负不平等；但对“被选中的一小撮人”而言，对资产阶级女性而言，这真的可以迎来此前只为资产阶级男性所享有的权利和特权。但资产阶级女性所赢得的让步都使她们取得利器以剥削妹妹们，并会使两个对立的社会阵营中的女性持续分化。她们的利益冲突会愈趋尖锐，她们的目标之矛盾性会愈趋明显。\n那么，普遍的“女性问题”究竟在哪？女性主义喋喋不休的统一任务和目标究竟在哪？清醒地看待现实，便会发现这种统一性并不存在，亦不能存在。女性主义徒劳无功地试图说服自己“女性问题”与政党无关，以及“其解决方案只有所有政党和所有女人参与其中时只可能实现”；正如一个激进的德国女性主义所言，事实的逻辑迫使我们拒绝女性主义者这种循规蹈矩的幻觉。\n通观人类历史，生产条件及形式都使女性处于从属地位，并逐渐把她们编配到被压迫与依附的地位上，而至今当中很大部分依然存在。\n在女性可以开始重拾她们失去的重要性与独立性之前，整个社会及经济结构必须出现一次巨大的裂变。一度连最天才的哲人亦难以解决的问题，现已被无生命却全能的生产条件所解决。这几千年奴役女性的力量，于新的发展阶段中，已领导她们走上自由与独立之路。\n约在十九世纪中叶，女性问题对资产阶级女性日益重要——这距离无产阶级女性登上劳动舞台已有一段时日。在资本主义惊人的成功下，人口内的中产阶层受到一波又一波需求的冲击。经济变化使小资产阶级与中层资产阶级的财务状态不稳，而资产阶级女性便面对一种进退维谷的两难：不是承受贫穷，便是取得工作权。这些社会群体的妻子与女儿便开始叩谒大学、艺术沙龙、编辑部和办公室，潮涌进那些向她们开放的职位。\n资产阶级女性取得科学与文化优势的欲望并不是一种突然、成熟中的需求，它同样脱胎自“讨生活”的问题。资产阶级女性首先便遭罹男性死硬的抵抗。执迷于其“安逸小工作”的专业男性与刚开始讨生活的女性之间便爆发了一场恶战。这场斗争使“女性主义”得以冒起——这是资产阶级女性团结合力对抗敌人，对抗男性的尝试。当她们登上劳动舞台，这些女人便自傲地自号为“女性运动的先锋”。她们忘记了于赢得经济独立上，她们不过是在步其妹妹的后尘，并收割她们那对疱裂的双手中之成果。\n所以当各国成千上万无产阶级女性于资产阶级女性运动诞生以前已涌入工厂与作坊，占据一个又一个工业分支时，我们真的可以说女性主义者开拓了女性工作的道路吗？只有在女工的劳动受到世界市场认可时，资产阶级女性才能在社会占上女性主义者引以为傲的独立地位。\n我们甚至觉得很难指出在无产阶级女性的斗争史中，一般的女性主义运动对提高她们的物质条件有什么突出的贡献。每当无产阶级女性在改善自身生活标准的方面上有所成就，这都是普遍的工人阶级——尤其是她们自身——的奋斗成果。女工为着提升劳动条件及改善生活的斗争史，便是无产阶级为了解放自身的斗争史。\n若然不是恐惧无产者之不满危险的爆发，还有什么驱使工厂主提高劳动价格、减少工时，并采择更好的劳动条件？若然不是害怕“工人骚乱”，还有什么可说服政府为限制资本剥削劳工而立法？\n世上没有一个政党如社会民主党般以捍卫女性为务。女工首先是工人阶级的一份子，而无产阶级大家庭中每个成员的地位和一般福祉愈叫人满意，长期而言，对工人阶级的利益便愈大。\n面对日深的社会困局，为了解放事业，真诚的战士必不可陷于悲痛的困惑。她不能不看到一般的女性运动对无产阶级女性那么少的贡献，它对改善工人阶级的工作及生活条件是多么的无力。在那些为平等而奋斗，却仍未采纳无产阶级世界观，或未发展出一个更完美的社会制度将至的坚定信念的女性而言，人类的未来或许灰暗无光、了无生气、无法预料。在当代资本主义仍未被改变时，解放对她们一定看似不彻底，亦无所偏向。绝望会勒紧那些思想更深邃、更敏感的女人。只有工人阶级能在这个社会关系扭曲的现代世界中保持士气。它已坚定和谨慎地往目标迈步前进。它把女性工人带到战列之中。无产阶级女性勇敢地于工人那荆棘满途的道路上出发。她的双脚压弯了，她的身躯业已破损。路上仍有危险的绝壁，残暴的野兽近在咫尺。\n但只有在这条路上，女性才可以达成那个遥远却可人的目标——她在一个劳动者的新世界之中真正解放。于这场通往光明未来的苦难行军，直至最近还是被受凌辱蹂躏而毫无权利的奴隶的无产阶级女性，开始学会了抛弃紧捏着她的奴隶心态，一步步把自己转化为一个独立工人、一个于爱情上自由的独立人格。正是在无产阶级战列中奋斗的她，为女性赢得工作权；正是她，这个“妹妹”，为着未来“自由”与“平等”的女性奠基。\n因此，为何女性工人应寻求与资产阶级女性主义者结盟呢？谁，在实际上，会在这个同盟中获利呢？肯定不是女性工人。她是她自身的救世主；她的未来就在她手里。女性工人捍卫她的阶级利益，并不被那些言称“所有女性共有的世界”的伟大演说所蒙骗。女性工人一定不可忘记，亦没有忘记，当资产阶级女性的目标是要在一个反对我们的社会框架中保障她们自身的福祉，我们的目标便要在这个老旧过时的世界中，建起一座普世工人、同志情谊与自由之乐的辉煌圣殿。\n婚姻与家庭问题\n让我们回到女性问题的另一方面——家庭问题。这迫切而复杂的问题之解决方案对真正的女性解放之重要性已广为人知。为着政治权利、博士学位及其他学位，以及同工同酬的斗争，都并非平等之战的总和。欲真正变得自由，女性需要舍弃现时陈旧而压迫性之家庭形式的沉重锁链。对女性而言，家庭问题之解决的重要性，并不比达至政治平等与经济独立为低。\n在今天的家庭，家庭结构由习俗与法律所确定，女性不只作为一个人——同时亦作为一个妻子和母亲——受尽压迫。在大部分文明世界中的国家，民法都把女性置于一个或多或少依附于其丈夫的地位，而同时不只给予丈夫处置妻子财产的权利，而亦给予他以道德和物理上宰制她的权力。\n当于官方与法律上终结了女性被奴役的境况，我们称之为“公众舆论”的力量便发始了。这种公众舆论是资产阶级为了维护“神圣产权制度”而创造及支持的。“双重道德”的虚伪则是另一件武器。资产阶级社会以野蛮的经济罪恶辗压女性，仅以很低比率偿付其劳动。女性被剥夺了她用来捍卫自身权益的市民权：反之，却只赋予了她被婚姻束缚或被卖淫紧缠——一种在公众会被唾弃及迫害，而在暗地里却被鼓励和支持的贸易——的美好选项。我们还有必要强调当代婚姻生活的黑暗面和女性于其现有家庭结构的地位中所经历的痛苦吗？关于这个问题，人们已写了很多，说了很多。文学经常抑压地描绘婚姻与家庭生活的陷阱。多少心理剧在上演着！多少生命因而残缺不全！于此，我们仅仅需要注意现代家庭结构，或多或少，都在全人口里各个阶级各个层面上压迫女性。不论一个年轻的母亲属于哪个社会阶层，习俗与传统也处罚她；法律把资产阶级女性、无产阶级女性与农民女性一律置于她们的丈夫的管辖下。\n难道我们至此仍未觉察到所有阶级的女性能就哪一方面的女性问题而联合在一起吗？她们能不团结地与压迫她们的环境抗争吗？难道女性于此共负的悲痛与苦难不可能软化阶级对立的掣肘，并为不同阵营的女性提供共同的目标和一致的行动吗？在共同愿望与目标的基础上，难道不会催生出资产阶级女性与无产阶级女性合作的可能性吗？女性主义正为了更自由的婚姻形式与“母亲权”而奋斗；她们为了保护被所有人迫害的妓女而高呼。看看那些丰硕的女性主义文学如何寻觅新型性关系，并热衷地要求性别间的“道德平等”。虽然于经济解放方面，资产阶级女性远远落后于作为“新女性”先驱的无产阶级女性大军，但于争取解决家庭问题上，女性主义者难道不应获得嘉奖吗？\n在俄国，中层资产阶级的女性——于 1860 年代被投入劳动市场的独立雇佣劳动者——很久以前已在实践上解决了婚姻问题里很多疑难。她们果敢地以更弹性，且能满足那社会层面的性关系形式取代了传统宗教婚姻的“固化”家庭。但个体女性对这问题的主观解决方案并不会改变情势，亦不会纾缓整个家庭生活的惨象。假如有什么力量正破坏现代家庭的形式，那并非相互割裂、较强的个体所作的极大努力，而是毫不妥协地在新基础上孕育新生、无生命而极大的生产力。\n资产阶级世界里个别的年轻女性向社会发起挑战，要求没有秩序亦没有枷锁，“敢于去爱”的权利。外国那些更自由的女性主义者与我们这里进步的平权份子都在说教：所有饱受家庭枷锁之苦的女性都应效法这种英勇奋斗。换言之，在她们看来，婚姻问题能在不指涉外部情势下得到解决；它能独立于社会的经济结构变革而得到解决。单靠这种勇敢的个人努力便足够了。只要女人“敢作敢为”，解决婚姻问题便势如破竹了。\n但没那么英勇的女性会怀疑地摇摇头。“作家精心的在小说里给了那些女中豪杰很大的独立性、无私的友人和非凡的魅力，她们才得以此挑战社会。这都不错。但那些没有资本、工资不足、没有朋友和魅力微弱的女人又如何做到呢？”而母亲问题亦在妨害那些欲争自由之女性的心灵。“自由恋爱”可能吗？在我们社会既定的经济结构下，它能作为一个普遍现象，作为一种得到广泛接受的现象，而非个别的例外而实现吗？有可能忽视当代婚姻中的私有制元素吗？在一个个体论世界里，有可能在不损害女性权益的情况下，忽视形式化的婚姻契约吗？因为婚姻契约就是在她们成为母亲时，好使困难不至全落在女方一人身上的唯一保证。曾在男性工人身上发生的事，现在难道不会再发生于女工身上吗？在未订立限制行会师傅的新行为守则时移除行会规则，终使资本全权驾驭于工人之上。“为了劳工与资本的契约自由”这个诱人的口号变成资本赤裸裸地剥削工人的手段。不断传入当代阶级社会里的“自由恋爱”不能从家庭生活的困局中解放出来，却必然使她负上新的重担——独自而无助地照顾自己的孩子。\n只有在社会关系中全数的根本改革——使责任从家庭转移至社会及国家的改革——才会创造出可能使“自由恋爱”原则于某程度上得以实现的环境。即使有个多么好多么民主的现代阶级国家，我们能真的期望它负起现正由现代家庭的个体论单位所负起的对母亲与孩子的责任吗？只有所有生产关系的根本转型才会创造出社会前提，保护女性免受“自由恋爱”公式之负面影响。我们注意到现况下的腐败与反常正急以这个便宜的标签矇混过关吗？看看那些坐拥和管理工业企业的绅士们，如何以解雇胁迫劳工与文员中的女性满足他们的性欲吧。他们不就是以自己的方式实践“自由恋爱”吗？那些强奸家佣，并在她们怀孕时逐出家门的“一家之主”，不也是遵行着“自由恋爱”的公式吗？\n自由婚姻的倡导者反对道：“但我们不是在说那种‘自由’。相反，我们要求接纳一种平等地约束两性的‘单一道德’。我们反对现时的性放荡，并只视基于真爱的自由结合为合符道德的。”但我亲爱的朋友，你认为在现时社会的条件下实践你“自由婚姻”的理想，不会产生与扭曲地行使性自由相差无几的结果吗？只有卸去现时那些产生女性对资本及丈夫双重依附的物质负担时，“自由恋爱”的原则才可以贯彻而不给女性带来新的悲痛。当女性出外工作并达至经济独立，尤其是知识分子群体中薪金较为优渥的女性，都有遇上“自由恋爱”的可能性。但女性对资本的依附仍然存在，而且这种依附会随着愈来愈多无产阶级女性出卖劳动力而增强。“自由恋爱”的口号能改善那些挣扎求存的女性之惨况吗？无论如何，工人阶级里“自由恋爱”不是早已广为实践，以至于资产阶级不止一次警告并反对无产阶级的“堕落”和“不道德”吗？请注意，当女性主义者歌颂那些资产阶级解放女性都加以考虑的新型婚外同居时，她们大谈“自由恋爱”，但当谈及工人阶级，她们便会蔑称为“性滥交”。这已概括了她们的态度。\n但对无产阶级女性，不论现时的性关系是否受教会认可，最终都是同样残酷的。对无产阶级妻子和母亲而言，家庭与婚姻问题之症结不在于外在的神圣或世俗问题上，而于随之而生的社经问题，界定无产阶级女性那些复杂责任的条件。当然，丈夫有没有权力管理她的收入，有没有法律权利强迫她与他同居，能不能强行带走她的孩子等等，对她来说亦很重要。然而，民法中的条文并未决定女性的家庭地位，它们也不是使家庭问题变得混乱和复杂之原因。只有在社会免去女性现时无法避免的家务（基于个体、分散的家庭经济），负起照顾年轻一代的责任，保护母亲并在孩子出生后的头几个月让她们待在一起，性关系问题才不会如此痛苦。\n在反对合法和神圣的教会婚约时，女性主义者是在打击拜物教；而无产阶级女性则是向现代婚姻与家庭形式之条件发动战争。在力图根本地改变生活条件时，她们清楚她们同时也是在改革两性关系。这里我们便看到了资产阶级与无产阶级处理家庭难题时的主要之别。\n资产阶级阵营中的女性主义者与社会改革者天真地相信于她们可能在当代阶级社会的绝景中创造新型的家庭和婚姻关系，因而在寻觅这些新形式时迷失了。她们似乎在想，若然生活没有生出这些形式，那无论如何都一定要想出来。她们相信一定有一些现代性关系形式，可以在现有社会体制下解决复杂的家庭问题。而资产阶级世界的空想家——记者、作者与女权斗士一个接着一个提出他们的“家庭万灵丹”，他们新的“家庭配方”。\n这些婚姻配方听起来多么的乌托邦啊。想到我们现代家庭结构的灰暗现实，这些缓和疗法是多么的无用啊。在这些“自由关系”与“自由恋爱”的公式可以付诸实行之前，必须根本地改革一切人与人之间的社会关系；再者，道德与性规范，乃至整个人类的心理皆须彻底进化，当代人在心理上真的能接受“自由恋爱”吗？那连最好的灵魂亦会一并吞噬的嫉妒又怎样呢？那不只要拥有对方的身体，更要拥有对方的灵魂，深植其中的财产观念又怎样呢？无法尊重对方之个体性又怎样呢？不是服从于爱人，便是要驾驭爱人的习性又怎样呢？因爱人离弃而历经那苦涩绝望的孤独，陷入无垠的寂寞，这又会怎样呢？一个骨子里的个人主义者在孤独时可以从何寻求慰藉？个人情感和智力的最佳出路便是那众人共享着欢乐、沮丧和抱负的集体。但现代人能够与这个集体合作，以至感受大家的相互影响吗？直至目前为止，这种集体生活真的能取代个人的小确幸吗？没有这“独特”、“独一无二”的双生灵魂，即便是社会主义者、集体主义者也会在现在这个对立的世界里感到寂寞；只有在工人阶级中我们才能瞥见未来，及更和谐更社会化的人际关系。婚姻问题就如生命一般复杂和多面向。我们的社会制度没有能力解决它。\n其他的婚姻公式亦被提出来了。一些进步女性和社会思想家视婚姻结合不过是一种繁衍后代的方法。他们坚信婚姻自身对女性并没有任何特别价值——成为母亲才是她的要旨、她神圣的目标、她一生之重任。多亏像路芙·彼尔（Ruth Bray）与爱伦·凯（Ellen Key）这些启发人心的倡导者，视女人为女性而非人类的资产阶级空想取得一种特别的进步光环。\n外国文学热切地高举这些进步女性提出的口号。即使在俄国这里，在（1905 年）政治风波以前，在社会价值被重新检视以前，母亲问题也吸引到报纸的注意。“母亲权”的口号并不会在最广泛的女性人口中激起什么回响。因此，虽然女性主义者就此提出的建议无不异想天开，但这个问题本身十分重要，十分合时，女性不得不关心。\n“母亲权”是一个不只关乎资产阶级女性，亦触及无产阶级女性的问题。成为母亲的权利——这些是会直接打进“所有女人心”，并使她们心跳加速的至言。以自己的乳水喂养“自家”孩子的权利、见证他苏醒一刻的权利、照料他细小的身躯，从生命首步的荆棘中保护他柔嫩的灵魂，以免他受苦的权利——哪个母亲不会支持这些诉求？\n看来我们又碰上可以使社会各阶层的女性团结一起的议题了：看来我们最终发现了连结两个敌对世界中的女性的桥梁了。让我们看清楚进步资产阶级女性对“母亲权”的理解是怎样。这样我们才得看到事实上无产阶级女性能否接受资产阶级平权斗士预想的解决方案。在其热心的辩护士眼中，母亲拥有一种近乎神圣的性质。为了粉碎那些因法律仍未认可而给进行自然活动——分娩——的女性贴标签的虚伪偏见，争取母亲权的斗士便把棍子折向另一面折：对她们来说，母亲已成为女性生命的目标。\n爱伦·凯对母亲及家庭责任的投入令她认为即使在一个以社会主义路线转型的社会里，孤立的家庭单位仍会继续存在。她眼中会变的，便只是随之而来的各种便利，或是物质利益被排除于婚姻以外，并通过双方意愿而非仪式或是礼节结合两者——爱情与婚姻会真正的变为同义词。但这种孤立的家庭单位正是现代个体论世界中的竞争、压力与孤独的结果；家庭是可怕的资本主义制度的产物。然而爱伦·凯却希望在社会主义社会中为家庭续命！诚然，现时血亲连系往往是生活中的唯一依靠，于困难与不幸中唯一的避难所。但在未来它们于道德上于社会上是必要的吗？爱伦·凯没有解答这道问题。她太热衷于“理想家庭”了，而资产阶级社会结构的拥护者都会很崇敬这种中层资产阶级的利己主义单位。\n但不只这位天才却古怪的爱伦·凯在社会矛盾中迷失方向。在社会主义者之间，大概没有一个问题比起婚姻与家庭问题可以产生更大的分歧了。假使我们尝试在社会主义者里进行调查，那调查结果很可能十分有趣。家庭会消亡吗？认为现时的家庭失序只是过渡危机的想法有根据吗？在未来社会中，现有家庭形式会得到保留，还是会与现代资本主义体制一同被埋葬？这些问题都会换来很不同的回应。\n当家庭的教育功能转移至社会时，维系着现代独立家庭的最后一结将会被松绑；瓦解的过程甚至会加速，而未来婚姻关系的模糊轮廓将逐渐浮现。我们可以怎样描述这些深受当下影响而潜藏的模糊轮廓呢？\n还要重复地说，现行强迫的婚姻形式将会被爱人的自由结合所取代吗？那些解放奋斗的女性所渴想的自由恋爱理想，无疑与社会即将建立的两性关系规范相呼应。然而，社会影响太复杂，而其互动又太多样，以至我们不可能预言当整个体制彻底改变时，未来的性关系将会如何。但两性关系慢慢转趋成熟的演化已清楚表明了，仪式婚姻与强迫性的独立家庭将注定消失。\n为政治权利而斗争\n女性主义回应我们的批评，说：即使在你看来，我们捍卫女性政治权利的论点都是错误的，这对女性主义者与工人阶级代表同样迫切的诉求的重要性会因而削弱吗？为了她们共同的政治抱负，两个社会阵营的女性就不能跨越分隔她们的阶级对立障碍吗？她们一定能对包围她们的敌人枪口一致的抗争吧？女性主义者幻想，虽然在其他问题上资产阶级与无产阶级无可避免地对立，但在这个问题上，不同社会阶级的女性却没有什么不同。\n女性主义者一而再，再而三，怨恨地、疑惑地回到这些论题上。在工人阶级代表拒绝与她们为女性政治权益共同作战时，她们只看到先入为主、忠于派系的观念。真是这样一回事吗？\n存在着一种彻底的政治身份吗？抑或如在这个和其他例子中，对立正窒碍着一队不可约化、高于阶级的女性大军之形成？在概括无产阶级女性于争取政治权利应采取什么策略之前，我们应先厘清这些问题。\n女性主义者号称站在支持社会改革的一方，有一些甚至自称欢迎社会主义——当然是在遥远的未来了——但她们并不打算为了实现这些目标而加入到无产阶级战列的斗争中。她们当中的佼佼者很天真地相信，只要她们能取得议席，她们便能使社会的痛楚痊癒，因为在她们看来，问题在于自私自利的男人一直是掌控局势的人。不论这些个别的女性主义团体对无产者抱有多么良好的意愿，每当提出阶级斗争的问题时，她们便吓得从战场落荒而逃。她们发现自己其实并不希望在别的事业参一脚，只想与使她们感到舒适又熟悉的资产阶级自由主义待至终老。\n不，无论资产阶级女性主义者如何尝试压抑她们真正的政治目的，无论她们如何向其妹妹保证参与政治生活能为工人阶级女性带来难以估量的好处，贯穿于整个女性主义运动中的资产阶级精神都会在与男性政治平权的诉求上染上阶级色彩，即使这看起来像个普遍的女性诉求。不同的目标与对如何使用政治权利的不同理解，都会在资产阶级女性与无产阶级女性间划下鸿沟。这并不与两个女性群体的当务之急颇有重合的事实相悖，因为所有拥有政治权力的阶级代表都力求重新修订或多或少歧视女性的民法。女性推动着能创造出对她们更有利的劳动条件的法律改革；她们一起反对卖淫合法化的法规，等等。然而，当务之急的重合全然是在形式上的。因为阶级利益决定两个群体看待改革的态度是极为矛盾的。\n阶级本性——无论女性主义者怎样说——经常证明自己比那些“跨阶级”政治的高尚情操更为有力。只要资产阶级女性与她们的“妹妹”仍然平等地共负不平等，前者便仍可以完全真诚地为普遍的女性福祉付出努力。但一旦障碍倒下，而资产阶级女性可以参与政治活动，那么最近那些“一切女性权益”的卫士便会转而热衷于捍卫自身的阶级特权，即便妹妹们无权可言也没有所谓。因此，当女性主义者向女性工人宣说，为了实现一些“普遍的女性”原则而需要共同抗争时，工人阶级女性自然不会信任她们了。"},"2024/最小生成树":{"slug":"2024/最小生成树","filePath":"2024/最小生成树.md","title":"最小生成树","links":["2024/Graph","2024/Tree"],"tags":["DataStructure/Graph"],"content":"最小生成树（Minimum Spanning Tree） 是在一个无向连通加权图中一个联通了所有节点，并且所有边的权重的和是所有连通方案中最小的，无环的一个节点和边组成的子集，因为无环，所有这个子集也是一个树，所以叫最小生成树。\n对于一个无向非连通（不是所有的节点都有路径相连）加权图，每个连通的分量（子图）中都有自己的最小生成树，所有的最小生成树的合集被称为最小生成森林。\n对于给定的图，求解最小生成树的算法主要有两种：\nKruskal 算法\nWiki\n按照边的权重顺序（从小到大）将边加入生成树中，但是若加入该边会与生成树形成环则不加入该边。直到树中含有 V−1 条边为止。这些边组成的就是该图的最小生成树。\nPrime 算法\nWiki\n每一步都会为一棵生长中的树添加一条边，该树最开始只有一个顶点，然后会添加 V−1 个边。每次总是添加生长中的树和树中除该生长的树以外的部分形成的切分的具有最小权值的横切边。"},"2024/氢能产业概况":{"slug":"2024/氢能产业概况","filePath":"2024/氢能产业概况.md","title":"氢能产业概况","links":[],"tags":["政治经济/产业分析"],"content":"氢能的分类\n\n白氢，自然储备的自然氢，需要开采，储量少；\n灰氢，传统制氢，从化石能源（煤炭，天然气）中制造，制造过程会产生碳排放；\n蓝氢，通过传统方法制氢之后，通过手段将制造过程中的碳排放中和回收；\n绿氢，通过可再生能源发电，再电解水制造的氢。\n\n目前，我国传统制氢行业已是全球最大，但氢只是作为各种产品的中间产物，如今要大力发展的是使用绿氢做为能源利用的产业，比如交通领域，包括使用氢燃料电池的汽车，火车，轮船和航天。\n目前的氢能产业\n\n交通运输，运载卡车，公交，轮船；\n各地氢能小镇，产学研一体，探索更多运用领域。\n\n绿氢能产业链\n\n上游制氢，绿电产业\n中游产业，储存和运输，需要高压低温的条件，汽车运输与管道运输\n下游利用，运输和储能\n\n参考连接\n\n2024-04-19 央视财经评论\n"},"2024/胜者思维":{"slug":"2024/胜者思维","filePath":"2024/胜者思维.md","title":"胜者思维","links":[],"tags":["书"],"content":"金一南教授的一本关于如何领导队伍以取得胜利的书，主要是他在不同的地方演讲所组成的。虽然面向的主要是军事将领，但是对其它职业的领导和管理也有借鉴意义。"},"2024/解决Linux中代理使得WebSocket连接失败的问题":{"slug":"2024/解决Linux中代理使得WebSocket连接失败的问题","filePath":"2024/解决Linux中代理使得WebSocket连接失败的问题.md","title":"解决Linux中代理使得WebSocket连接失败的问题","links":[],"tags":["Reference","Linux","Linux/Network"],"content":"WebSocket connection fails in Ubuntu 13.10\nWe’re having a weird problem at work and I’m hoping someone here can give me some ideas on how to troubleshoot it.\nThe problem is that I cannot make WebSocket connections from my Kubuntu 13.10 workstation. I’ve tried from both Chrome and Firefox. I’m behind a proxy and first I thought that must be the reason. However, I got some coworkers to try to connect to the same WebSocket echo demo and all of them were able to, except one. He was the only one running Ubuntu (same as me), the others were on Mac, Windows and even one on RedHat! Theirs all worked fine.\nOk, so now for the really weird part. I created and ran a virtual machine on my workstation (the one that couldn’t connect). The VM is a Lubuntu 13.10 and what do you know, the darn thing establishes a websocket connection just fine!\nSo any ideas on how to troubleshoot this or even some suggestions for solutions would be very much appreciated.\n\nwebsocket\nubuntu-13.10\n\n1 Answer\nUgh… well that one was dumb.\nSo it turns out that in Linux you can check a checkbox in your Network Proxy settings (the system settings) that will use the same proxy for all protocols.\nYeah… don’t do that!\nUnless, that is, your proxy server supports SOCKS as well as HTTP/HTTPS/FTP (highly unlikely).\nIt turns out that if you check that checkbox, your proxy server will be registered as a SOCKS proxy and for some reason, websocket connections in both Chrome and Firefox will want to use that. So your HTTP proxy will end up getting a bunch of weird SOCKS handshakes that it doesn’t understand and any websocket connection will fail.\nThis was tested on both Ubuntu and Kubuntu and the “problem” exists on both.\nTL;DR; Don’t check the “Use this proxy server for all protocols” checkbox unless your proxy server supports the SOCKS protocol. Instead, manually fill in the same server for the different protocols (http, https and ftp) but leave the socks protocol empty (or point to an actual socks proxy server)."},"2024/项目延期决策树":{"slug":"2024/项目延期决策树","filePath":"2024/项目延期决策树.md","title":"项目延期决策树","links":[],"tags":["技能/项目管理"],"content":"\n\n                  \n                  基本原则 \n                  \n                \n\n向下有对策，向上有交代。\n\n\n\nmindmap\n  root((项目延期))\n    n1(技术原因)\n      nn1[人力角度解决]\n        m1{{推动组内加班}}\n        m2{{争取更多人力}}\n          mm1)招聘（长期）(\n          mm2)别组抽调（短期）(\n      nn2[事情优先级]\n        nnn1)砍掉低优先级(\n    n2(非技术原因)\n      n2m1)做好沟通(\n    n3(无法解决)\n      n3m1)总结原因，向上沟通(\n"},"2024/领导":{"slug":"2024/领导","filePath":"2024/领导.md","title":"领导","links":["2024/胜者思维"],"tags":["书/管理"],"content":"“领导”有从字面上看有两个意思：领，走在最前面；导，告诉下属方向。领导者的主要工作是要带领大家前进，要给大家带来希望，要告诉大家前进的方向在哪里。\n克劳维茨认为真正的领导者要具备两大要件：第一是在一片黑暗中发现微光的能力，这是领导的智慧；第二是敢于跟随这微光前进的勇气，这来自领导的勇气与意志。最好的领导应该提供思想，也提供意志。\n领导和被领导的差别，在于领导既有权利又有责任，很多人想当领导只看到了权利没有看到责任，这是要出问题的。领导的工作就是运用权利承担责任的决策活动，决策活动分为平时决策和危机决策。对平时决策大家趋之若鹜，因为这是权利的体现，危机的决策却人人避之不及，因为危机体现的是责任。\n摘自《胜者思维》，金一南，第二章 危机中的领导者。"},"2024/高效危机处理的特点":{"slug":"2024/高效危机处理的特点","filePath":"2024/高效危机处理的特点.md","title":"高效危机处理的特点","links":["2024/胜者思维"],"tags":["技能/管理"],"content":"一个高效的危机处理显著的特点是：权力向下分散，责任向上集中。\n\n目的明确的分权，能让一线人员有处理问题的积极性与能动性\n分权也要有限制，要一线人员有足够的权力处理目标内的问题，也不能过于放开\n分权的同时也要给予相匹配的资源\n分权不分责，充分相信一线人员判断，责任依然领导承担。分权也分责，则不能调动一线人员的积极性，会担心承担责任而只做领导指示\n\n摘自《胜者思维》"},"2025/Bellman-Ford-算法":{"slug":"2025/Bellman-Ford-算法","filePath":"2025/Bellman-Ford 算法.md","title":"Bellman-Ford 算法","links":["2025/Dijkstra-最短路径算法","2024/Graph","2024/Breadth-First-Search"],"tags":["DataStruture/Graph"],"content":"Bellman-Ford 算法1 同 Dijkstra 最短路径算法一样是求解带权有向无环图中从一个源节点到目标节点的最短路径问题。不同与 Dijkstra 每次取最近的点进入集合再更新距离，Bellman-Ford 算法每次都是循环所有的边，更新所有边的终点距离，有点类似与 BFS，Bellman-Ford 从源节点一圈一圈的向外更新。优点是算法可以处理负数权重的边，缺点是时间复杂度高于 Dijkstra 最短路径算法。\n其大概过程用伪码表示：\nprocedure BellmanFord(list vertices, list edges, vertex source)\n   // 讀入邊和節點的列表\n   // 初始化圖distance為∞，predecessor為空\n   for each vertex v in vertices:\n       if v is source then distance[v] := 0\n       else distance[v] := infinity\n       predecessor[v] := null\n   // 對所有節點\n   for i from 1 to size(vertices)-1:\n        //檢查每條邊\n       for each edge (u, v) with weight w in edges:\n           if distance[u] + w &lt; distance[v]:\n               distance[v] := distance[u] + w\n               predecessor[v] := u\n\n   // 檢查是否有負權重的迴路\n   for each edge (u, v) with weight w in edges:\n       if distance[u] + w &lt; distance[v]:\n           error &quot;圖包含負權重的迴路&quot;\n\n算法的复杂度为：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-复杂度最坏时间复杂度O(V \\cdot E)最优时间复杂度O(E)空间复杂度O(V)\nFootnotes\n\n\nWikipedia ↩\n\n\n"},"2025/Dijkstra-最短路径算法":{"slug":"2025/Dijkstra-最短路径算法","filePath":"2025/Dijkstra 最短路径算法.md","title":"Dijkstra 最短路径算法","links":["2024/Graph","2024/最小生成树","2023/Greedy","2025/Bellman-Ford-算法","2023/Binary-Heap"],"tags":["DataStructure/Graph"],"content":"Dijkstra 最短路径算法1 是用于查找带权有向图中两点最短路径的算法，也可以用来从一个节点出发，找寻到图中所有其它节点的最短路径的问题。其核心其实和最小生成树中的Prime 算法类似，是一个贪心算法。\n\n\n                  \n                  特别注意 \n                  \n                \n\nDijkstra 算法并不能适用于有负数权重边的图，对于用负数权重的边，可以使用 Bellman-Ford 算法\n\n\n其主要的算法过程如下：\n将所有的节点分成两个集合，“已确定节点” 和 “未确定节点” （算法开始时，”已确定节点” 集合只包含起始节点）。\n算法开始后，每次从 “未确定节点” 的集合中找到离 “已确定节点” 最近的节点，将其加入到 “已确定节点” 集合，并且更新 “未确定节点” 中的节点到 “已确定节点” 集合的最短距离。（这里只需考虑与选择节点连通的节点，如果通过选择节点访问时，其距离比通过其它 “已确定节点” 访问的距离短，则找到了一条更短的路径，更新其距离）\n重复这一过程，直到我们遇到目标节点，或者访问到了所有节点。\n\n\n                  \n                  优化 \n                  \n                \n\n算法过程中我们需要一直查找最短的距离，所以我们可以考虑使用小顶堆来优化我们查找的速度。\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n算法最坏时间复杂度使用邻接表的戴克斯特拉算法O(V^2)使用二叉堆优化的戴克斯特拉算法O((E+V)\\log{V})\nFootnotes\n\n\nWikipedia ↩\n\n\n"},"2025/三脑理论":{"slug":"2025/三脑理论","filePath":"2025/三脑理论.md","title":"三脑理论","links":[],"tags":["心理学","技能/沟通方法"],"content":"除了在解刨结构上我们的大脑可以被分为大脑、小脑和脑干三个部分外，心理学家 Paul MacLean 提出在认知层面也可以分为三层由下至上的层级结构1，其分别为：\n\n原始动物脑（爬行脑）： 负责指导“战或逃”等行为和反应，基本属于下意识的反应，不涉及太多的思考。比如当遇到危险时第一反应是停止思考呆在原地一动不动，这是下意识里认为一动不动可以避免被捕食者发现的本能。\n哺乳动物脑（哺乳脑）： 是情绪反应层，种种强烈的情感都由这层产生和控制。\n灵长动物脑（理智脑）： 负责认知、智力和精神价值，它会从爬行脑和哺乳脑收集数据，筛选分析，逻辑推理，最后做出切实、明智符合道德规范的决定。\n\n三层结构分工合作，但在面临巨大压力和紧急情况时，运行较慢的理智脑可能会被关闭，爬行脑和哺乳脑控制我们的行为，这就是为何在有些冲突情况下我们的行为可能不受自身控制，放弃思考。\nFootnotes\n\n\n《倾听的力量》第二章 ↩\n\n\n"},"2025/倾听的力量":{"slug":"2025/倾听的力量","filePath":"2025/倾听的力量.md","title":"倾听的力量","links":["2025/说服周期","2025/三脑理论","2025/杏仁核劫持","2025/镜像神经元","2025/构建沟通的九大核心原则","2025/建立沟通的12种快速方法"],"tags":["书/心理学","技能/沟通方法","MOC"],"content":"《倾听的力量》1 是一本讲如何更好的与人沟通交流的书，作者马克-郭士顿（Mark Goulston）。全书共分为四个部分：\n第一部分，书中介绍了沟通说服的过程，将说服过程分为了几个说服周期，为了说服他人，我们在沟通过程中应该时刻注意我们处在说服的哪个阶段，从而正确的选择我们的策略；进一步，作者介绍了在沟通中影响我们的生理结构，利用三脑理论和杏仁核劫持解释了为何我们在沟通中会被情绪控制。而镜像神经元则向读者解释了沟通中产生共情的生理机制，而在后续的章节中我们也会看到如何利用它帮助交流。\n第二部分，书中从第一部分的生理机制出发，讲述了构建沟通的九大核心原则，包括：\n\n保持镇定\n破处刻板影响\n让对方觉得“你懂我”\n对对方感兴趣，而不是表现自我\n让对方觉得自己有价值\n帮助他人舒缓情绪，释放压力\n消除错位沟通\n主动示弱\n远离五种“有毒”的人\n\n第三部分，从第二部分继续拓展，总结了建立沟通的12种快速方法。\n最后一部分，进入实战环节，将前面部分的技巧与原则相融合，给出了七种棘手场景的应对办法，如果相似的场景可以参考原书，这七种场景为：\n\n如何搞定噩梦般的队友\n如何顺利升迁\n如何对付自恋狂\n如何拓展人脉\n如何对付情绪失控的人\n如何与自我对话\n如何结识大人物\n\nFootnotes\n\n\nbook.douban.com/subject/36084651/ ↩\n\n\n"},"2025/分布式-CAP-理论":{"slug":"2025/分布式-CAP-理论","filePath":"2025/分布式 CAP 理论.md","title":"分布式 CAP 理论","links":[],"tags":["ComputerScience/DistributedSystem"],"content":"CAP 原则是分布式系统设计中的一个核心理论，由 Eric Brewer 提出，指出在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三个特性无法同时满足，最多只能实现其中的两个。\nCAP 原则的三个要素：\n\n一致性（Consistency）：\n\n所有节点在同一时间看到的数据是相同的。\n系统在执行写操作后，任何后续的读操作都能获得最新的数据。\n\n\n可用性（Availability）：\n\n每个请求都能得到响应，无论成功或失败。\n系统在部分节点故障时仍能正常处理请求。\n\n\n分区容错性（Partition tolerance）：\n\n系统在网络分区（节点间通信中断）的情况下仍能继续运行。\n分布式系统必须具备分区容错性，因为网络分区难以避免。\n\n\n\nCAP 的权衡：\n\nCA（一致性和可用性）：\n\n放弃分区容错性，适合单点系统或网络绝对可靠的场景，但分布式系统通常无法保证网络绝对可靠。传统小型企业使用的内部数据库就是如此。\n\n\nCP（一致性和分区容错性）：\n\n放弃可用性，确保数据一致性，适合对一致性要求高的场景，如金融系统。在网络分区时，系统可能拒绝请求。\n\n\nAP（可用性和分区容错性）：\n\n放弃强一致性，保证高可用性，适合对一致性要求不高的场景，如社交网络。系统在网络分区时仍能响应，但数据可能不一致。\n\n\n"},"2025/增广贤文":{"slug":"2025/增广贤文","filePath":"2025/增广贤文.md","title":"增广贤文","links":[],"tags":["书/划线笔记"],"content":"贫居闹市无人问，富在深山有远亲。\n谁人背后无人说，哪个人前不说人。\n有钱道真语，无钱语不真。\n不信且看筵中酒，杯杯先敬有钱人。\n来说是非者，便是是非人。\n远水难救近火，远亲不如近邻。\n有茶有酒多兄弟，急难何曾见一人。\n人情似纸张张薄，世事如棋局局新。\n力微休负重，言轻莫劝人。\n无钱休入众，遭难莫寻亲。\n若要断酒法，醒眼看醉人。\n求人须求大丈夫，济人须济急时无。\n渴时一滴如甘露，醉后添杯不如无。\n久住令人贱，频来亲也疏。\n酒中不语真君子，财上分明大丈夫。\n积金千两，不如明辨经书。\n养子不教如养驴，养女不教如养猪。\n有田不耕仓禀虚，有书不读子孙愚。\n水太清则无鱼，人至察则无徒。\n是非终有日，不听自然无。\n宁可正而不足，不可邪而有余。\n宁可信其有，不可信其无。\n竹篱茅舍风光好，道院僧堂终不如。\n命里有时终须有，命里无时莫强求。\n结交须胜己，似我不如无。\n但看三五日，相见不如初。\n人情似水分高下，世事如云任卷舒。\n磨刀恨不利，刀利伤人指。\n求财恨不得，财多害自己。\n知足常足，终身不辱。\n知止常止，终身不耻。\n宁向直中取，不可曲中求。\n人无远虑，必有近忧。\n成事莫说，覆水难收。\n是非只为多开口，烦恼皆因强出头。\n人生一世，草生一春。\n黑发不知勤学早，看看又是白头翁。\n月到十五光明少，人到中年万事休。\n儿孙自有儿孙福，莫为儿孙做牛马。\n人生不满百，常怀千岁忧。\n今朝有酒今朝醉，明日愁来明日忧。\n路逢险处难回避，事到头来不自有。\n药能医假病，酒不解真愁。\n入门休问荣枯事，观看容颜便得知。\n好言难得，恶语易施。\n一言既出，驷马难追。\n道吾好者是吾贼，道吾恶者是吾师。\n见官莫向前，做客莫在后。\n枯木逢春犹再发，人无两度再少年。\n无求到处人情好，不饮从他酒价高。\n用心计较般般错，退步思量事事难。\n从俭入奢易，从奢入俭难。\n路不行不到，事不为不成。\n人不劝不善，钟不打不鸣。\n人老心未老，人穷志莫穷。\n世事如明镜，前程暗如漆。"},"2025/建立沟通的12种快速方法":{"slug":"2025/建立沟通的12种快速方法","filePath":"2025/建立沟通的12种快速方法.md","title":"建立沟通的12种快速方法","links":["2025/构建沟通的九大核心原则"],"tags":["心理学","技能/沟通方法"],"content":"从不可能变为可能\n解决问题的前提是需要相信问题可以解决，如果沟通中遇到对方认为无法解决的困难，这种内心的预设立场可以封住他进行积极思考的可能性，那可以引导对方说出自己认为不可能的事，当对方在说出不可能的事同时就会转向积极思考，当发现他的思想开始从“绝对不可能”变成了“有可能，不过”时要给予肯定，这样有利于推动事情的解决。\n魔术悖论\n需要和处于消极情绪中的人进行沟通时，好的办法不是上来说教，而是说出他消极的原因让他感到你懂他，这是让对方感觉到“你懂我”的运用，说出对方消极的原因并表达出你理解他为何消极时，可以让处在压力之下的对方获得喘息的机会，也会增加他对你的信任，同时对方在使用“是”来回复你他确实处于某种状态时，他就会从不同意的态度开始向同意的态度转变。\n移情沟通法\n引导针锋相对的双方放下愤怒的情绪，让他们各自站在对方的角度去沟通，做为第三方在这一过程中不要去表达对任何一方的观点的反对，首要的目的是利用双方的同理心放下情绪，再用理智去交流。\n同样在与人沟通时，可以推己及人，通过问题引导对方站在自己的立场思考。另一方面，也要推己及己，当自己气血上涌，也站在对方的角度看看。\n逆向游戏：转换立场\n与对自己不满的人沟通，在对方以为又将和你争锋相对时，反其道而行之，自己先承认自己的错误，并向对方道歉，为自己的行为负责，并承诺未来也会主动纠正自己的错误，这样对方会从防御模式切换，投射你的谦卑和关心。而如果只是放任问题，或希望对方道歉、改过自新，那问题不会消失，而是变本加厉，对方也可能暗中与你做对。\n“你真的这样认为吗？”\n面对对方夸大其词的指责，可以使用“你真的这样认为吗？”，让对方重新思考是不是自己放大了自己的情绪，但如果对方坚持，那让对方说明细节，可以解决重大问题。\n“嗯”的力量\n面对来势汹汹充满火药味的对方，当对方还在输出情绪时，一句“嗯”可以让对方稍微停顿，当对方疑惑时，你要表达出：“你很重要，你的问题也很重要，我在听”信息，这样能让对方卸下防备，一起处理问题，而不是相互伤害。\n关键不是只说“嗯”就完了，也要同时表达出“我在仔细的听，请你继续”的意思\n先自揭短处\n比起大费周章隐藏自己的缺点，不如在交流最开始就主动承认并请求对方的原谅，如果对方选择继续交流，那缺点就不会是你们交流的障碍，但如果故意隐瞒，对方或许早以知悉或很快发现，这时他可能会选择停止交流，或者在交流的时候可以的避开问题，这会让对方很不舒服，无法和你建立情感的联系，而且你隐瞒的行为还会让对方觉得你或许还有更多他没有发现的问题。\n这种策略可以称为事前约定，就像在法庭上双方律师都会接受对方提出的证物已经经过了检验，无须再找专家进行检测。\n这个方法有三个关键点：开场（快速而有效地描述问题）、消除问题（解释问题的处理方法，或者为什么它不算什么问题）、转场（转移到下一个话题，不要逗留或讨论更多细节）。\n从交易到交流\n现在生活中，我们很多的交谈只是为了交易，而很少共情。每个人都在问“你会为我做什么？”以及“作为回报，我能为你做什么？”。这种交易式的沟通无法打开交流人的心扉，流于表面，不能加深两人的感情，为了使生活有波澜，你需要超越交易，引发共情。办法是通过提问让对方需要抬头思考，让他告诉你“这就是我的想法”，“这就是我”，“这就是我的目标”，或者“这样你就可以让我的生活更美好“。比如，在面试时问面试官“想象一年以后，你和老板在评估今年聘用的人，谈到这个职位时，他们会说：‘再给我找 10 个这样的员工。我们很久没遇到这么好的员工了。‘ 你能告诉我那个人为了公司做了什么才能得到如此热烈的好评吗？”\n肩并肩沟通\n使用方法：邀请对方一起参加一项活动（最好是在活动中对方会为你提供帮助），在活动中向对方提问，问题应该指向对方在做什么、思考什么、感觉如何\n整个过程中要注意，尊重他们的答案，如果对方的注意不错，就要采取行动，即使答案很离谱，也要用“值得考虑”这样的答案给予肯定的回复。\n记住尝试肩并肩的沟通是因为面对面的沟通会让对方对你有所防备，而使用肩并肩的沟通可以让对方放松警惕，所以不要用这种方法去套话或者寻找负面信息，即使和你的观点不同，也不要去辩解，而是通过问题来加深对话。\n填空法\n比起直接提出让对方戒备的问题，试着用留白的方法邀请对方进行对话。因为直接了当的问让人戒备问题会让人觉得你在刁难对方，让他们填补空白，他们才会觉得你在和他们平等的交流。\n直到对方说“不”\n得寸进尺，直到收到“不”的回复。特别是在生意场上，对方的“不”并不是明确的拒绝，而是还有回旋的余地，你可以退一步再次协商，并且你也明确了对方的底线在哪里。\n重量级感谢和道歉\n如果你非常感激对方的帮助，那就不要简单的说一句“谢谢”，而是应该用重量级的感谢来表达你的情感。如果不知道什么是一个重量级的感谢，可以参看以下这种表达方式，主要包含三个步骤：\n\n第一步，具体感谢对方为你做了哪些事\n第二步，感谢对方为帮助你所做的努力\n第三步，告诉对方他的帮助给你带来的不同\n\n同样，如果做了十分伤害对方的事情，也不能只是简单的说句“对不起”，而应该做一个诚恳的道歉，道歉中包含“4 个 R”：\n\n认错（Remorse）：向他人证明你知道自己造成了伤害，并且你对此真的很抱歉。\n补偿（Restitution）：想办法弥补，至少弥补部分后果。\n改过（Rehabilitation）：用行动证明你已经汲取了教训。\n请求原谅（Requesting Forgiveness）：不要马上请求原谅，而是在用行动证明你汲取教训之后，再时间去请求他的原谅。\n"},"2025/杏仁核劫持":{"slug":"2025/杏仁核劫持","filePath":"2025/杏仁核劫持.md","title":"杏仁核劫持","links":[],"tags":["心理学","技能/沟通方法"],"content":"杏仁核是人脑深处的一个小小区域，当察觉到威胁或挑衅时，它会迅速的采取行动。虽然大脑中掌管逻辑的额叶皮层也会处于警戒状态，但高级中枢需要更多时间来分析威胁再采取行动，而杏仁核用指挥的权力，可以把冲动引导至额叶皮层，也可以让其从额叶皮层转移。当人处于非常恐惧的时，杏仁核会立马关闭高级中枢，以最原始的本能去面对威胁，这时候人便处于 杏仁核劫持1 的状态。但并不是只要一受到威胁恐惧杏仁核就会关闭大脑，在选择关闭高级中枢之前，杏仁核也会评估状态，在这段时间还有停顿的余地，但一旦进入劫持的状态，就无法停止了。\nFootnotes\n\n\n《倾听的力量》第二章 ↩\n\n\n"},"2025/构建沟通的九大核心原则":{"slug":"2025/构建沟通的九大核心原则","filePath":"2025/构建沟通的九大核心原则.md","title":"构建沟通的九大核心原则","links":["2025/三脑理论","2025/杏仁核劫持","2025/镜像神经元"],"tags":["心理学","技能/沟通方法"],"content":"保持镇定\n有效沟通的前提是两人都在使用自己的逻辑脑来交流，所以第一原则是让自己首先处于镇定的状态，而不是被自己的杏仁核劫持或处于情绪激动的状态。那如何能够快速的控制住自己的情绪啦？我们锻炼自己应该遵循如下的心路历程：\n\n反应期（“哦，见鬼”）：不要否认自己的沮丧和害怕，如果可以大声说出来，呼气的动作可以帮助自己冷静。可以离开座位或闭上眼睛，集中精力承认自己的愤怒或恐惧并摆脱情绪的束缚。\n释放期（“天啦”）：承认自己的情绪后，深呼吸，放松下来。\n重新定位期（“拜托”）：继续深呼吸，走出自己的防御状态。\n重新聚焦期（“那就这样吧”）：思考自己能做什么，减少伤害控制情况。\n重新投入期（“行，没问题”）：做需要做的事情。\n\n整个过程中关键是要明白自己处于哪一个阶段并做出理智的判断，不要否认自己的情绪，而需要快速的释放出来，重新冷静做下一步的打算。\n破处刻板印象\n我们的大脑会依据过去听到过或了解到的关于某人的一切，在见到他时会立刻做出评价，即使是见到陌生人，我们也会根据各种过滤器：性别，年龄，国籍，教育水平，性格等快速的生成一个刻板印象，这时我们沟通的对象其实是我们自己创造的虚构印象，而非真人，并且这种印象不会在第一次交流之后消失，相反我们可能根据这刻板印象去歪曲我们听到的一切，让他看起来更像我们自己捏出来的那个人。\n有效的沟通需要我们意识到这种刻板印象的存在，面对交流人身上表现出的缺点，仔细思考其背后的原因，从而建立一个更准确的认识，以更好的交流。\n让对方感觉到“你懂我”\n简单来说就是设身处地的为他人着想，由于镜像神经元的存在，当你感知到对方的感受，那么对方也会对你感同身受。表达出“我懂你”，对方会自发的表达出感激之情，渴望理解你的想法。这是一种无法抗拒的生理冲动，会把对方拉向自己。\n你可以使用下面的步骤来让对方感觉被理解：\n\n判断对方的情绪，比如沮丧、生气或担心。\n然后说：“我正在试着理解你的感受，我认为你是（某种情绪）。我说对了吗？如果不是，那你的感受是什么？”等待对方的反应，看他认同还是纠正你。\n接着说：“你有多（某种情绪）？” 给他一点时间反应。并做好准备迎接对方情绪的爆发，不要回击和表达不满。\n随即说：“你如此（某种情绪）的原因是不是。。。” 让对方发泄出来。\n继续说：“告诉我，要做什么你才会觉得好受一点？”\n最后说：“我能帮上什么忙吗？你自己又能做些什么呢？”\n\n每个人都是真实的个体，都会害怕、会紧张，需要别人的理解。如果你忽略对方的感受，你只会不断的碰壁，感受到怒气、敌意或冷漠。而如果让对方感觉“被理解”，你们更容易从陌生人，甚至敌人转变为朋友或盟友。\n对别人感兴趣，而不是显摆自己有趣\n比起关注自己留给他人的印象，更注重倾听他人，是真正赢得朋友和影响他人的最好方法。因为你越对他人感兴趣，就越能弥补他的镜像神经元受体缺陷，对方就会对你越感恩，越容易产生共鸣。\n但要注意不要装作感兴趣，而是要付出行动，一个小技巧是把对话当成侦探游戏，你的目标就是尽可能地了解对面那个人。告诉自己，和你交流的人身上有些非常有趣的故事，你要去挖掘它。这样你的期待就会自然的从你的眼神和肢体语言中流露出来。\n和新朋友聊天是，可以使用 F(Feel)T(Think)D(Do) 交流来问问题，引导他们回答：“我觉得，我认为，我做过或可能会做。”\n衡量自信的标准，是看你对他人的兴趣有多深、多真诚，而衡量不自信的标准，在于你有多努力要给他人留下印象。\n让人们觉得自己有价值\n我们需要感觉到自己的价值，而且仅仅自己知道自己有价值远远不够，我们需要看到自己的价值得到周围人们的认可。如果你让对方感觉自己举足轻重，相当于赠给对方一份无价之宝。这不限于你所看重的人，对有些想法设法让你的生活中讨厌他的人让他们知道自己很有价值也有奇效，因为他们很多只是得不到别人的认同，患有严重的镜像神经元受体缺陷，所以想法设法的刷存在感。告诉他们你认为他们很重要，让他们帮助你可以拉近你们之间的距离。\n帮助他人抒发情绪，舒缓压力\n试图和压力下处于困境的人进行交流时，首先要做的是让他们摆脱痛苦，让他们的大脑进入能够倾听的状态。\n面对表情愤怒，肩膀僵硬，双臂交叉，痛苦万分的人，不要想着讲事实摆道理，而是要引导他释放压力，张开双臂。\n消除错位沟通\n如果你认为自己留下的印象与人们对你的看法截然不同，那就会出现不协调。而不协调会阻止你和对方的交流。\n茫然无助时，请主动示弱\n诚实的承认自己的错误，而不是试图掩盖，别人会原谅你，甚至试着帮你。承认自己的脆弱是一种力量，它可以使你避免杏仁核劫持，进而避免仓促做出决定，或是做出极其糟糕的选择。\n远离五种“有毒”的人\n五种有毒的人：\n\n精神穷人，拒绝自己做决定或解决问题，他们希望你话时间手把手帮助他们解决生活中所有的问题。\n地头蛇，在工作中总是试图欺负你的人，最好的办法是强硬回应，他碰钉子之后就会自己离开去找其他容易被欺负的人。\n索取者，只会找你帮忙却不回报的人，每次他来索取时都提出等价交换的条件。\n自恋者，只在乎自己，而不会去理解周围的人。\n精神病患者，不要以为自己能改变生病的人，医生都不行凭什么你行？\n\n远离“有毒”人的同时，也要反思是不是自己也存在同样的问题。"},"2025/说服周期":{"slug":"2025/说服周期","filePath":"2025/说服周期.md","title":"说服周期","links":[],"tags":["心理学","技能/沟通方法"],"content":"说服周期1 是成功说服人所需要经过的几个步骤，主要用被说服人的心理变化来划分，分为以下几个阶段：\n\n拒绝去做\n愿意倾听\n考虑你说的话\n愿意去做\n付诸实践\n感到愉快\n继续去做\n\n为了完成整个说服周期，我们需要用打动人的方式进行交谈：\n\n从抗拒到倾听\n从倾听到思考\n从思考到有意愿\n从有意愿到行动\n从乐意行动到持之以恒\n\n成功的说服的关键不在与你告诉了对方什么，而是你让对方在说服周期中告诉了你什么，以及整个过程中他们脑海中的所思所想。\nFootnotes\n\n\n《倾听的力量》第一章 ↩\n\n\n"},"2025/镜像神经元":{"slug":"2025/镜像神经元","filePath":"2025/镜像神经元.md","title":"镜像神经元","links":[],"tags":["心理学","技能/沟通方法"],"content":"镜像神经元是人类共情的基础，他把我们的感受传送到另一个人的脑海里。比如看到同事的手被纸划伤你也会感觉到疼，看到电影中英雄救出小女孩，你也会欢呼，就像那一瞬间事情好像就发生在你自己的身上，这就是你脑中的镜像神经元被激活的原因。\n在生活中我们会不断的把世界当成一面镜子，满足它的需求，希望获得它的爱和支持，而如果付出之后没有获得相应的回复，就会产生一种缺失感，如果这种缺失感得不到满足，我们就可能患上“镜像神经元受体缺陷”。而当今现实世界中每一天我们都会和很多“镜像神经元受体缺陷”的患者，很多人尽力付出却只能日复一日的得到冷漠、敌意或者更本没有回应。所以如果能在沟通中理解别人的需求，并做出回应，将是一个非常有力的沟通工具，可以帮助我们更好的沟通，哪怕可能你并不认同他的感受。"},"2025/领域驱动设计":{"slug":"2025/领域驱动设计","filePath":"2025/领域驱动设计.md","title":"领域驱动设计","links":[],"tags":["ComputerScience/SystemDesign"],"content":"领域驱动设计（Domain-Driven Design, DDD） 简单来讲就是同过业务逻辑的边界来划分模块，通过定义领域事件和明确的交互方式实现模块之间的低耦合协作。\nDDD 的核心概念\n\n\n领域（Domain）\n指业务问题的范围，即软件要解决的实际问题所处的领域（如电商、金融、物流等）。DDD 强调开发者需要深入理解业务，而非仅关注技术实现。\n\n\n通用语言（Ubiquitous Language）\n开发团队与业务专家共同定义一套统一的术语和概念，确保代码、文档、沟通中使用相同的语言，减少歧义。\n\n\n限界上下文（Bounded Context）\n将大系统划分为明确的边界，每个边界内使用独立的通用语言和模型。例如，电商系统中“订单”在支付上下文和物流上下文中可能含义不同。\n\n\n领域模型（Domain Model）\n在限界上下文内，通过对象（实体、值对象等）和规则抽象业务逻辑，模型是代码的直接反映。\n\n\n分层架构（Layered Architecture）\n通常分为：\n\n用户界面层（展示逻辑）\n应用层（协调用例，不包含业务规则）\n领域层（核心业务逻辑）\n基础设施层（技术实现，如数据库、外部服务）\n\n\n\n战术设计模式\n\n实体（Entity）：具有唯一标识的对象（如用户 ID）。\n值对象（Value Object）：通过属性定义的无标识对象（如货币金额）。\n聚合根（Aggregate Root）：一组相关对象的入口，保证一致性。\n领域服务（Domain Service）：处理无状态业务逻辑。\n仓储（Repository）：封装数据持久化逻辑。\n领域事件（Domain Event）：记录业务状态变化。\n\n\n\n需要注意的陷阱：\n\n事件泛滥：过度事件化可能导致系统难以跟踪（需配合事件溯源或 Saga 模式）。\n业务边界模糊：不合理的限界上下文划分会带来事件循环依赖（如订单和库存互相监听事件）。\n最终一致性：事件异步处理可能带来短暂状态不一致（需业务容忍）。\n"},"2025/高并发数据库优化设计":{"slug":"2025/高并发数据库优化设计","filePath":"2025/高并发数据库优化设计.md","title":"高并发数据库优化设计","links":[],"tags":["ComputerScience/Database","ComputerScience/SystemDesign"],"content":"反范式设计\n将一些冗余字段存在多个表中，这样在查询时可以避免关联多个表，以提高查询的性能。\n在更新时，如果需要一个表先查出一个 ID 再去更新另一张表，这样更新的事务会变大，而冗余一些更新条件的字段在表中，就可以进行单表更新。但如果更新这个条件字段是个高频操作，更新时需要同时更新两张表，那就需要仔细权衡。\n不要设置外键\n对有外键的数据进行更新，本身需要做额外的检查，也有可能需要加锁，这对于更新的性能是有影响的。所以不在数据库中设置外键，而是在业务层面去保证外键的逻辑。\n增加字段的扩展性\n对于业务上可能会增加删除字段的的情况，很难在一开始就能定义到所有需要的字段，所以可以考虑使用字符串或 JSON 数据类型来增加表的扩展性。对于一些需要索引的字段，则将其单独例出来，或者使用数据库本身的 JSON 方法。\n数据的冷热分离\n垂直分表，对于有些字段，其有些属性更新频繁，而有些数据更新较少并且数据较大，这样这字段的属性就不适合放在一个表中，而是可以将高频的数据存一张表，低频的数据存另外一张表，可以提高增删改查的性能。\n建数据库集群时考虑事务\n如果开始的时候只是按照同一块业务去建一个数据库，后期如果遇到多个业务需要在一个事务中完成，那就会涉及分布式事物的处理，而如果前期在数据库设计是就考虑到了这个问题，尽量的把可会放在一个事务中的数据放在同一个数据库中，那就能避免后期的分布式事务问题。比如同一用户的数据尽量放入同一数据库中。\n尽量单表操作\n单表操作和联表查询在性能上可能需要具体问题具体分析，但在业务逻辑高速发展时单表的处理简单，当数据量上来之后的分库分表也比有多个表要方便。如果预料到数据需要分表分库，那在初期设计时就要考虑使用分布式 ID，而不应该使用自增 ID。"},"Blogs/Emacs-中英文的对齐设置":{"slug":"Blogs/Emacs-中英文的对齐设置","filePath":"Blogs/Emacs 中英文的对齐设置.md","title":"Emacs 中英文的对齐设置","links":[],"tags":["Software/Editor/Emacs","Programming/Fonts"],"content":"emacs 中的中英文对齐对于稍微有点强迫症的人来说算是个可以折腾的人直挠头的问题了，特别是当你使用 org-mode ，并且在文章中添加表格的时候。在不做任何设置的情况下，默认的结果可能是这样的：\n\n在网上搜索一番之后，会找到一个 cnfonts 的解决方案，思路是为中文和英文字体分别设置不同大小，经过一番调整，得到结果是这样的：\n\n但这个方案其实还是有些个问题：\n\n\n对齐的设置是按照宽度来设置的，这就导致了有些英文字体小，但对应的中文字体太大，宽度虽然对上了，高度却差了很多，照成上图中的中英文行距明显大于英文之间的行距。\n\n\n不能够放大缩小，我用的 emacs-mac 的 fork，可以使用 trackpad 的手势对字体进行缩放，但是 cnfonts 调整过后的中英文放到缩小的比例是不同的，导致不仅对不齐，而且中英字体的字号差距太大，没法看。\n\n\n在有些主题中，buffer 的字体设置有些不同，和设置字体的设置可能有冲突，有可能会导致一些字体突然变得特别大，我就遇到过在某一个主题中 org-agenda 的英文字体突然大到夸张的情况。\n\n\n除了这三点，其实还有一点是我选择直接拷贝 cnfonts 生成的 elisp 到 custom.el 来设置字体， cnfonts 生成的默认字体大小对于有些字体来说太小了，加大一号又太大了，中间的大小又没有对齐。所以在使用了一段时间之后我决定再想想办法。\n其他方案\n在放弃了 cnfonts 的解决方案之后，我想到的最后的解决方案是找到一对严格或者近似符合 2:1 的中英文字体，这样不管在放大或缩小的情况下，两个字体都能配合的比较完美，不会出现忽大忽小的问题。最终我找到的是 Ubuntu Mono 配合 Sarasa Mono SC，以及 Iosevka 配合 Sarasa Mono SC 。其中来说 Iosevka 搭配 Sarasa Mono SC 比较完美，因为是同一人之手。而 Ubuntu Mono 会稍微有一点点差距，在 size &lt; 15 的时候都是能完美对齐，另外高度会有一点点差距。可以通过使用下面的方法来进行设置。\n(let ((default-font (font-spec :name &quot;Iosevka&quot; :size 15))\n      (cn-font (font-spec :name &quot;Sarasa Mono SC&quot;)))\n  (set-face-attribute &#039;default nil :font default-font)\n  (dolist (charset &#039;(kana han symbol cjk-misc bopomofo))\n    (set-fontset-font t charset cn-font)))\n\n更进一步\n进行到上一步的时候其实已经差不多了，除了，对于有些喜新厌旧的人来说某一个字体看久就会老想着换到别的字体，那怎么办？在搜索方案的过程中我看到了 emacs 的一个叫做 face-font-rescale-alist 的变量，查看变量和帮助文档，可以看到如下描述：\nThis variable specifies scaling for certain faces. Its value should be a list of elements of the form\n \n(fontname-regexp . scale-factor)\n \nIf fontname-regexp matches the font name that is about to be used, this says to choose a larger similar font according to the factor scale-factor. You would use this feature to normalize the font size if certain fonts are bigger or smaller than their nominal heights and widths would suggest.\n所以我们可以将中英文字体的大小设置为相同，然后通过这边变量来单独的放大或缩小英文字体的显示，以便和英文字体对齐。于是结合上面的设置我将新的设置方案写成了一个函数方便快速的调整我想要的字体。\n(defun max/set-font (FONT-NAME CN-FONT-NAME &amp;optional INITIAL-SIZE CN-FONT-RESCALE-RATIO)\n  &quot;Set different font-family for Latin and Chinese charactors.&quot;\n  (let* ((size (or INITIAL-SIZE 14))\n\t (ratio (or CN-FONT-RESCALE-RATIO 0.0))\n\t (main (font-spec :name FONT-NAME :size size))\n\t (cn (font-spec :name CN-FONT-NAME)))\n    (set-face-attribute &#039;default nil :font main)\n    (dolist (charset &#039;(kana han symbol cjk-misc bopomofo))\n      (set-fontset-font t charset cn))\n    (setq face-font-rescale-alist (if (/= ratio 0.0) `((,CN-FONT-NAME . ,ratio)) nil))))\n这样我就能通过如下的办法来设置我想要的字体，并且通过一个参数来调整中文的对齐了。\n(max/set-font &quot;JetBrains Mono&quot; &quot;Hiragino Sans GB&quot; 13 1.25)\n(max/set-font &quot;Fira Code&quot; &quot;Hiragino Sans GB&quot; 13 1.25)\n(max/set-font &quot;Monaco&quot; &quot;Sarasa Mono SC&quot; 13 1.25)\n(max/set-font &quot;Fira Code&quot; &quot;Source Han Serif SC&quot; 13 1.3)\n部分的效果如下，总体来说 Sarasa Mono SC 的效果会比其他的中文字体好一些，其他的中文字体应该自身并不是 monospace，所有只有在特定的 size 下才会对齐，就当作是中调剂吧。\n\n\n\n相关的一些链接\n\nSarasa Gothicc\nIovseka\nUbuntu Mono\nEmacs cnfonts\nemacs-china上关于等宽字体的讨论\n"},"Blogs/Moral-Lessons-from-GNU-Emacs---Protesilaos":{"slug":"Blogs/Moral-Lessons-from-GNU-Emacs---Protesilaos","filePath":"Blogs/Moral Lessons from GNU Emacs - Protesilaos.md","title":"Moral Lessons from GNU Emacs - Protesilaos","links":["Emacs"],"tags":["Software/Editor/Emacs","Philosophy"],"content":"Protesilaos 是 Emacs 社区近几年比较活跃的贡献者，开发了好几个比较出名的包，比如高质量的主题 Modus Theme，在 Emacs 28 之后已经被打包进入了 Emacs 中，可以直接使用。还有新的 EF Theme，看着也不错，但因为我自己没有用 Emacs 了，所以没有尝试过。\n他包开发的思路也和近几年 Emacs 社区的趋势十分契合，充分的发掘 Emacs 本身内部的潜力，尽量依托 Emacs 本身的内置功能，构建起功能单一高效的插件，每个插件通过所依托的 Emacs 本身的功能相互配合达到更强的功能，而不是重新造轮子，产生一套和 Emacs 内置功能冲突的有自己独立一套 API 的臃肿插件。\n其个人的经历也很有意思，并非计算机科班出身，希腊人，学的是哲学，以前在希腊的世界银行工作，疫情之后失业才开始使用和学习 Emacs ，为 Emacs 开发插件，现在在希腊山上一边种地一边在网上分享自己的哲学心得，一边维护自己的 Emacs 项目。\n\n\n                  \n                  题外话 \n                  \n                \n\nEmacs 社区有些背景很神奇的贡献者，比如 Emacs 内置 LSP 插件 Eglot 的贡献者 João Távora ，这人是个葡萄牙学画画的。\n\n\n以下的几段话是摘自 Protesilaos 2021 年的演讲 Moral Lessons from GNU Emacs，我觉得说的挺对，就记下来了。\n\n\n                  \n                  Quote\n                  \n                \n\nThis is no magical way to boost your productivity by changing the software you use, while keeping your mindset constant.\n如果不改变你使用工具的思路，就算是不断的更换使用的工具也没办法神奇的提高你自身的效率。\n\n\n\n\n                  \n                  Quote\n                  \n                \n\nAutonomy comes at a cost. It presupposes responsibility, and this predicated on discipline. If you do not want to be responsible, if you prefer to be spoon-fed what life has to offer, then you remain in a state of heteronomy with its fake comforts.\n自主是有代价的。自主意味着责任，而责任又以纪律为前提。如果你不想负责任，如果你喜欢别人喂你生活提供的一切，那么你就会处于一种他律状态，享受虚假的舒适。\n\n\n\n\n                  \n                  Quote\n                  \n                \n\nWhat made me change habits was the realization that there is no “cheat code” or “secret lift hack” to gaining expertise in any given field. You have to earn it. And this means you have to put some serous effort into it.\n当我意识到，在任何领域，没有“秘诀”或“秘密技巧”可以让你获得专业知识时，我才开始改变我的习惯。你必须努力工作才能有收获，这里的努力工作指的是你必须付出一些真正的实际的努力，而不是看上去像是在努力。\n\n\n\n\n                  \n                  Quote\n                  \n                \n\nTake your time. Read, read, read! And proceed slowly from the basics to the more advanced issues.\n花时间耐心的去阅读，阅读，再阅读！耐心的吸收和消化基础的技能，再去尝试更高阶的技巧。\n\n\n一句话总结，脚踏实地，夯实基础，实事求是的努力，而不是寄希望于一些外在的所谓提供效率的工具，不求外物，反求诸己。"},"Blogs/UTXO的委托代理问题":{"slug":"Blogs/UTXO的委托代理问题","filePath":"Blogs/UTXO的委托代理问题.md","title":"UTXO的委托代理问题","links":[],"tags":["政治经济/货币","ComputerScience/Bitcoin"],"content":"经济学中委托代理问题指的是由于代理人的利益与目标与委托人的利益与目标不一致，加上存在不确定性和信息不对称，在缺乏有效监督和措施时，代理人更倾向与损害委托人的利益以牟取自己利益的现象。\nUTXO 作为支付工具的委托代理问题\n软分叉与硬分叉\n软分叉为向前与向后兼容，硬分叉为只向后兼容（升级过的节点可以验证未升级节点产生的块）。软件的 Bug 和版本升级都可能带来分叉。\n开发者、矿池和代币投资者之间的信托关系及委托代理问题\n开发者提供分叉的技术方案并负责技术实施，矿池有权拒绝和接受升级后生产的区块，拥有投票权。开发者和矿工相当于企业的普通合伙人（General Partner）， 拥有充分的管理和控制权，代币持有者相当于普通合伙人（Limited Partner），拥有受益权。代币持有人和开发者与矿工存在委托代理关系，如果信息不对称，容易引发代理委托问题，开发者与矿工可能处于自己的私利，改变共识机制，从\n而损害代币持有者的利益。\n例子，比特币扩容问题，看似是开发者于矿工的技术理念不同，实则是各自利益出发点的不同。支持扩大区块的矿工，是为希望更多人使用链上的比特币交易，由此赚钱更多的交易手续费，而开发者支持闪电网络，则是开发者中有人就职于研发闪电网络的公司，可以赚取专利费，但闪电网络将大量小额交易隔离到链下，损害了矿工的利益。\n另外，分叉发行 IFO 相当于变相的通货膨胀，摊薄了代币持有者的权益。\nUTXO 作为加密权益的委托代理问题\n投资者与 ICO 发起人\n投资人与 ICO 发起人之间是一种基于委托代理的长期契约，投资者购买初始代币，投资发起人，发起人开发区块链项目，不承诺保障代币的未来价值。虽然发起人在 ICO 时会披露资金的使用计划，但是 ICO 之后的资金使用无人监管，发起人也没有强制义务公开资金的具体使用。信息不对称容易引起投资人与发起人之间的委托代理问题。ICO 无需专业的审核程序，容易发生 ICO 欺诈的行为，反过来在欺诈成风的情况下，投资者行为也变的短期化，不关注项目的未来价值，追求短期收益，投机炒作。\n投资者与中心化交易所\n投资者与中心化交易所之间也存在委托代理问题。各类交易平台长期缺乏监管，处于完全自治的状态，集登记、托管、交易、结算等诸多功能于一身，既无监管约束，也没有市场监督。从风险防范角度看，合规的做法应是交易平台只做信息撮合和交易，而将登记、托管和结算交由具有市场公信力的第三方来负责。通常而言，资产托管在专业化、技术水平和成本投入等方面都有很高要求，绝非民间私营机构能够承担。作为私营的机构，现有中心化交易平台的托管体系从安全性上还远远不够，托管和结算风险高。\nUTXO 作为数字资产的委托代理问题\n数字资产以货币、证卷、实物、加密代币或者其它数字资产作为抵押而发行，映射了抵押品的价值。如果抵押物为加密代币，那么可以通过智能合约的透明可信、自动执行、强制履约等特性来保证数字资产与抵押品之间的最终兑付，但如果抵押品是现实世界的资产，就会面临价值偿付的问题。区块链的共识机制创造了链上信任，但是支持不了链下信任。数字资产发行者与持有者之间也是一种长期契约关系，在信息不对等的情况下，存在委托代理问题。\n我们通常所见的证卷或商品的电子化交易，由特定的可信机构负责证卷托管与清算，有效的保障了证卷交割的安全和效率。而 Bitcoin 等并没有足够可信的第三方机构，而且如果有的话，也和 Bitcoin 所设想的完全去中心话思想背道而驰，这里 Bitcoin 陷入了悖论当中。"},"Blogs/VIM实用技巧":{"slug":"Blogs/VIM实用技巧","filePath":"Blogs/VIM实用技巧.md","title":"VIM实用技巧","links":["Vim","Neovim","ASCII","Unicode"],"tags":["Software/Editor/Vim"],"content":"使用 Vim 进行的编辑的核心使用逻辑为执行，重复，回退。即先执行一次编辑动作，再在别的地方重复同一操作，如果不小心出错了就回退操作。可以理解为每次的编辑动作都被 Vim 自动保存为了一小段宏，再移动到另一个地方执行同一段宏，如果发现宏录错了，就快速回退，再重复这一过程，直到编辑完成。\n所以，掌握 Vim 的第一步就是理解哪些是可以重复的操作以及如何回退。\n可重复操作和对应的回退操作\nVim 中有很多操作是同一操作的两个方向，这类操作一般使用大小写来区分方向，比如 f{char} 向前到指定字符，F{char} 向后前进到指定字符。\n一些编辑操作也有特别的撤销的操作，如下表所示：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n目的操作重复回退做出一个修改{edit}.u在行内查找下一个制定字符f{char}/t{char};,在行内查找上一个制定字符F{char}/T{char};,在文档中查找下一处匹配项/pattern&lt;CR&gt;nN在文档中查找上一处匹配项?pattern&lt;CR&gt;nN执行替换:s/target/replacement&amp;u执行一系列修改qx{changes}q@xu\nUndo 命令\nNormal 模式下使用 u 可以撤销一次编辑动作。\n\n\n                  \n                  注意 \n                  \n                \n\n命令撤销的不是上一次的输入，而是一次编辑动作。\n\n\n一次编辑动作可以被以下三种情况规定：\n\n在 Normal Mode 中使用编辑动作， 比如 ., &lt;C-a&gt;, s/target/replace；\n进入 Insert Mode 到退出 Insert Mode 中间的所有操作，除了包含 3 中所述的情况；\n在 Insert Mode 中使用光标移动的操作，会立即将已有的输入保存为一次编辑动作块，包括 &lt;UP&gt;, &lt;Down&gt;, &lt;Left&gt;, &lt;Right&gt; 等，可以理解为我们回到了 Normal Mode 进行了光标的移动。\n\n\n\n                  \n                  Tips\n                  \n                \n\n使用 Redo 命令来撤销 Undo，快捷键为 &lt;Ctrl + r&gt; 。\n\n\n快速增减数字\n&lt;c-a&gt; 会正向跳到第一个数字上，并将数字 +1， &lt;c-x&gt; 会将数字 -1， 也可手动制定增减的值，如 180&lt;c-a&gt; 。但有两点需要注意：\n\n进制问题，类似 007 这种数字，会默认识别为 8 进制数\n日期增减问题，如果日期格式为 2020-10-07，当试图对月日进行增减时，会被识别为负数，其增减方向和期望的方向恰好相反\n\n以 root 权限保存文件\n:w !sudo tee % &gt; /dev/null\n\n% 符号会自动展开为当前文件路径，所以这条命令工作的原理就是通过 Vim :write 命令将文件内容通过标准输出写入到有 root 权限的 sudo tee &lt;filepath&gt;命令，这样就能成功保存了。\n\n\n                  \n                  注意 \n                  \n                \n\n这个技巧只能用于 Vim，而不适用于 Neovim，Neovim 中不支持 ! 命令中交互输入密码，所以只能使用插件或者将 tee 命令设置为不使用密码也能使用 sudo，再使用命令 :w sudo -n tee % 调用。\nSee Also: Neovim FAQ, Neovim Issue, Another Issue\n\n\n输入特殊字符\nVim/Neovim中支持使用ASCII或Unicode编码输入键盘上无法找到的字符，在输入模式下使用 Ctrl + v 快捷键就能进入编码输入的模式，这模式下有三种不同输入。\n\n直接输入 3 位数字，如 &lt;Ctrl + v&gt;065 会以十进制编码输入字符，这里会输入大写字母 “A”\n输入 u 之后可以输入 4 位数字的 Unicode 字符，如 &lt;Ctrl + v&gt;u00bf 会输入字符 ”¿”\n输入非数字键则会直接输入键入的字符，比如 &lt;Ctrl + v&gt;&lt;TAB&gt; 会输入一个 tab 符，并且不会因为在配置中设置了 tab 转空格而自动的被转化为空格\n\n如果已经在文本中存在的字符，如果想知道其字符编码，可以在 Normal Mode 将光标移动到对应字符使用快捷键 ga，屏幕下方就会显示出其对应的编码。\n另外也可以通过二合字母来插入特殊字符，使用方式是在插入模式下使用 &lt;Ctrl + k&gt;{char1}{char2} 的快捷键，比如 &lt;Ctrl + k&gt;&lt;&lt; 可以输入左书名号 ”«“，&lt;Ctrl + k&gt;12 可以输入 “½”，二合字母比起使用数字更容易记忆使用，使用 :h digraphs 了解更多信息，或者使用 :h digraph-table 查询所有可以输入的字符表。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n按键用途&lt;Ctrl+v&gt;{123}以十进制字符编码输入字符&lt;Ctrl+v&gt;u{1234}以十六进制编码输入字符&lt;Ctrl+v&gt;{nondigital}按原义插入非数字字符&lt;Ctrl+k&gt;{char1}{char2}插入二合字母表示的字符\n参考\n\n《Vim 实用技巧》\n"},"Blogs/Windows-开机端口被随机占用的原因与修复":{"slug":"Blogs/Windows-开机端口被随机占用的原因与修复","filePath":"Blogs/Windows 开机端口被随机占用的原因与修复.md","title":"Windows 开机端口被随机占用的原因与修复","links":[],"tags":["Windows"],"content":"一个奇怪的问题\n在用 Windows 的时候遇到一个特别烦躁的 bug，有些需要绑定端口的程序老是启动不了，比如 Clash，Wezterm，查询程序的启动日志，发现是无法绑定端口，程序有时会提示是端口已经被使用，所以考虑去手动把占用端口的程序关掉，但是使用  netstat -ano|findstr &quot;&lt;port&gt;&quot;  的命令去查询是哪个进程在占用，却怎么也找不到。因为 Windows 确实用的时间不多，问题出现也很随机，所以有段时间我的解决方案都是简单地换端口多试几次（有时换地端口也有问题，要多试几次）。但最近用 Wezterm 和 WSL 的次数有所增加，这个问题就越发地烦人了，基本每次启动都要试很多次，所以决定好好查查这个问题到底是怎么回事。\n问题原因\n造成这个 bug 有三个方面：\n第一，Windows 中会为一些专用的需要端口的程序设置一个专门的可分配端口的范围，叫做动态端口范围，这个范围内的端口号可以被预先申请保留，保留之后相当于被占用，别的程序无法使用。这个范围默认值是 49152-65535，这个范围实际上是没有在 IANA 注册的端口号，平时基本不会用到，可以使用命令 netsh int ipv4 show dynamicport tcp 查询当前的范围。\n第二，使用 Hyper-V 的 WSL 就是这么个程序，Hyper-V 启动之后就会在动态端口范围内随机的预先保留一些端口段，以供后续 WSL 使用。\n第三，由于某些 Windows 自身的 bug，可能是 Windows Update 的问题，导致这个动态范围的值被错误的修改，从 49152-65535 修改旧 Windows 默认的开始端口加新的端口范围，成了 1024-15001 这个比较常用的范围，这样很多程序在申请端口时会刚好撞上已经被 Hyper-V 预先保留的端口范围，导致失败，并且无法通过 netstat -ano 查找到占用的程序，因为端口只是被预留了而没有真正的在使用中。\n解决办法\n知道原因之后，修复的方法也很简单，只需要将范围重新设置为默认值，或者个人不常用的范围就好。\n首先，使用 netsh int ipv4 show dynamicport tcp 确认下当前的范围是不是错的：\nPS C:\\Users\\max&gt; netsh int ipv4 show dynamicport tcp\n \n协议 tcp 动态端口范围\n---------------------------------\n启动端口        : 1024\n端口数          : 13977\n通过 netsh int ipv4 show excludedportrange protocol=tcp 命令可以查询当前已被保留的端口范围，可以确认自己要使用的端口是不是已经预先被保留了。\nPS C:\\Users\\max&gt; netsh int ipv4 show excludedportrange protocol=tcp\n \n协议 tcp 端口排除范围\n \n开始端口    结束端口\n----------    --------\n1026        1125\n1126        1225\n1226        1325\n3262        3361\n3462        3561\n3662        3761\n5357        5357\n5628        5727\n5728        5827\n5828        5927\n5928        6027\n6228        6327\n6328        6427\n6449        6548\n6549        6648\n7018        7117\n7118        7217\n50000       50059     *\n \n* - 管理的端口排除。\n通过下面的命令重新设置 TCP 动态端口范围\nnetsh int ipv4 set dynamic tcp start=49152 num=16383\nnetsh int ipv6 set dynamic tcp start=49152 num=16383\n重新设置之后重启 winnat 服务的办法来使得新的范围生效\nnet stop winnat\nnet start winnat\n或者也可以直接重启电脑。\n参考连接\n\nWindows TCP/IP 默认动态端口范围\nINNA 服务名称和传输协议端口号注册表\n"},"Blogs/使用-orgmode-+-github-pages-搭建博客":{"slug":"Blogs/使用-orgmode-+-github-pages-搭建博客","filePath":"Blogs/使用 orgmode + github pages 搭建博客.md","title":"使用 orgmode + github pages 搭建博客","links":[],"tags":["Software/Editor/Emacs"],"content":"\n\n                  \n                  附注 \n                  \n                \n\n文章迁移自旧博客，已不再具有时效性，只是作为存档。\n\n\n上篇说到我重新搭建起自己的博客，这篇讲讲目前写文章使用的工具以及主要使用到的工具。\n等等，上篇才说到术和道的关系，咋现在又开始捣鼓起写博客的工具来了？\n这，确实，这篇确实是关于工具的文章，但是主要不是捣鼓各种工具，而是记录下这次使用到的东西和用法，算是对这项工作的总结吧。\n简单来说，目前我写文章会用到 emacs orgmode, ox-hugo, hugo, git, github pages 这几个东西，具体的流程如下：\n\n使用 orgmode 来写文章\n通过 ox-hugo 插件来将 org 文件转化为 markdown 文件\n使用 hugo 将 markdown 文件生成静态网页\n使用 git 将静态页面发布到 github pages\n\n所用到的工具们\nemacs + orgmode\n作为一个在编辑器圣战中反复横跳的人，我用过 emacs，vim，sublime，vscode，neovim。最近再使用了 neovim 作为工作开发的主力差不多一年，就在我以为它已经是我的最终归属的时候，我还是重新盼到回了初恋 emacs 的怀抱（哼，男人！）。\n原因其实很简单，neovim 很优秀，但 lisp 太美了。neovim，vscode 们像是一个干活很利索的工人，你告诉他你想做什么，他会告诉你能做还是不能做，如果能做就利索给你搞定，而 emacs 更像是个可以在你面前宽衣解带的姑娘，她不仅仅可以帮你帮事情做完，而且只要你有兴趣，就可以还不费力的窥见她做事的内部逻辑。\n所以，目前我主力写文章的工具是 emacs + orgmode， orgmode 应该是所有 emacs 用户都会使用的 mode 了，因为用处很多，可以写文章，做笔记，做日程管理等等，但我目前主要使用的功能是写文章和记笔记。\nox-hugo\nox-hugo 是 orgmode 的一个导出插件，主要功能就是在 orgmode 的导出选项中增加一个导出为 hugo 所要求的 markdown 格式的文件。可以解决使用 pandoc 转换的话要手动添加 hugo 要求的 metadata 的问题。\n我目前配置 ox-hugo 的代码如下，我使用了 use-package 来进行 emacs 的插件管理：\n(use-package ox-hugo\n  :ensure t\n  :after ox)\nhugo\n一款比较流行的 static site generator，相比 Jekyll，我其实不太在乎网页生成时间这种指标，只是使用 Jekyll 的话，需要本地安装 ruby 和一些依赖， hugo 则是直接编译好的一个二进制文件，相对来说要简洁很多。具体的用法可以参照 hugo 的quickstart。\ngithub pages\n这个没有什么说的，比起自己搭建服务器，将博客这种简单的静态网页托管在 github 上确实非常方便。但是对于国内的用户，有可能 github 的访问可能不是非常稳定，所以我选择将内容放在 github 上，而域名是通过 cloudflare 的服务来管理。这样可以通过 cloudflare 来对流量做中转，虽然免费版的 cloudflare 说不上快，但是国内访问来说，还是比直接访问 github.io 来说要稳定一些。\n文章的生成过程\n下面大概解释下文章的格式转换和发布的流程。\n构建基本目录结构 {#构建基本目录结构}\n参照 hugo 的 quickstart，建立一个自己的博客项目，其主要的目录结构如下：\npersonal_blog $ ls -alh\ntotal 8\ndrwxr-xr-x   3 qingyi  staff   96 Dec  3 20:52 archetypes/\n-rw-r--r--   1 qingyi  staff  751 Dec  3 20:28 config.toml\ndrwxr-xr-x   3 qingyi  staff   96 Dec  3 12:45 content/\ndrwxr-xr-x   2 qingyi  staff   64 Dec  3 20:52 data/\ndrwxr-xr-x   2 qingyi  staff   64 Dec  3 20:52 layouts/\ndrwxr-xr-x   6 qingyi  staff  192 Dec  6 16:44 orgs/\ndrwxr-xr-x  11 qingyi  staff  352 Aug 31  1754 public/\ndrwxr-xr-x   3 qingyi  staff   96 Dec  3 20:54 resources/\ndrwxr-xr-x   3 qingyi  staff   96 Dec  6 16:43 static/\ndrwxr-xr-x   3 qingyi  staff   96 Dec  3 20:53 themes/\n其中 config.toml 可以调整网站的各种样式于设置，可以参考 hugo 的文档修改。另外需要关注的是 orgs 目录，用来存储所有文章，我采用的是一篇文章对应一个 org 文件的方式， ox-hugo 还支持一个 org 文件中的一部分导出为一个 markdown 文件的方式，这里不多介绍了。另外一个目录是 public 目录，这个目录是 hugo 生成的静态文件的目录。这里我们通过 git submodule 命令，将 public 目录和我们 github pages 的仓库绑定：\n$ git submodule add -b main git@github.com:[GITHUB_USER]/[GITHUB_USER].github.io.git public\n这样，我们每次写完文章，利用 ox-hugo 转换为 markdown 的文章，再直接通过 hugo 命令，重新生成了 public 的目录，再通过 git 将 public 的仓库同步到 Github 就完成了文章的发布。\n撰写文章\n基本的目录结构构建好了之后，就可以开始写文章了，一般来说使用 hugo 来写文章会使用 hugo new posts/[POST_NAME] 的命令在 content/posts/ 的目录中生成文章的模版，模版中主要包括下面的 metadata：\n---\ntitle: &quot;My First Blog&quot;\ndate: 2020-12-06T17:07:57+08:00\ndraft: true\n---\nhugo 在生成静态网页的时候会使用这些 metadata 来生成 categories 和 tags 等信息，所以我们的 org 文件中也要包括这些信息，借助于 ox-hugo 提供的功能，我们可以在 org 文件中直接标注这些信息，如下：\n#+HUGO_BASE_DIR: ../\n#+HUGO_SECTION: posts\n#+HUGO_AUTO_SET_LASTMOD: t\n#+HUGO_TAGS: emacs orgmode hugo github\n#+HUGO_CATEGORIES: computer\n#+HUGO_DRAFT: false\n#+TITLE: 使用orgmode+hugo+github pages搭建博客\n这里要注意 HUGO_BASE_DIR 和 HUGO_SECTION 这两个属性，HUGO_BASE_DIR 是这个 hugo 项目的根目录，在我这个例子中为 personal_blog ，因为我的 org 文件存储在 personal_blog/orgs/ 目录中，所以设置为 ../ 。 HUGO_SECTION 这个属性指定了 ox-hugo 导出的文件在 content 目录中的子目录，这里默认的为 posts 。\n这个 org 文件使用 orgmode 的导出命令，经过 ox-hugo 转换之后，会在 personal_blog/content/posts/ 的目录中生成对应的 markdown 文件，其中的 metadata 会转换为：\n+++\ntitle = &quot;使用orgmode+hugo+github pages搭建博客&quot;\nauthor = [&quot;Qing Yi&quot;]\nlastmod = 2020-12-06T17:13:46+08:00\ntags = [&quot;emacs&quot;, &quot;orgmode&quot;, &quot;hugo&quot;, &quot;github&quot;]\ncategories = [&quot;computer&quot;]\ndraft = false\n+++\n到这一步，我们就完成了文章的撰写和转换的过程。\n文章的发布\n到这一步就非常简单了，利用 hugo 命令会将 content 的内容生成为 html，并全部放入 public 目录，我们进入 public 目录，使用 git commit 和 git push 将最新的 html 推送到 github 就完成了文章的发布。\n这一步可以通过编写 shell 来实现自动化，也可以使用 emacs 的 easy-hugo 来实现自动化。目前我还有研究 easy-hugo 的插件，所以是写了个 deploy.fish 的脚本来做发布，内容如下：\n#! /usr/local/bin/fish\n#我的shell是fish ，如果是bash, zsh可能不能运行/\n \necho &quot;generating new site&quot;\n \nhugo\n \nif test $status != 0\n   echo &quot;fail to generate new site&quot;\n   exit\nend\n \ncd public/\n \necho &quot;commit all changes&quot;\n \ngit add .\n \nset msg echo rebuilding site at (date +&#039;%Y-%m-%d %H:%M&#039;)\n \ngit commit -m &quot;$msg&quot;\n \necho &quot;push to github&quot;\n \ngit push origin main\n相关连接\n\nemacs\norgmode\nox-hugo\nhugo\nhugo quickstart\nhugo with github pages\ngithub pages\n"},"Blogs/经济学综合笔记":{"slug":"Blogs/经济学综合笔记","filePath":"Blogs/经济学综合笔记.md","title":"经济学综合笔记","links":[],"tags":["政治经济"],"content":"\n\n                  \n                  附注 \n                  \n                \n\n文章迁移自旧博客，已不再具有时效性，只是作为存档。\n\n\n为什么会有这个？\n因为一直都对经济学有点儿兴趣，作为一个 IT 行业的从业者，很多人会觉得科学技术是第一生产力，盲目的相信技术可以让世界变的更好，却很少关心除了互联网以外的世界是如何运转的。互联网的发展是一种技术进步，而技术进步确实在各种经济增长模型中都占有很大的比重，但经济增长却不止包含技术进步的部分，人口，资本在其中也扮演着自己的角色。如果我们考察中国历史，会发现经济增长社会进步的主要原因更多的时候是人口的增长与资本的积累。只是在工业时代之后，技术的进步变的更加重要。而作为 IT 行业的从业者如果只关注自身产业的发展，就显得有些管中窥豹以偏概全了。所以当人大在深圳开办在职研究生的课程时，我就机缘巧合的报名了。而这些经济学笔记就是在备考 2020 年的考试的时候根据教材和课程整理的笔记，虽然是针对 2020 年考试，有些非重点的内容有些简略，但姑且可以算作是对经济学相关知识点的整理和线索，为经济学相关内容搭了一个框架，以后可以根据笔记按图索骥补充相关的知识。\n在线的版本\n\n西方经济学\n国际经济学\n货币银行学\n社会主义经济理论\n财政学\n\n供下载的版本\n注意：因为 orgmode latex 中的一些未解决的问题，pdf 中有些公式中的中文丢失了\n\n全部笔记\n\n项目地址\n目前笔记中还有些错误没有更正，有时间会在这个仓库中更新。\ngithub.com/q3yi/economic_notes"},"Blogs/解决-org-mode-中-LaTeX-数学公式中的中文渲染问题":{"slug":"Blogs/解决-org-mode-中-LaTeX-数学公式中的中文渲染问题","filePath":"Blogs/解决 org-mode 中 LaTeX 数学公式中的中文渲染问题.md","title":"解决 org-mode 中 LaTeX 数学公式中的中文渲染问题","links":[],"tags":["Software/Editor/Emacs","ComputerScience/LaTex"],"content":"历史遗留问题\n我喜欢用 org-mode 来记笔记和写文章，而不是用 markdown 的一个原因是 org-mode 对 \\\\LaTeX 的支持更友好，可以直接使用 $\\LaTex$ 这种方式直接输入，也可以直接使用 \\begin{cases}\\end{cases} 这种方式来直接开始一段跨行的公式输入。除了输入方便， org-mode 更是支持在 emacs 中直接预览输入的数学公式，wysiwyg。但在配置之后我遇到了点小问题，在我使用 org-mode 做一些经济学笔记的时候，我遇到了这样一个公式：\n\\mbox{需求的价格弹性系数} = \\frac{\\mbox{需求的变动率}}{\\mbox{价格的变动率}}\n得到的结果是下面这样的：\n\n这是什么情况？ \\LaTeX 难道不支持中文？我又试着使用 org-export 将整个文档输出成 PDF 看看情况，好家伙，全是方框，不支持中文实锤了。经过一番查证，最后确定问题出现在 org-mode 默认使用的是 pdflatex 来生成最终文档，不支持中文的。解决方案是将默认的使用的 compiler 切换到了 xelatex ，另外添加了一些导出PDF是需要添加的 Headers，终于 PDF 可以正常导出了。但问题没有结束，PDF 中的一般中文没有问题，但是在数学公式中的中文依然像上面一样无法显示。嗯，像不像在修 bug 的你，明明在修一个 bug，却先把另外一个 bug 修好了，原来那个 bug 还在对你微笑。😂\n我又继续查了一些资料，但是 org-mode 中用 \\LaTeX，并且还有中文的人实在有点儿少，要不就是有点儿老。没有找到解决方案，我也发现将文件转换为 html，使用 LaTeX.js 来渲染并没有问题，所以这个问题就暂时搁置了下来。\n问题的解决\n因为最近在使用 brew upgrade 来升级一下系统中的各种工具的时候报了一个错，是在 brew cleanup 的过程中有些文件没有权限删除，我仔细一看，这文件不是 ghostscript 的么，是在捣腾 \\LaTeX 环境的时候通过安装 MacTex 的时候一起安装的，pkg 的安装程序默认用的用户是 root，homebrew 确实没有权限删除，于是我又想起了 org-mode 中还有 preview 无法显示中文公式的 bug，决定这一次把它们一起解决了。\n删除原来的 MacTex\n上次捣腾的时候，为了方便，我直接安装了一个完整的 MacTex，大概有 5G 左右，很多东西都用不上，而且现在和 homebrew 冲突了，所以我决定这次删掉 MacTex，然后通过 homebrew 安装一个精简的 BasicTex。MacTex 的删除不是那么容易，主要分成两个步骤：\n\n\n删除 latex 相关程序和 app，可以参考 MacTex 网站的说明，在这里 Uninstalling MacTex\n\n\n删除 ghostscript, 这个相对麻烦一点。因为要删除 ghostscript 的相关文件，首先你需要知道有哪些 ghostscript 的相关文件，于是需要重新下载一遍 MacTex 的 pkg 安装包，再从安装包中提取获取到具体安装了哪些文件。有人分享了一段 shell，但是我实际使用的时候发现已经不太一样了，这里是我修改的一个版本：\nuninstall_ghostscript () {\n    bom_usr_local=$(pkgutil --bom $1 | grep -F Ghostscript)\n    lsbom -s -f $bom_usr_local | grep -F -v ghostscript | sed &#039;s_^\\.__&#039; | while read filename; do\n\tif [[ -e $filename ]]; then\n\t    command mv - &quot;$filename&quot; ~/.Trash\n\tfi\n    done\n    command mv -v /usr/local/share/ghostscript ~/.Trash\n}\n \nuninstall_ghostscript $1\n\n\n通过 homebrew 安装 BasicTex\n在经历了上面的 MacTex 的删除过程，才能更深的体会到使用 homebrew 来管理软件的方便，直接使用 brew install baisctex ，翘着二郎腿等着结束就完成了。\n解决 org-mode preview 无法显示中文的问题\n在又经过了一番搜索和试错之后，我确定这个问题要分成两个部分解决。\n第一个问题是 latex 本身的问题， xelatex 中在公式环境中插入中文默认都是无法显示的，需要使用 \\mbox{} 来处理，所以我之前的笔记中的公式是不对的，需要在公式中出现中文的地方，都使用 \\mbox{} 来包围才能正常显示，拿文章开头的例子来说明。\n错误的输入方式为：\n$需求的价格弹性系数 = \\frac{需求的变动率}{价格的变动率}$\n正确的输入方式为：\n$\\mbox{需求的价格弹性系数} = \\frac{\\mbox{需求的变动率}}{\\mbox{价格的变动率}}$\n这一部分问题解决之后，使用 org-export 导出的PDF中的中文可以正常显示了，但是在 org-mode 中调用 org-latex-preview 函数依然无法获得正常的结果。\n接着来解决第二个问题，需要修改控制 org-latex-preview 的两个变量：\n\n\norg-preview-latex-process-alist 这个变量是一个列表，列表中每一项都定义了一种 org-latex-prewiew 的处理过程，默认的过程中使用的都是 latex 命令来生成 dvi 文件，在转化为 png 或者 svg 在 emacs 中显示。\n\n\norg-preview-latex-default-process 这个变量定义了 org-latex-preview默认使用的处理过程，需要在 org-preview-latex-process-alist 变量中定义。\n\n\norg-latex-prewiew 函数的大概处理流程为，先查询到当前buffer当前光标下公式开始与结尾，再通过 org-preview-latex-default-process 变量获取到需要使用的处理流程，再通过 org-preview-latex-process-alist 查到对应处理过程需要使用到的命令，最后把公式的插入到一个固定模板，在按照定义好的处理流程将 LaTeX 的代码转化为png或者svg显示在buffer当中。\n明白了这个流程，我们就可以通过下面的设置，新建一个处理流程来解决公式中中文无法显示的问题，具体的代码如下：\n(add-to-list &#039;org-preview-latex-process-alist &#039;(xdvsvgm :progams\n\t\t\t\t\t\t\t(&quot;xelatex&quot; &quot;dvisvgm&quot;)\n\t\t\t\t\t\t\t:discription &quot;xdv &gt; svg&quot;\n\t\t\t\t\t\t\t:message &quot;you need install the programs: xelatex and dvisvgm.&quot;\n\t\t\t\t\t\t\t:image-input-type &quot;xdv&quot;\n\t\t\t\t\t\t\t:image-output-type &quot;svg&quot;\n\t\t\t\t\t\t\t:image-size-adjust (1.7 . 1.5)\n\t\t\t\t\t\t\t:latex-compiler (&quot;xelatex -interaction nonstopmode -no-pdf -output-directory %o %f&quot;)\n\t\t\t\t\t\t\t:image-converter (&quot;dvisvgm %f -n -b min -c %S -o %O&quot;)))\n(setq org-preview-latex-default-process &#039;xdvsvgm)\n这里要注意的是 image-input-type 这个字段的值不为 dvi，而应该是 xdv，xelatex 处理之后的文件后缀为 xdv，再通过 dvisvgm 处理成 svg。\n这样我们终于成功的让 org-mode 支持实时显示含有中文的公式了。\n\n配置 orgmode 的 LaTeX 环境的其他问题\nTex 环境的选择\n目前应该有三种选择：\n\n\n直接安装 MacTex，非常大，功能很全，但是很多用不上，删除也不容易，还和 homebrew 冲突。\n\n\n通过 homebrew 安装 basictex，比起 MacTex，这个不到 100M，所以很多 package 都没有，安装之后还需要安装所需要的 package。具体来说为了能够使用 org-export 导出 PDF 文件，我还安装了如下的 package。\nsudo tlmgr nth\nsudo tlmgr install capt-of\nsudo tlmgr install wrapfig\n \nsudo tlmgr install nth\nsudo tlmgr install ulem xcolor environ letltxmacro enumitem stringenc trimspaces soul algorithm2e genmisc\nsudo tlmgr install epstopdf subfigure appendix\n \nsudo tlmgr install ifmtarg\nsudo tlmgr install multirow ifoddpage relsize titlesec\nsudo tlmgr install xifthen\n\n\n使用 MikTex，这个我并没有了解，不太清楚使用的效果。\n\n\n配置 org-export 使用 xelatex 来做 pdf 的生成\n(setq org-latex-compiler &quot;xelatex&quot;)\n(setq org-latex-pdf-process &#039;(&quot;xelatex %f&quot;))\n(add-to-list &#039;org-latex-default-packages-alist &#039;(&quot;&quot; &quot;ctex&quot; t (&quot;xelatex&quot;)))\n实时的预览 LaTeX 公式\norg-latex-preview 这个函数不是自动调用的，需要使用一个插件 org-fragtog 来让我们离开公式输入的region之后自动调用这个函数生成预览。这里我直接使用 use-package 来管理包的安装。\n(use-package org-fragtog\n  :after org\n  :hook\n  (org-mode . org-fragtog-mode))\n相关的一些链接\n\nMacTex\nMikTex\nuninstall ghostscript\nLaTeX公式中的中文输入\n"},"Blogs/让-Emacs-的-paredit-的编辑快捷键更符合直觉":{"slug":"Blogs/让-Emacs-的-paredit-的编辑快捷键更符合直觉","filePath":"Blogs/让 Emacs 的 paredit 的编辑快捷键更符合直觉.md","title":"让 Emacs 的 paredit 的编辑快捷键更符合直觉","links":[],"tags":["Software/Editor/Emacs"],"content":"什么是 paredit？\n刚开始使用 lisp 类语言的人大多都会觉得 lisp 中的括号不是很容易看清和分辨，经常写着写着不小心删除了一个 ) 就导致不匹配，如果光标还在删除的位置还好，要是不小心碰到了触控板导致光标移动到了别的地方，那可能就要仔细找找才能找到原来的位置了。这种情况频率不高还好，还有种更困扰的情景是写了一大段代码，代码中间的逻辑可能改了好几次，终于满意了，需要最后把没有写完的 ) 补完，这时候就一个一个小心又小心的注意不能写少也不能写多了。第二种情景不止会在 lisp 类的语言中遇到，任何需要括号来确定作用域的语言其实都会有这个问题，比如 Golang 中的 {} ，只是遇到的频率小很多。\n为了解决这个问题，我们一般都需要借助于结构化的编辑插件，结构化的编辑插件可以分成两个类型。\n\n\n非强制的建议性的补齐插件\n这是一般的编辑器现在普遍存在的功能，在你输入 &quot;, (, { 之后自动补齐 &quot;, ), } 之类的符号，emacs 24 之后提供的 electric-pair-mode 就是这样的实现。这中状态下用户可以任意删除 &quot;, (), {} 等字符，文档中可能出现括号不匹配的状态，需要用户自己去修改。\n\n\n强制要求所有括号匹配的插件\n类似 paredit, lispy, smartparens-strict-mode 的插件，要求在任何时候括号都必须匹配，如果要删除则需要一对同时删除。着保证了我们不需要再担心括号匹配的问题，但会对文档的修改造成一定的限制。\nparedit 应该算是 emacs 上这类插件的鼻祖的了， smartparens 和 lispy 都是借鉴了 paredit 之后增加了一些新功能。我最开始使用的是 smartparens 但是并没有使用强制的模式，使用一段时间过后，其实感觉差别不大，很多功能都没有用到，这样就显得提供的功能太多了。于是我切换到了功能更加纯粹的 paredit 来编辑 lisp 类的代码，而其它模式下使用 emacs 自带的 electric-pair-mode 就完全满足需求了。\n\n\nlisp 类语言编程对 S-exp 常用的操作\n在使用强制括号匹配的插件之后，之前某些通过现删除后括号增加些内容，再添加后括号的操作是被禁止的，因为会导致括号不匹配。所以需要一些同时修改前后括号的操作来完成编辑动作。总结下来在一般的编辑过程中，会频繁的使用下面提到的四种操作。\n\n\nUnwrap, 相当于解包，把一对括号中的内容拿到外面来。我们可以通过下面的例子来说明， | 代表光标所在位置， ---&gt; 上代表操作之前的状态，下代表操作结束后的状态。\n(foo (bar| baz) quux)\n  ---&gt;\n(foo bar| baz quux)\n\n\nWrap，和 Unwrap 对应，相当于封包，把内容封装到一对括号当中，同样使用例子来展示。\n(foo |bar baz)\n  ---&gt;\n(foo (|bar) baz)\n\n\nSlurp, 吃进来，向前或向后扩张当前括号的范围，把括号的前一个或者后一个元素吃到当前的括号当中来。\n\n向后吞并元素\n\n(foo (bar |baz) quux zot)\n  ---&gt;\n(foo (bar |baz quux) zot)\n \n(a b ((c| d)) e f)\n  ---&gt;\n(a b ((c| d) e) f)\n\n向前吞并元素\n\n(foo bar (baz| quux) zot)\n  ---&gt;\n(foo (bar baz| quux) zot)\n \n(a b ((c| d)) e f)\n  ---&gt;\n(a (b (c| d)) e f)\n\n\nBarf, 吐出去，向前或者向后吐出括号内最近的内容，相当于缩小当前的括号范围。\n\n向后吐出元素\n\n(foo (bar |baz quux) zot)\n  ---&gt;\n(foo (bar |baz) quux zot)\n\n向前吐出元素\n\n(foo (bar baz |quux) zot)\n  ---&gt;\n(foo bar (baz |quux) zot)\n\n\nparedit 的默认按键绑定存在的问题\n针对上面常用的四种操作，paredit 中都有对应的函数，并且绑定特定的快捷键，但是使用一段时间我发现这些快捷键的设计缺乏合理的设计隐喻，所以需要死记硬背才能熟练，而且如果一段时间没有使用就多半会忘记，重新用又要再重新记忆一遍，而偏偏我还是个记忆不算好的人，十分的别扭。我们来说说默认的快捷键和存在的问题。\n\n\nUnwrap，对应的快捷键为 M-s, 对应的函数为 paredit-splice-sexp 可以看出这个快捷键的设置完全是根据函数名来设置的，但是对于我来说我和作者对于这一操作的命名不一样，作者认为是把 S-exp 劈开，我认为这个行为更像是把 S-exp 拿出来，因为在对这个 S-exp (foo|) 使用是产生的结果是 foo|, (foo bar |baz quux) 产生的结果是 foo bar |baz quux ，这两种情况下都很难理解 splice 的语义，我认为 unwrap 的描述更准确。这就导致我在使用这个命令时需要转换，我想做一个我认为是 unwrap 的操作，需要想到用的函数是 splice，所以快捷键是 M-s 。\n\n\nWrap，对应的快捷键为 M-( ，对应的函数为 paredit-wrap-round ，看起来没什么问题，用括号包起来嘛。但在使用中会有两个不好的点，第一，( 是需要按住 shift 才能打出的符号，也就是说我实际是要按三个按键；第二，如果我的光标在这个位置 bar| 快捷键确实 ( ，这里也存在着隐喻的转换， /当然如果你实际在这个位置使用这个命令，目前的 paredit 会是这样的结果 bar () / 。另外还有一个问题就是这个命名和 unwrap 是有对应关系的，当在快捷键的设计上缺完全没有考虑，造成了更多的记忆负担。\n\n\nBarf &amp; Slurp，这两个动作实际对应了四个操作，paredit 在这四个操作的快捷键设计上我认为作者是有思考的，有自己的逻辑，原有的键位设置比起一些 paredit 的设置分享上改为 M-{, M-[ 之类的好上非常多，我不是很理解那些设置分享的人是通过怎样的模型来记忆这几个操作的。\n在默认的设置中，作者是按照操作的位置来区分的 C 键代表操作右边的括号：\n\n\nC-&lt;right&gt; 就是向后吞元素，右边括号继续往右移动，调用的函数为 paredit-forward-slurp-sexp , 非常直观，这也是我没有调整之前记得最清楚的操作，有时候其它操作都要转化成这个操作来完成。\n\n\nC-&lt;left&gt; 同样操作右边括号，向后吐出元素，右边括号向左边移动，调用函数 paredit-forward-barf-sexp , 注意这里有个点是函数名里有个 forward，但我们的括号实际在往左边移动，这是 barf 的语义造成的问题，在我们使用快捷键，不用想函数名时不会有困扰。\n\n\n然后默认设置中 C-M 键代表了操作左括号：\n\n\nC-M-&lt;left&gt; 就是向前吞并元素，左边的括号继续往左移动，调用的函数为 paredit-backward-slurp-sexp 。\n\n\nC-M-&lt;right&gt; 就是向前吐出元素，左边的括号向右边移动，调用函数paredit-backward-barf-sexp 。\n\n\n我认为 Barf &amp; Slurp 这组快捷键是作者经过精心设计的，比较的直观并且有自己的操作逻辑，比起 un/wrap 的键位设计好很多，也更容易记住。但是我不满意的点在于，我直觉上更倾向于把 slurp 的操作看作一组，barf 的操作看做另外一组，而不是把针对左括号的操作看作一组，针对右括号的操作看作一组。在实际操作中，左右括号的位置也会随着操作发生改变，虽然和方向键的方向一致，但是还是会有中模型的原点在不断移动的感觉。另外在 emacs 中，C 和 C-M 代表同一层级的操作对象也不符合 emacs 的直觉，举个例子是 C-f 移动一个字符，M-f 移动一个单词，C-M-f 移动一个 sexp，之间是有层级关系的模型存在。\n\n\n基于 control, meta 和方向键的解决方案\n说完了默认绑定的键位问题，来说说我的改进方案。\n首先把 unwrap &amp; wrap 这两个操作看做一组，分别绑定为 unwrap: M-&lt;up&gt;, wrap: M-&lt;down&gt; 。可以理解为 wrap 就是向下把 sexp 放到括号这个盒子里，uwrap 就是向上把 sexp 从括号这个盒子里拿出来。\n其次把 slurp 的操作看作一组，把 barf 的操作看作另一组，而放弃绑定到左右括号上。\nSlurp 的操作全部绑定到 C 上，要吞掉后面的元素，使用 C-&lt;right&gt; 。C 表示吞，方向指向要吞掉元素。同理向前吞就使用 C-&lt;left&gt; 。\nBarf 的操作全部绑定到 M 上，要吐掉后面的元素，使用 M-&lt;right&gt; , M 表示吐，方向指向要吐出的元素。同理向前吐就使用 M-&lt;left&gt; 。这里的操作方向和括号的移动方向是相反的，但是我们的心理模型并不是绑定到括号的移动方向上，可以这么立即，吐出去肚子会变小，所以括号会往里缩紧。\n下面是调整完后的配置代码：\n(use-package paredit\n  :delight &quot; Par&quot;\n  :bind\n  (:map paredit-mode-map\n\t(&quot;M-&lt;up&gt;&quot; . paredit-splice-sexp)\n\t(&quot;M-&lt;down&gt;&quot; . paredit-wrap-round)\n\t(&quot;C-&lt;right&gt;&quot; . paredit-forward-slurp-sexp)\n\t(&quot;C-&lt;left&gt;&quot; . paredit-backward-slurp-sexp)\n\t(&quot;M-&lt;left&gt;&quot; . paredit-backward-barf-sexp)\n\t(&quot;M-&lt;right&gt;&quot; . paredit-forward-barf-sexp))\n  :hook ((emacs-lisp-mode . paredit-mode)\n\t (scheme-mode . paredit-mode))\n  :config\n  (define-key paredit-mode-map (kbd &quot;M-s&quot;) nil)\n  (define-key paredit-mode-map (kbd &quot;M-?&quot;) nil))"},"Blogs/重新搭建个人博客":{"slug":"Blogs/重新搭建个人博客","filePath":"Blogs/重新搭建个人博客.md","title":"重新搭建个人博客","links":[],"tags":[],"content":"\n\n                  \n                  附注 \n                  \n                \n\n文章迁移自旧博客，已不再具有时效性，只是作为存档。\n\n\n为什么要搭博客？\n说来惭愧，其实很早之前，可能是 Github Pages 刚开始的时候，我就试着用 Jekyll 搭建过自己的博客。但是结果就是捣鼓了一遍 Jekyll 相关的工具链，学了学 ruby，网上找了各种主题，试了又试（自己的博客嘛，首先一定要好看才行），最后搞来搞去还是用了最初Github Pages的主题总算是把项目搭起来了， 然后放上了Github，然后，就没有然后了、、、我没有写博客的习惯，所以一直没有内容，出生就夭折。\n这件事情，总结起来，有种“得术而忘道”的感觉，我们都喜欢去追新的技术，希望自己用的东西越时髦越好，心中总是有种新的工具一定比我现在用的东西好，只要我学会了一定比现在厉害许多，可以轻松的解决我现在不轻松的才能解决的问题。比如当初我觉得我写不好长篇的文章，一定是因为我没有个时髦的可以很炫酷的把你写的文章变成漂亮网页的博客工具，所以花时间尝试了各种工具，最后却没有养成写博客的习惯，因为我一开始的问题就偏了，我应该要学的是如何写出好的文章，而不是造出写文章的笔。\n这问题其实在写代码的行业挺普遍的，写代码的人都对新的事物，特别是新的技术，有着一种超乎其他人的好奇。并且，对稍微有点旧的技术有种不由自主的嫌弃。要是工作中遇到旧一点的技术，就会把大部分的 bug 和开发的不便利归因于陈旧的技术，然后不遗余力的想用新的技术替代旧的技术，最后造出更多的 bug。\n扯远了，收～\n回到博客的话题，为什么现在想重新把自己的博客搭建起来。这问题可以分成两个方面来回答：\n一个方面是个人需求，除开交作业，工作上写文档，我太习惯知识的输入，而十分缺少输出。这种输入造成的一个问题就是，知识输入之后其实并没有在自己脑子了仔细融汇贯通，学了好多的课，读了一些书，看了大量的视频课，但是没有总结成体系，看别人输出的时候可劲儿点头：“嗯嗯，和我想的一样”，但是一旦自己想要输出自己观点的时候就卡壳：“哎呀，这个观点应该怎么解释来着”，“哎呀，这个我应该懂，之前看过的，应该怎么做来着”。这种问题的原因，一个是没有融汇贯通形成自己内在的观点，一个是缺少了表达的练习和实践，所以我想通过写文章的方式来帮助自己更好的理解学到知识，同时也是一种表达的练习。\n另外一个方面是现在的社会，我们太习惯短的碎片的东西。互联网早期的时候，我们写博客来表达自己的想法，后来140字的推特微博来了，消息变短让信息的传递速度变快了，内容和深度变少了，大家都爱段子手。到了现在，短视频火了，信心的沉浸感更强了，但是内容更少，20分钟看20个视频段子，哈哈哈哈，好欢乐～，但是真的不能在自己脑子里面留下什么东西。我们交流的方式也变了，以前是写信，异地的情侣可以在一封信里表达出他（她）一个月的思念，后来我们打电话，一个小时的电话粥还夹着嘟嘟的电流声传递着对方的甜言蜜语，现在我们电话也不打了，微信QQ里面用表情就可以吵架。这种表达方式的碎片化消弭了我们组织和总结自己思想的动力，我们习惯飞快地小而碎的表达，从而缺乏了深思熟虑考虑全面的表达自己思想。所以我想通过重新开始写文章这种办法来在这个碎片的时代保持一个独立思考的手段。\n往后博客的主要内容\n目前还没有详细的更新计划，但今后博客的主题应该主要会包含下面几个内容：\n\n\n计算机相关，毕竟我是个写代码的人。\n\n\n经济相关，一直是我关心的领域，工作后读的研究生也是世界经济，想要理解驱动世界运行的经济逻辑。\n\n\n读书笔记。\n\n\n某些游戏的杂谈。“十年索狗，百年任豚”，玩笑了，第九艺术正在默默的改造这我们这个时代。\n\n\n猫片（家里猫主子日记）\n\n\n结束\n文章最后给自己打个气,\n望我们在这个碎片的时代能始终保持独立的思考。"},"Quick-References/ACM-Code-Of-Ethics":{"slug":"Quick-References/ACM-Code-Of-Ethics","filePath":"Quick References/ACM Code Of Ethics.md","title":"ACM Code Of Ethics","links":[],"tags":["ComputerScience"],"content":"序言\n计算专业人员的行为改变世界。他们应反思其工作的广泛影响，始终如一支持公众利益，才能负责任地行事。计算机协会道德与职业行为准则（下称“准则”）体现了行业良知。\n本《准则》旨在激励和指导包括现有和胸怀抱负的从业者、教师、学生、影响者以及任何以有影响力的方式使用计算技术的人士等所有计算专业人员的道德行为。此外，本《准则》亦可作为发生违规行为时的补救措施依据。基于了解公众利益始终是首要考虑因素，本《准则》包括作为责任声明制定的原则。每项原则都辅以诠释指南，以帮助计算专业人员理解和应用该原则。\n第 1 节阐述了奠定本《准则》其余部分基础的基本道德原则。第 2 节阐明了专业责任的其他更具体的考虑因素。第 3 节给工作场所或专业志愿者团体的领导者提供了指引。每位计算机协会成员都需要坚守道德行为承诺，同时第 4 节中给出了遵守本《准则》的原则。\n整个《准则》所涉及的是基本道德原则如何适用于计算专业人员的行为。本《准则》并非解决道德问题的算法，而是道德决策的基础。在考虑特定问题时，计算专业人员可能会发现应考虑多个原则，同时不同的原则与问题有着不同的相关性。通过认真考虑基本道德原则、理解公众利益是最重要的考虑因素，就能给与这些问题相关的疑问以最好的回答。当道德决策过程对所有利益相关者承责并保持透明时，整个计算行业都会受益。对于道德问题的公开讨论可促进这种责任的承担和透明度。\n1.一般道德原则。\n计算专业人士应…\n1.1 为社会和人类的幸福做出贡献，承认所有人都是计算的利益相关者。\n这一涉及所有人生活质量的原则确认，计算专业人员个体和集体均有义务利用其技能造福社会、造福其成员及其周围环境。这种义务包括促进基本人权和保护每位个体的自主权。计算专业人员的一个基本目标就是最大限度减少计算的负面后果，包括对健康、安全、人身安全和隐私的威胁。当多个群体的利益发生冲突时，应该给那些弱势群体以更多关注和优先。\n计算专业人员应考虑其工作结果是否会尊重多样性、是否会以对社会承责的方式被使用、是否符合社会需求以及是否可具有广泛的可及性。鼓励计算专业人员参与造福公众利益的公益或志愿工作，积极为社会做出贡献。\n除了安全的社会环境外，人类的幸福也需要安全的自然环境。因此，计算专业人员应促进本地和全球的环境可持续性。\n1.2 避免伤害。\n本文中，“伤害”是指负面后果，特别是那些重大和不公正的后果。伤害的例子包括不合理的身心伤害、不正当的信息破坏或披露以及对财产、声誉和环境的不合理损害。上述伤害并非详尽无遗。\n完成指定职责等善意行为也可能造成伤害。如果是无意造成的伤害，责任人有义务尽可能撤销或减轻伤害。避免伤害始于认真考虑给受决策影响的所有人士造成的潜在影响。如果伤害是系统有意为之，责任人有义务确保伤害合乎道德。无论怎样，责任人应尽量减少伤害。\n为了最大限度降低间接或意外伤害他人的可能性，计算专业人员应遵循普遍接受的最佳做法，除非真的有其他令人信服的道德理由不这样去做。此外，应仔细分析数据汇总和系统紧急属性的后果。对于涉及普及或基础设施系统的伤害，也应考虑原则 3.7。\n计算专业人员还有义务报告可能导致伤害的任何系统风险迹象。如果领导者未采取措施来减少或减轻这种风险，可能有必要“举报”以减少潜在的伤害。但是，反复无常或误导性的风险报告本身可能就有害。在报告风险之前，计算专业人员应仔细评估相关方面的情况。\n1.3 诚实可靠。\n诚实是信任的重要组成部分。计算专业人员应保持透明，向有关各方充分披露所有相关系统功能、限制和潜在问题。故意造假或误导声明、虚构或伪造数据、提供或接受贿赂以及其他不诚行为均属对于本《准则》的违反。\n计算专业人员在其资格及其完成任务能力的任何限制方面应诚实相告。计算专业人员应直率面对任何可能导致实际或感知利益冲突或破坏其判断独立性的情况。此外，计算专业人员应兑现承诺。\n计算专业人员不应歪曲组织的政策或程序，同时如果没有获得授权，则不应代表组织发言。\n1.4 做事公平，采取行动无歧视。\n平等、宽容、尊重他人和正义的价值观是这一原则的管理方针。要做到公平，就需要在即便十分谨慎的决策过程中也提供一些纠正错误的机会。\n计算机专业人员应促成包括代表性不足群体在内的所有人的公平参与。基于年龄、肤色、残疾、种族、家庭状况、性别认知、工会会员、军人身份、国籍、种族、宗教或信仰、性别、性取向或任何其他不适当因素的偏见与歧视均为对于本《准则》的明确违反。骚扰（包括性骚扰）、欺凌和其他滥用权力和权威的行为是一种歧视形式，和其他伤害一样，会限制对于发生此等骚扰的虚拟和物理空间的公平进入。\n信息和技术的使用可能产生新的或加剧现有的不公平现象。技术和实践应尽可能具有包容性和可访问性，计算专业人员应采取措施避免创建剥夺或压迫人权的系统或技术。不具有包容性和可访问性的设计可能构成不公平歧视。\n1.5 尊重需要产生新想法、新发明、创造性作品和计算工件的工作。\n开发新的想法、发明、创造性作品和计算工件可以为社会创造价值，同时在上述方面努力的人士应从其工作中获得价值。因此，计算专业人员应鸣谢承认创意、发明、作品和文物的创作者，并尊重版权、专利、商业秘密、许可协议以及其他保护作者作品的方法。\n习俗和法律都承认，创作者对作品控制权的一些例外是公众利益的需要。计算专业人士不应过度反对对于其知识产权的合理使用。为有助于社会的项目付出时间和精力等努力来帮助他人是这一原则积极方面的体现。这些努力包括免费和开源软件以及公共领域工作。计算专业人员不应对本人或他人已经共享为公共资源的工作主张私人所有权。\n1.6 尊重隐私。\n尊重隐私的责任对于计算专业人员具有特别重要的意义。技术可以快速、低成本地收集、监控和交换个人信息，而且往往让受影响人群毫不知情。因此，计算专业人员应熟悉各种隐私的定义和形式，并应了解关于收集和使用个人信息相关的权利和责任。\n计算专业人员只应将个人信息用于正规合理的目的，不得侵犯个人和团体的权利。这就需要采取预防措施以防止重新识别匿名数据或未经授权的数据收集、确保数据准确性、了解数据来源并保护数据免受未经授权的访问和意外泄露。计算专业人员应建立透明的政策和程序，使个人能够了解正在收集的是什么数据及其使用方式，为自动数据收集提供知情同意，并审查、获取、纠正不准确和删除其个人数据。\n只应在系统中收集必要的最少量的个人信息。计算机专业人员应该把数据的保留和处置时间明确地定义、执行并与数据主体传达。未经个人同意，不得将为特定目的收集的个人信息用于其他目的。合并数据集合可能会影响原始数据集合中的隐私功能。因此，计算专业人员在合并数据集合时应特别注意隐私。\n1.7 尊重保密协议。\n计算专业人员通常会被委以保密信息，例如商业秘密、客户数据、非公共商务战略、财务信息、研究数据、出版前学术文章和专利申请。计算专业人员应保护信息保密性，除非有证据表明其对法律、组织法规或本《准则》的违反。在这种情况下，该信息的性质或内容不得向除有关部门之外的任何人或机构披露。计算专业人员应仔细考虑该披露是否与本《准则》一致。\n2.职业责任。\n计算专业人士应…\n2.1 努力在专业工作的过程和产品中实现高质量。\n计算专业人员应该坚持并支持其自身及其同事的高质量工作。在整个工作过程中，应尊重雇主、员工、同事、客户、用户以及受工作直接或间接影响的任何其他人的尊严。计算专业人员应尊重涉及此项目相关人士的沟通透明性的权利。专业人员应认识到可能由于工作质量不佳所造成的、影响任何利益相关者的任何严重负面后果，并且应该抵制忽视这种责任的诱惑。\n2.2 保持高标准的专业能力、行为和道德实践。\n高质量的计算取决于个人和团体能否尽职尽责去获得和保持其专业能力。专业能力始于技术知识及对于其工作开展的社会背景的了解。专业能力还应包括沟通技能、反思分析技能，以及对道德挑战的识别和驾驭能力。提升技能会是一个持续的过程，可能包括独立学习、参加会议或研讨会以及其他正式或非正式的教育。专业组织和雇主应鼓励和促进这些活动。\n2.3 了解并尊重与专业工作相关的现有规则。\n此处的“规则”包括地方、地区、国家和国际法律法规以及专业人员所属组织的任何政策和程序。计算专业人员必须遵守这些规则，除非令人信服的道德理由另有要求。被判断为不道德的规则应该受到挑战。当规则的道德基础不充分或将造成可识别的伤害时，这个规则可能是不道德的。计算专业人员应该在违反规则之前考虑通过现有渠道质疑规则。因规则不道德或任何其他原因而决定违反规则的计算专业人员必须考虑潜在的后果并对其行为承担责任。\n2.4 接受并提供适当的专业审查。\n高质量的计算专业工作取决于所有阶段的专业审查。在任何适当的情况下，计算专业人员都应寻求并利用同行和利益相关者的审查。计算机专业人员还应对他人的工作提供建设性的和批判性的审查。\n2.5 对计算机系统及其影响进行全面彻底的评估，包括分析可能的风险。\n计算专业人员处于受信任的地位，因此负有为雇主、员工、客户、用户和公众提供客观、可靠的评估和见证的特殊责任。在评估、建议和展示系统说明和替代方案时，计算专业人员应努力保持敏锐、全面和客观。应格外注意识别和减轻机器学习系统中的潜在风险。随着系统的发展，当系统的未来风险在使用中无法被可靠预测的时候，需要对系统进行频繁的风险再评估，否则就不应该部署该系统。可能导致重大风险的任何问题都必须向相关各方汇报。\n2.6 仅在能力范围内开展工作。\n计算专业人员负责评估潜在工作任务。这种评估包括对于工作的可行性和可取性的评估以及对于工作任务安排是否在其专业领域能力之内的判断。如果在工作任务之前或期间的任何时候，专业人员确认缺乏必要的专业知识，则必须告知雇主或客户。客户或雇主可决定让专业人员在额外的时间获得必要的能力后再执行任务，或安排具有所需专业知识的人员来执行任务，或放弃任务。计算专业人员的道德判断应是决定是否从事任务的最终指南。\n2.7 培养公众对计算、相关技术及其后果的认识和理解。\n计算专业人员应根据具体情况和个人能力，向公众分享技术知识、培养计算意识，并鼓励对计算的理解。与公众的此类沟通应该清晰、礼貌和热情。重要的议题包括计算机系统的影响、局限性和脆弱性及其展现出的机会。另外，计算专业人员应以尊重的方式处理与计算有关的不准确或误导性信息。\n2.8 仅当获得授权或仅为公众利益之目的才能访问计算和通信资源。\n个人和组织有权限制对其系统和数据的访问，但这些限制必须符合本《准则》中的其他原则。因此，在没有合理理由认为其行为将被授权或无法笃信其行为符合公众利益的情况下，计算专业人员不应访问另一人的计算机系统、软件或数据。可公开访问的系统本身并不足以暗示授权。在特殊情况下，计算专业人员可能会使用未经授权的访问来破坏或阻止恶意系统的运行，在这些情况下必须采取特别的预防措施以避免给他人造成伤害。\n2.9 设计和实施具有稳固又可用的安全的系统。\n违反计算机安全规则会造成伤害。在设计和实施系统时，稳固的安全性应该是首要考虑因素。计算专业人员应尽职工作以确保系统按预期运行，并应采取适当措施确保资源免遭意外和故意滥用、修改和拒绝服务。由于系统部署后，威胁可能出现并不断变化，所以计算专业人员应集成威胁缓解技术和策略，如监控、补丁和漏洞报告。计算专业人员还应采取措施，确保及时明确通知受数据泄露影响的各方，并提供适当的指导和补救措施。\n为确保系统达到预期目的，安全功能应设计为尽可能直观且易于使用。计算专业人员不应采取过于混乱、在情境上不合适或以其他方式遏制合规使用的安全预防措施。\n如果系统误用或损害可预测或不可避免，最好的选择可能是不使用该种系统。\n3.专业领导原则。\n领导者可以经由正式指定或基于对他人的影响力非正式产生。在本节中，“领导者”是指具有影响力、教育责任或管理责任的组织或团体的任何成员。虽然这些原则适用于所有计算专业人员，但领导者承担着在组织内部和整个组织中维护和促进这些原则的高度责任。\n计算专业人员，特别是作为领导者的人士，应…\n3.1 确保公众利益是所有专业计算工作的核心问题。\n包括用户、客户、同事以及其他受直接或间接影响的人士在内的所有人都应始终是计算关心的核心问题。在进行与研究、需求分析、设计、实施、测试、验证、部署、维护、停用和处置相关的任务评估时，公众利益应始终是一个明确的考虑因素。无论计算专业人员在实践中使用哪种方法或技术，他们都应保持这一重点。\n3.2 明确、鼓励接受并评估组织或团体成员履行社会责任的情况。\n技术组织和团体会对大范围的社会产生影响，其领导者应该承担相关的责任。组织通过在流程和态度上注重质量、透明度和社会幸福感，可减少对公众的伤害，并提高对技术给我们生活带来的影响的认识。因此，领导者应鼓励计算专业人员充分参与履行相关的社会责任，并劝阻不这样做的倾向。\n3.3 管理人员和资源，提高工作生活质量。\n领导者应确保增强、而非降低工作生活质量。领导者应该考虑所有工人的个人和职业发展、无障碍要求、身体安全、心理健康和人格尊严。应在工作场所采用适当的人体工程学标准。\n3.4 阐明、应用和支持反映本准则原则的政策和流程。\n领导者应追求与本《准则》一致的明确定义的组织政策，并将其有效传达给利益相关者。此外，领导者应鼓励并奖励对这些政策的遵守，并对违反政策的情况采取适当的措施。设计或实施故意或无意违反或倾向于违反本《准则》原则的流程在道德上不可接受。\n3.5 为组织或团队成员创造机会，让其成长为专业人员。\n教育机会对所有组织和团体成员都至关重要。领导者应确保计算专业人员有机会得到帮助来提高专业精神、道德实践和技术专长等方面的知识和技能。这些机会应包括让计算专业人员熟悉特定类型系统的后果和限制的体验。计算专业人员应充分意识到过度简化方法的危险性、预测每种可能操作条件的不可能性、软件错误的必然性、系统及其环境的相互作用，以及与其专业复杂性相关的其他问题——从而能有信心地承担其所开展工作的责任。\n3.6 谨慎修改或停用系统。\n界面更改、功能删除甚至软件更新都会影响用户的工作效率和工作质量。在改变或停止对人们仍然依赖的系统功能的支持时，领导者应保持谨慎。在取消对传统旧式系统的支持时，领导者应彻底调查可行的替代方案。如果这些替代方案具有不可接受的风险或不切实际，开发人员应协助利益相关方进行从系统向替代方案的无损安全迁移。在终止支持之前的长时间内，应通知用户有关继续使用不受支持系统的风险。计算专业人员应协助系统用户监测其计算系统的运行可行性，并帮助用户了解可能需要及时更换不适当或过时的功能或整个系统。\n3.7 识别并特别关注那些融入社会基础设施里的系统。\n当与商业、旅游、政府、医疗保健和教育等日常活动相结合时，即使最简单的计算机系统也有可能影响社会的各个方面。在开发成为社会基础设施重要组成部分的系统时，组织和团体的领导者有成为这些系统的优良管理者的额外责任。良好的管理需要制定公平系统访问政策，包括让那些可能被排除在外的人士进行访问的政策，还要求计算专业人员监控其系统与社会基础设施的整合程度。组织或团队的道德责任可能随着使用程度的变化而有所不同。持续监控社会如何使用系统将使得组织或团体能够与本《准则》中概述的道德义务保持一致。如果没有适当的维护标准，计算专业人员有责任确保制定该类标准。\n4.遵守《准则》\n计算专业人士应…\n4.1 坚持、促进和尊重《准则》的原则。\n计算的未来取决于技术和道德的卓越性。计算专业人员应遵守本《准则》的原则，并持续改进这些原则。意识到违反本《准则》的计算专业人员应采取行动解决他们意识到的道德问题，包括在合理的情况下向被认为违反本《准则》的人员表达其担忧。\n4.2 将违反本《准则》的行为视为不符合计算机协会会员资格。\n每位计算机协会会员，都应鼓励并支持所有计算专业人员遵守本《准则》，无论其是否是 ACM 会员。意识到违反本《准则》的计算机协会成员应考虑向计算机协会报告违规行为，这可能触发计算机协会道德与职业行为准则执法政策中制定的补救措施。"},"Quick-References/Editor-Config-File":{"slug":"Quick-References/Editor-Config-File","filePath":"Quick References/Editor Config File.md","title":"Editor Config File","links":["VIM"],"tags":["Reference","Programming/Editor"],"content":"EditorConfig 在支持他的编辑器中可以为项目中各种类型的文件单独设置缩进的策略，比如在 .go 文件中使用 tab 缩进，而在同项目的 .html 中适用两格空格缩进。\n当然，这个需要编辑器的支持，Neovim 是支持的，这样在 neovim 的全局设置中可以设置为默认是四格空格缩进，而在项目中为 html, yaml 等文件单独设置为两格空格缩进，不需要手动切换。\n使用的方法就是在项目的根目录放入一个 toml 格式的 .editorconfig 配置文件。\n一个简单的例子\n# content of .editorconfig file\n \n# top-most EditorConfig file\nroot = true\n \n# Unix-style newlines with a newline ending every file\n[*]\nend_of_line = lf\ninsert_final_newline = true\n \n# Matches multiple files with brace expansion notation\n# Set default charset\n[*.{js,py}]\ncharset = utf-8\n \n# 4 space indentation\n[*.py]\nindent_style = space\nindent_size = 4\n \n# Tab indentation (no size specified)\n[Makefile]\nindent_style = tab\n \n# Indentation override for all JS under lib directory\n[lib/**.js]\nindent_style = space\nindent_size = 2\n \n# Matches the exact files either package.json or .travis.yml\n[{package.json,.travis.yml}]\nindent_style = space\nindent_size = 2\n文件匹配模式\n文件中的 section name 支持模式匹配，有以下语法：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npatterneffect*Matches any string of characters, except path separators (/)**Matches any string of characters?Matches any single character[name]Matches any single character in name[!name]Matches any single character not in name{s1,s2,s3}Matches any of the strings given (separated by commas)  (Available since EditorConfig Core 0.11.0){num1..num2}Matches any integer numbers between num1 and num2,  where num1 and num2 can be either positive or negative\n支持的控制属性\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKeySupported valuesindent_styleSet to tab or space to use hard tabs or soft tabs respectively. The values are case insensitive.indent_sizeSet to a whole number defining the number of columns used for each indentation level and the width of soft tabs (when supported). If this equals tab, the indent_size shall be set to the tab size, which should be tab_width (if specified); else, the tab size set by the editor. The values are case insensitive.tab_widthSet to a whole number defining the number of columns used to represent a tab character. This defaults to the value of indent_size and should not usually need to be specified.end_of_lineSet to lf, cr, or crlf to control how line breaks are represented. The values are case insensitive.charsetSet to latin1, utf-8, utf-8-bom, utf-16be or utf-16le to control the character set. Use of utf-8-bom is discouraged.spelling_languageSets the natural language that should be used for spell checking. Only one language can be specified. There is no default value.The format is ss or ss-TT, where ss is an ISO 639 language code and TT is an ISO 3166 territory identifier.Note: This property does not specify the charset to be used. The charset is in separate property charset.trim_trailing_whitespaceSet to true to remove all whitespace characters preceding newline characters in the file and false to ensure it doesn’t.insert_final_newlineSet to true ensure file ends with a newline when saving and false to ensure it doesn’t.rootMust be specified in the preamble. Set to true to stop the .editorconfig file search on the current file. The value is case insensitive.\n更完整的清单可以在这里找到。"},"Quick-References/LaTeX-Quick-Reference":{"slug":"Quick-References/LaTeX-Quick-Reference","filePath":"Quick References/LaTeX Quick Reference.md","title":"LaTeX Quick Reference","links":[],"tags":["Reference","ComputerScience/LaTex"],"content":"1 数学公式编辑 Displaying a formula\n1.1 符号与字母 Symbol and Alphabet\n1.1.1 希腊字母 Greek alphabet\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号小写LaTeX读音序号大写LaTeX读音1\\alpha\\alpha/ˈælfə/31\\Gamma\\Gamma/ˈɡæmə/2\\beta\\beta/ˈbiːtə/, US: /ˈbeɪtə/32\\Delta\\Delta/ˈdɛltə/3\\gamma\\gamma/ˈɡæmə/33\\Theta\\Theta/ˈθiːtə/4\\delta\\delta/ˈdɛltə/34\\Lambda\\Lambda/ˈlæmdə/5\\epsilon\\epsilon/ˈɛpsɪlɒn/35\\Xi\\Xi/zaɪ, ksaɪ/6\\varepsilon\\varepsilon/ˈɛpsɪlɒn/36\\Pi\\Pi/paɪ/7\\zeta\\zeta/ˈzeɪtə/37\\Sigma\\Sigma/ˈsɪɡmə/8\\eta\\eta/ˈeɪtə/38\\Upsilon\\Upsilon/ˈʌpsɪlɒn/9\\theta\\theta/ˈθiːtə/39\\Phi\\Phi/faɪ/10\\vartheta\\vartheta/ˈθiːtə/40\\Psi\\Psi/psaɪ/11\\iota\\iota/aɪˈoʊtə/41\\Omega\\Omega/oʊˈmeɪɡə/12\\kappa\\kappa/ˈkæpə/13\\lambda\\lambda/ˈlæmdə/14\\mu\\mu/mjuː/15\\nu\\nu/njuː/16\\xi\\xi/zaɪ, ksaɪ/17oo/ˈɒmɪkrɒn/18\\pi\\pi/paɪ/19\\varpi\\varpi/paɪ/20\\rho\\rho/roʊ/21\\varrho\\varrho/roʊ/22\\sigma\\sigma/ˈsɪɡmə/23\\varsigma\\varsigma/ˈsɪɡmə/24\\tau\\tau/taʊ, tɔː/25\\upsilon\\upsilon/ˈʌpsɪlɒn/26\\phi\\phi/faɪ/27\\varphi\\varphi/faɪ/28\\chi\\chi/kaɪ/29\\psi\\psi/psaɪ/30\\omega\\omega/oʊˈmeɪɡə/\n\n\n                  \n                  注意 \n                  \n                \n\nMathJax 支持的大写希腊字母有限，如需其他（如大写 Alpha），可使用罗马体转换，如\\mathrm{A}表示大写 Alpha：\\mathrm{A}。\n\n\n1.1.2 希伯来字母 Hebrew alphabet\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号图标LaTeX英文1\\aleph\\alephaleph2\\beth\\bethbeth3\\gimel\\gimelgimel4\\daleth\\dalethdaleth\n1.1.3 二元运算符 Binary operations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号图标LaTeX序号图标LaTeX1++20\\bullet\\bullet2−-21\\oplus\\oplus3\\times\\times22\\ominus\\ominus4\\div\\div (在 physics 扩展开启状态下为)23\\odot\\odot5\\pm\\pm24\\oslash\\oslash6\\mp\\mp25\\otimes\\otimes7\\triangleleft\\triangleleft26\\bigcirc\\bigcirc8\\triangleright\\triangleright27\\diamond\\diamond9\\cdot\\cdot28\\uplus\\uplus10\\setminus\\setminus29\\bigtriangleup\\bigtriangleup11\\star\\star30\\bigtriangledown\\bigtriangledown12\\ast\\ast31\\lhd\\lhd13\\cup\\cup32\\rhd\\rhd14\\cap\\cap33\\unlhd\\unlhd15\\sqcup\\sqcup34\\unrhd\\unrhd16\\sqcap\\sqcap35\\amalg\\amalg17\\vee\\vee36\\wr\\wr18\\wedge\\wedge37\\dagger\\dagger19\\circ\\circ38\\ddagger\\ddagger\n1.1.4 二元关系符 Binary relations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号图标LaTeX序号图标LaTeX1==49\\gneq\\gneq2\\ne\\ne50\\geqq\\geqq3\\neq\\neq51\\ngeq\\ngeq4\\equiv\\equiv52\\ngeqq\\ngeqq5\\not\\equiv\\not\\equiv53\\gneqq\\gneqq6\\doteq\\doteq54\\gvertneqq\\gvertneqq7\\doteqdot\\doteqdot55\\lessgtr\\lessgtr8\\overset{\\underset{\\mathrm{def}}{}}{=}\\overset{\\underset{\\mathrm{def}}{}}{=}56\\lesseqgtr\\lesseqgtr9:=:=57\\lesseqqgtr\\lesseqqgtr10\\sim\\sim58\\gtrless\\gtrless11\\nsim\\nsim59\\gtreqless\\gtreqless12\\backsim\\backsim60\\gtreqqless\\gtreqqless13\\thicksim\\thicksim61\\leqslant\\leqslant14\\simeq\\simeq62\\nleqslant\\nleqslant15\\backsimeq\\backsimeq63\\eqslantless\\eqslantless16\\eqsim\\eqsim64\\geqslant\\geqslant17\\cong\\cong65\\ngeqslant\\ngeqslant18\\ncong\\ncong66\\eqslantgtr\\eqslantgtr19\\approx\\approx67\\lesssim\\lesssim20\\thickapprox\\thickapprox68\\lnsim\\lnsim21\\approxeq\\approxeq69\\lessapprox\\lessapprox22\\asymp\\asymp70\\lnapprox\\lnapprox23\\propto\\propto71\\gtrsim\\gtrsim24\\varpropto\\varpropto72\\gnsim\\gnsim25&lt;&lt;73\\gtrapprox\\gtrapprox26\\nless\\nless74\\gnapprox\\gnapprox27\\ll\\ll75\\prec\\prec28\\not\\ll\\not\\ll76\\nprec\\nprec29\\lll\\lll77\\preceq\\preceq30\\not\\lll\\not\\lll78\\npreceq\\npreceq31\\lessdot\\lessdot79\\precneqq\\precneqq32&gt;&gt;80\\succ\\succ33\\ngtr\\ngtr81\\nsucc\\nsucc34\\gg\\gg82\\succeq\\succeq35\\not\\gg\\not\\gg83\\nsucceq\\nsucceq36\\ggg\\ggg84\\succneqq\\succneqq37\\not\\ggg\\not\\ggg85\\preccurlyeq\\preccurlyeq38\\gtrdot\\gtrdot86\\curlyeqprec\\curlyeqprec39\\le\\le87\\succcurlyeq\\succcurlyeq40\\leq\\leq88\\curlyeqsucc\\curlyeqsucc41\\lneq\\lneq89\\precsim\\precsim42\\leqq\\leqq90\\precnsim\\precnsim43\\nleq\\nleq91\\precapprox\\precapprox44\\nleqq\\nleqq92\\precnapprox\\precnapprox45\\lneqq\\lneqq93\\succsim\\succsim46\\lvertneqq\\lvertneqq94\\succnsim\\succnsim47\\ge\\ge95\\succapprox\\succapprox48\\geq\\geq96\\succnapprox\\succnapprox\n1.1.5 几何符号 Geometric symbols\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号图标LaTeX序号图标LaTeX1\\parallel\\parallel14\\lozenge\\lozenge2\\nparallel\\nparallel15\\blacklozenge\\blacklozenge3\\shortparallel\\shortparallel16\\bigstar\\bigstar4\\nshortparallel\\nshortparallel17\\bigcirc\\bigcirc5\\perp\\perp18\\triangle\\triangle6\\angle\\angle19\\bigtriangleup\\bigtriangleup7\\sphericalangle\\sphericalangle20\\bigtriangledown\\bigtriangledown8\\measuredangle\\measuredangle21\\vartriangle\\vartriangle9\\circ45^\\circ22\\triangledown\\triangledown10\\Box\\Box23\\blacktriangle\\blacktriangle11\\blacksquare\\blacksquare24\\blacktriangledown\\blacktriangledown12\\diamond\\diamond25\\blacktriangleleft\\blacktriangleleft13\\Diamond\\Diamond \\lozenge26\\blacktriangleright\\blacktriangleright\n1.1.6 逻辑符号 Logic symbols\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号图标LaTeX序号图标LaTeX1\\forall\\forall20\\neg\\neg2\\exists\\exists21\\not\\operatorname{R}\\not\\operatorname{R}3\\nexists\\nexists22\\bot\\bot4\\therefore\\therefore23\\top\\top5\\because\\because24\\vdash\\vdash6\\And\\And25\\dashv\\dashv7\\lor\\lor26\\vDash\\vDash8\\vee\\vee27\\Vdash\\Vdash9\\curlyvee\\curlyvee28\\models\\models10\\bigvee\\bigvee29\\Vvdash\\Vvdash11\\land\\land30\\nvdash\\nvdash12\\wedge\\wedge31\\nVdash\\nVdash13\\curlywedge\\curlywedge32\\nvDash\\nvDash14\\bigwedge\\bigwedge33\\nVDash\\nVDash15\\bar{q}\\bar{q}34\\ulcorner\\ulcorner16\\bar{abc}\\bar{abc}35\\urcorner\\urcorner17\\overline{q}\\overline{q}36\\llcorner\\llcorner18\\overline{abc}\\overline{abc}37\\lrcorner\\lrcorner19\\lnot\\lnot\n1.1.7 集合 Sets\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号图标LaTeX序号图标LaTeX1{}{}23\\sqsubset\\sqsubset2\\emptyset\\emptyset24\\supset\\supset3\\varnothing\\varnothing25\\Supset\\Supset4\\in\\in26\\sqsupset\\sqsupset5\\notin\\notin27\\subseteq\\subseteq6\\ni\\ni28\\nsubseteq\\nsubseteq7\\cap\\cap29\\subsetneq\\subsetneq8\\Cap\\Cap30\\varsubsetneq\\varsubsetneq9\\sqcap\\sqcap31\\sqsubseteq\\sqsubseteq10\\bigcap\\bigcap32\\supseteq\\supseteq11\\cup\\cup33\\nsupseteq\\nsupseteq12\\Cup\\Cup34\\supsetneq\\supsetneq13\\sqcup\\sqcup35\\varsupsetneq\\varsupsetneq14\\bigcup\\bigcup36\\sqsupseteq\\sqsupseteq15\\bigsqcup\\bigsqcup37\\subseteqq\\subseteqq16\\uplus\\uplus38\\nsubseteqq\\nsubseteqq17\\biguplus\\biguplus39\\subsetneqq\\subsetneqq18\\setminus\\setminus40\\varsubsetneqq\\varsubsetneqq19\\smallsetminus\\smallsetminus41\\supseteqq\\supseteqq20\\times\\times42\\nsupseteqq\\nsupseteqq21\\subset\\subset43\\supsetneqq\\supsetneqq22\\Subset\\Subset44\\varsupsetneqq\\varsupsetneqq\n1.1.8 箭头 Arrows\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号图标LaTeX序号图标LaTeX1\\Rrightarrow\\Rrightarrow36\\longmapsto\\longmapsto2\\Lleftarrow\\Lleftarrow37\\rightharpoonup\\rightharpoonup3\\Rightarrow\\Rightarrow38\\rightharpoondown\\rightharpoondown4\\nRightarrow\\nRightarrow39\\leftharpoonup\\leftharpoonup5\\Longrightarrow\\Longrightarrow40\\leftharpoondown\\leftharpoondown6\\implies\\implies41\\upharpoonleft\\upharpoonleft7\\Leftarrow\\Leftarrow42\\upharpoonright\\upharpoonright8\\nLeftarrow\\nLeftarrow43\\downharpoonleft\\downharpoonleft9\\Longleftarrow\\Longleftarrow44\\downharpoonright\\downharpoonright10\\Leftrightarrow\\Leftrightarrow45\\rightleftharpoons\\rightleftharpoons11\\nLeftrightarrow\\nLeftrightarrow46\\leftrightharpoons\\leftrightharpoons12\\Longleftrightarrow\\Longleftrightarrow47\\curvearrowleft\\curvearrowleft13\\iff\\iff48\\circlearrowleft\\circlearrowleft14\\Uparrow\\Uparrow49\\Lsh\\Lsh15\\Downarrow\\Downarrow50\\upuparrows\\upuparrows16\\Updownarrow\\Updownarrow51\\rightrightarrows\\rightrightarrows17\\rightarrow\\rightarrow52\\rightleftarrows\\rightleftarrows18\\to\\to53\\rightarrowtail\\rightarrowtail19\\nrightarrow\\nrightarrow54\\looparrowright\\looparrowright20\\longrightarrow\\longrightarrow55\\curvearrowright\\curvearrowright21\\leftarrow\\leftarrow56\\circlearrowright\\circlearrowright22\\gets\\gets57\\Rsh\\Rsh23\\nleftarrow\\nleftarrow58\\downdownarrows\\downdownarrows24\\longleftarrow\\longleftarrow59\\leftleftarrows\\leftleftarrows25\\leftrightarrow\\leftrightarrow60\\leftrightarrows\\leftrightarrows26\\nleftrightarrow\\nleftrightarrow61\\leftarrowtail\\leftarrowtail27\\longleftrightarrow\\longleftrightarrow62\\looparrowleft\\looparrowleft28\\uparrow\\uparrow63\\hookrightarrow\\hookrightarrow29\\downarrow\\downarrow64\\hookleftarrow\\hookleftarrow30\\updownarrow\\updownarrow65\\multimap\\multimap31\\nearrow\\nearrow66\\leftrightsquigarrow\\leftrightsquigarrow32\\swarrow\\swarrow67\\rightsquigarrow\\rightsquigarrow33\\nwarrow\\nwarrow68\\twoheadrightarrow\\twoheadrightarrow34\\searrow\\searrow69\\twoheadleftarrow\\twoheadleftarrow35\\mapsto\\mapsto\n1.1.9 特殊 Special\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号图标LaTeX序号图标LaTeX1\\infty\\infty33\\flat\\flat2\\aleph\\aleph34\\natural\\natural3\\complement\\complement35\\sharp\\sharp4\\backepsilon\\backepsilon36\\diagup\\diagup5\\eth\\eth37\\diagdown\\diagdown6\\Finv\\Finv38\\centerdot\\centerdot7\\hbar\\hbar39\\ltimes\\ltimes8\\Im\\Im40\\rtimes\\rtimes9\\imath\\imath41\\leftthreetimes\\leftthreetimes10\\jmath\\jmath42\\rightthreetimes\\rightthreetimes11\\Bbbk\\Bbbk43\\eqcirc\\eqcirc12\\ell\\ell44\\circeq\\circeq13\\mho\\mho45\\triangleq\\triangleq14\\wp\\wp46\\bumpeq\\bumpeq15\\Re\\Re47\\Bumpeq\\Bumpeq16\\circledS\\circledS48\\doteqdot\\doteqdot17\\amalg\\amalg49\\risingdotseq\\risingdotseq18\\%\\%50\\fallingdotseq\\fallingdotseq19\\dagger\\dagger51\\intercal\\intercal20\\ddagger\\ddagger52\\barwedge\\barwedge21\\ldots\\ldots53\\veebar\\veebar22\\cdots\\cdots54\\doublebarwedge\\doublebarwedge23\\smile\\smile55\\between\\between24\\frown\\frown56\\pitchfork\\pitchfork25\\wr\\wr57\\vartriangleleft\\vartriangleleft26\\triangleleft\\triangleleft58\\ntriangleleft\\ntriangleleft27\\triangleright\\triangleright59\\vartriangleright\\vartriangleright28\\diamondsuit\\diamondsuit60\\ntriangleright\\ntriangleright29\\heartsuit\\heartsuit61\\trianglelefteq\\trianglelefteq30\\clubsuit\\clubsuit62\\ntrianglelefteq\\ntrianglelefteq31\\spadesuit\\spadesuit63\\trianglerighteq\\trianglerighteq32\\Game\\Game64\\ntrianglerighteq\\ntrianglerighteq\n1.2 运算与函数 Operations &amp; Functions\n1.2.1 分数 Fractions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型样式LaTeX分数 Fractions\\frac{2}{4}x=0.5x\\frac{2}{4}x=0.5x or {2 \\over 4}x=0.5x小型分数 Small fractions (force \\textstyle)\\tfrac{2}{4}x\\tfrac{2}{4}x = 0.5x大型分数（不嵌套） Large (normal) fractions (force \\displaystyle)\\dfrac{2}{4}\\dfrac{2}{4} = 0.5 \\qquad \\dfrac{2}{c + \\dfrac{2}{d + \\dfrac{2}{4}}} = a大型分数（嵌套） Large (nested) fractions\\cfrac{2}{c + \\cfrac{2}{d + \\cfrac{2}{4}}} = a\\cfrac{2}{c + \\cfrac{2}{d + \\cfrac{2}{4}}} = a约分线的使用 Cancellations in fractions\\cfrac{x}{1 + \\cfrac{\\cancel{y}}{\\cancel{y}}} = \\cfrac{x}{2}\\cfrac{x}{1 + \\cfrac{\\cancel{y}}{\\cancel{y}}} = \\cfrac{x}{2}\n注意：  其中\\cancel命令需要cancel 扩展包支持，cancel 扩展包是一款自定义宏包，如需使用请在公式页面右上角【设置】页面勾选后使用。\n1.2.2 标准数值函数 Standard numerical functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n样式LaTeX\\exp_a b = a^b, \\exp b = e^b, 10^m\\exp_a b = a^b, \\exp b = e^b, 10^m\\ln c, \\lg d = \\log e, \\log\\_{10} f\\ln c, \\lg d = \\log e, \\log_{10} f\\sin a, \\cos b, \\tan c, \\cot d, \\sec e, \\csc f\\sin a, \\cos b, \\tan c, \\cot d, \\sec e, \\csc f\\arcsin a, \\arccos b, \\arctan c\\arcsin a, \\arccos b, \\arctan c\\operatorname{arccot} d, \\operatorname{arcsec} e, \\operatorname{arccsc} f\\operatorname{arccot} d, \\operatorname{arcsec} e, \\operatorname{arccsc} f\\sinh a, \\cosh b, \\tanh c, \\coth d\\sinh a, \\cosh b, \\tanh c, \\coth d\\operatorname{sh}k, \\operatorname{ch}l, \\operatorname{th}m, \\operatorname{coth}n\\operatorname{sh}k, \\operatorname{ch}l, \\operatorname{th}m, \\operatorname{coth}n\\operatorname{argsh}o, \\operatorname{argch}p, \\operatorname{argth}q\\operatorname{argsh}o, \\operatorname{argch}p, \\operatorname{argth}q\\operatorname{sgn}r, \\left\\vert s \\right\\vert\\operatorname{sgn}r, \\left\\vert s \\right\\vert\\min(x,y), \\max(x,y)\\min(x,y), \\max(x,y)\n\n\n                  \n                  Tip\n                  \n                \n\nLaTeX 和 MathJax 支持的操作符有限，如有特殊操作符，可以使用\\operatorname{}  命令自定义，例如\n\\operatorname{mydefine}x\n\n\n\n1.2.3 根式 Radicals\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n样式LaTeX\\surd\\surd\\sqrt{\\pi}\\sqrt{\\pi}\\sqrt[n]{\\pi}\\sqrt[n]{\\pi}\\sqrt[3]{\\frac{x^3+y^3}{2}}\\sqrt[3]{\\frac{x^3+y^3}{2}}\n1.2.4 微分与导数 Differentials and derivatives\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n样式LaTeXdt, \\mathrm{d}t, \\partial t, \\nabla\\psidt, \\mathrm{d}t, \\partial t, \\nabla\\psidy/dx, \\mathrm{d}y/\\mathrm{d}x, \\frac{dy}{dx}, \\frac{\\mathrm{d}y}{\\mathrm{d}x}, \\frac{\\partial^2}{\\partial x_1\\partial x_2}ydy/dx, \\mathrm{d}y/\\mathrm{d}x, \\frac{dy}{dx}, \\frac{\\mathrm{d}y}{\\mathrm{d}x}, \\frac{\\partial^2}{\\partial x_1\\partial x_2}y\\prime, \\backprime, f^\\prime, f&#039;, f&#039;&#039;, f^{(3)}, \\dot y, \\ddot y\\prime, \\backprime, f^\\prime, f’, f”, f^{(3)}, \\dot y, \\ddot y\n1.2.5 同余与模算术 Modular arithmetic\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n样式LaTeXs_k \\equiv 0 \\pmod{m}s_k \\equiv 0 \\pmod{m}a \\bmod ba \\bmod b\\gcd(m, n), \\operatorname{lcm}(m, n)\\gcd(m, n), \\operatorname{lcm}(m, n)\\mid, \\nmid, \\shortmid, \\nshortmid\\mid, \\nmid, \\shortmid, \\nshortmid\n1.2.6 极限 Limits\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n样式LaTeX\\lim_{n \\to \\infty}x_n\\lim_{n \\to \\infty}x_n\\textstyle \\lim_{n \\to \\infty}x_n\\textstyle \\lim_{n \\to \\infty}x_n\n1.2.7 界限与投影 Bounds and Projections\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n样式LaTeX\\min x, \\max y, \\inf s, \\sup t\\min x, \\max y, \\inf s, \\sup t\\lim u, \\liminf v, \\limsup w\\lim u, \\liminf v, \\limsup w\\dim p, \\deg q, \\det m, \\ker\\phi\\dim p, \\deg q, \\det m, \\ker\\phi\\Pr j, \\hom l, \\lVert z \\rVert, \\arg z\\Pr j, \\hom l, \\lVert z \\rVert, \\arg z\n1.2.8 积分 Integral\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n样式LaTeX\\int\\limits\\_{1}^{3}\\frac{e^3/x}{x^2}\\, dx\\int\\limits_{1}^{3}\\frac{e^3/x}{x^2}, dx\\int\\_{1}^{3}\\frac{e^3/x}{x^2}\\, dx\\int_{1}^{3}\\frac{e^3/x}{x^2}, dx\\textstyle \\int\\limits\\_{-N}^{N} e^x dx\\textstyle \\int\\limits_{-N}^{N} e^x dx\\textstyle \\int\\_{-N}^{N} e^x dx\\textstyle \\int_{-N}^{N} e^x dx\\iint\\limits_D dx\\,dy\\iint\\limits_D dx,dy\\iiint\\limits_E dx\\,dy\\,dz\\iiint\\limits_E dx,dy,dz\\iiiint\\limits_F dx\\,dy\\,dz\\,dt\\iiiint\\limits_F dx,dy,dz,dt\\int\\_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy\\int_{(x,y)\\in C} x^3, dx + 4y^2, dy\\oint\\_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy\\oint_{(x,y)\\in C} x^3, dx + 4y^2, dy\n\n\n                  \n                  Attention\n                  \n                \n\n积分符号可以使用\\int_{}^{}命令调用，如需双重积分符号只需将int替换成iint即可，以此类推，最高支持四重。曲线积分可使用\\oint命令调用，但曲面积分符号在 MathJax 环境中并不支持\\oiint的用法，但仍可通过\\unicode{}命令，即 Unicode 代码的方式进行调用（前提是您需要在设置中打开 Unicode 扩展），具体使用方法如下：\n\\unicode{8751} \\unicode{x222F}_C %曲面积分符号的Unicode码十进制为8751,十六进制为x222F(注意x标识符)\n\n\n\n                  \n                  Example\n                  \n                \n\n\\unicode{8751} \\unicode{x222F}_C\n\n\n\\unicode{8752} \\unicode{x2230}_C %三维曲面积分符号的Unicode码十进制为8752,十六进制为x2230\n\n\n\n                  \n                  Example\n                  \n                \n\n\\unicode{8752} \\unicode{x2230}_C\n\n\n其他积分符号：\n\\unicode{8753} \\unicode{x2231}_c\n         \\unicode{8754} \\unicode{x2232}_c\n         \\unicode{8755} \\unicode{x2233}_c\n\n\n\n                  \n                  Example\n                  \n                \n\n\\unicode{8753} \\unicode{x2231}_c\n         \\unicode{8754} \\unicode{x2232}_c\n         \\unicode{8755} \\unicode{x2233}_c\n\n\n\n\n1.2.9 其他大型运算 Large operators\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类别样式LaTeX求和 Summation\\sum_{a}^{b}\\sum_{a}^{b}求和 Summation\\textstyle \\sum_{a}^{b}\\textstyle \\sum_{a}^{b}连乘积 Product\\prod_{a}^{b}\\prod_{a}^{b}连乘积 Product\\textstyle \\prod_{a}^{b}\\textstyle \\prod_{a}^{b}余积 Coproduct\\coprod_{a}^{b}\\coprod_{a}^{b}余积 Coproduct\\textstyle \\coprod_{a}^{b}\\textstyle \\coprod_{a}^{b}并集 Union\\bigcup_{a}^{b}\\bigcup_{a}^{b}并集 Union\\textstyle \\bigcup_{a}^{b}\\textstyle \\bigcup_{a}^{b}交集 Intersection\\bigcap_{a}^{b}\\bigcap_{a}^{b}交集 Intersection\\textstyle \\bigcap_{a}^{b}\\textstyle \\bigcap_{a}^{b}析取 Disjunction\\bigvee_{a}^{b}\\bigvee_{a}^{b}析取 Disjunction\\textstyle \\bigvee_{a}^{b}\\textstyle \\bigvee_{a}^{b}合取 Conjunction\\bigwedge_{a}^{b}\\bigwedge_{a}^{b}合取 Conjunction\\textstyle \\bigwedge_{a}^{b}\\textstyle \\bigwedge_{a}^{b}\n1.3 上下标 Sub &amp; Super\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型样式代码上标 Superscripta^2, a^{x+3}a^2, a^{x+3}下标 Subscripta_2a_2组合 Grouping10^{30} a^{2+2}10^{30} a^{2+2}a_{i,j} b_{f&#039;}a_{i,j} b_{f&#039;}上下标混合 Combining sub &amp; superx_2^3x_2^3{x_2}^3{x_2}^3上标的上标 Super super10^{10^{8}}10^{10^{8}}混合标识 Preceding and/or additional sub &amp; super\\sideset{_1^2}{_3^4}X_a^b\\sideset{_1^2}{_3^4}X_a^b{}_1^2!\\Omega_3^4{}_1^2!\\Omega_3^4顶标底标 Stacking\\overset{\\alpha}{\\omega}\\overset{\\alpha}{\\omega}\\underset{\\alpha}{\\omega}\\underset{\\alpha}{\\omega}\\overset{\\alpha}{\\underset{\\gamma}{\\omega}}\\overset{\\alpha}{\\underset{\\gamma}{\\omega}}\\stackrel{\\alpha}{\\omega}\\stackrel{\\alpha}{\\omega}导数 Derivativesx&#039;, y&#039;&#039;, f&#039;, f&#039;&#039;x’, y”, f’, f”x^\\prime, y^{\\prime\\prime}x^\\prime, y^{\\prime\\prime}导数 Derivative dots\\dot{x}, \\ddot{x}\\dot{x}, \\ddot{x}下划线、上划线与向量 Underlines, overlines, vectors\\hat a\\bar b\\vec c\\hat a\\bar b\\vec c\\overrightarrow{a b}\\overleftarrow{c d}\\widehat{d e f}\\overrightarrow{a b}\\overleftarrow{c d}\\widehat{d e f}\\overline{g h i}\\underline{j k l}\\overline{g h i}\\underline{j k l}弧度 Arc (workaround)\\overset{\\frown}{AB}\\overset{\\frown}{AB}箭头 ArrowsA \\xleftarrow{n+\\mu-1} B \\xrightarrow[T]{n\\pm i-1} CA \\xleftarrow{n+\\mu-1} B \\xrightarrow[T]{n\\pm i-1} C大括号 Overbraces\\overbrace{ 1+2+\\cdots+100 }^{5050}\\overbrace{ 1+2+\\cdots+100 }^{5050}底部大括号 Underbraces\\underbrace{ a+b+\\cdots+z }\\_{26}\\underbrace{ a+b+\\cdots+z }_{26}求和运算 Sum\\sum_{k=1}^N k^2\\sum_{k=1}^N k^2文本模式下的求和运算 Sum (force \\textstyle)\\textstyle \\sum_{k=1}^N k^2\\textstyle \\sum_{k=1}^N k^2分式中的求和运算 Sum in a fraction (default \\textstyle)\\frac{\\sum_{k=1}^N k^2}{a}\\frac{\\sum_{k=1}^N k^2}{a}分式中的求和运算 Sum in a fraction (force \\displaystyle)\\frac{\\displaystyle \\sum_{k=1}^N k^2}{a}\\frac{\\displaystyle \\sum_{k=1}^N k^2}{a}分式中的求和运算 Sum in a fraction (alternative limits style)\\frac{\\sum\\limits^{^N}_{k=1} k^2}{a}\\frac{\\sum\\limits^{^N}_{k=1} k^2}{a}乘积运算 Product\\prod_{i=1}^N x_i\\prod_{i=1}^N x_i乘积运算 Product (force \\textstyle)\\textstyle \\prod_{i=1}^N x_i\\textstyle \\prod_{i=1}^N x_i副乘运算 Coproduct\\coprod_{i=1}^N x_i\\coprod_{i=1}^N x_i副乘运算 Coproduct (force \\textstyle)\\textstyle \\coprod_{i=1}^N x_i\\textstyle \\coprod_{i=1}^N x_i极限 Limit\\lim_{n \\to \\infty}x_n\\lim_{n \\to \\infty}x_n极限 Limit (force \\textstyle)\\textstyle \\lim_{n \\to \\infty}x_n\\textstyle \\lim_{n \\to \\infty}x_n积分 Integral\\int\\limits_{1}^{3}\\frac{e^3/x}{x^2}\\, dx\\int\\limits_{1}^{3}\\frac{e^3/x}{x^2}, dx积分 Integral (alternative limits style)\\int_{1}^{3}\\frac{e^3/x}{x^2}\\, dx\\int_{1}^{3}\\frac{e^3/x}{x^2}, dx积分 Integral (force \\textstyle)\\textstyle \\int\\limits_{-N}^{N} e^x dx\\textstyle \\int\\limits_{-N}^{N} e^x dx积分 Integral (force \\textstyle, alternative limits style)\\textstyle \\int_{-N}^{N} e^x dx\\textstyle \\int_{-N}^{N} e^x dx双重积分 Double integral\\iint\\limits_D dx\\,dy\\iint\\limits_D dx,dy三重积分 Triple integral\\iiint\\limits_E dx\\,dy\\,dz\\iiint\\limits_E dx,dy,dz四重积分 Quadruple integral\\iiiint\\limits_F dx\\,dy\\,dz\\,dt\\iiiint\\limits_F dx,dy,dz,dt路径积分 Line or path integral\\int_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy\\int_{(x,y)\\in C} x^3, dx + 4y^2, dy环路积分 Closed line or path integral\\oint_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy\\oint_{(x,y)\\in C} x^3, dx + 4y^2, dy交集 Intersections\\bigcap_{i=1}^n E_i\\bigcap_{i=1}^n E_i并集 Unions\\bigcup_{i=1}^n E_i\\bigcup_{i=1}^n E_i\n1.4 矩阵与多行列式 Matrices &amp; Multilines\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型样式LaTeX二项式系数 Binomial coefficients\\binom{n}{k}\\binom{n}{k}小型二项式系数 Small binomial coefficients (force \\textstyle)\\tbinom{n}{k}\\tbinom{n}{k}大型二项式系数 Large (normal) binomial coefficients (force \\displaystyle)\\dbinom{n}{k}\\dbinom{n}{k}矩阵 Matrices\\begin{matrix} x &amp; y \\\\ z &amp; v \\end{matrix}\\begin{matrix} x &amp; y \\\\ z &amp; v \\end{matrix}\\begin{vmatrix} x &amp; y \\\\ z &amp; v \\end{vmatrix}\\begin{vmatrix} x &amp; y \\\\ z &amp; v \\end{vmatrix}\\begin{Vmatrix} x &amp; y \\\\ z &amp; v \\end{Vmatrix}\\begin{Vmatrix} x &amp; y \\\\ z &amp; v \\end{Vmatrix}\\begin{bmatrix} 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; 0 \\end{bmatrix}\\begin{bmatrix} 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\ 0 &amp; \\cdots &amp; 0 \\end{bmatrix}\\begin{Bmatrix} x &amp; y \\\\ z &amp; v \\end{Bmatrix}\\begin{Bmatrix} x &amp; y \\\\ z &amp; v \\end{Bmatrix}\\begin{pmatrix} x &amp; y \\\\ z &amp; v \\end{pmatrix}\\begin{pmatrix} x &amp; y \\\\ z &amp; v \\end{pmatrix}\\bigl( \\begin{smallmatrix} a&amp;b\\\\ c&amp;d \\end{smallmatrix} \\bigr)\\bigl( \\begin{smallmatrix} a&amp;b\\\\ c&amp;d \\end{smallmatrix} \\bigr)条件定义 Case distinctionsf(n) = \\begin{cases} n/2, &amp; \\text{if }n\\text{ is even} \\\\ 3n+1, &amp; \\text{if }n\\text{ is odd} \\end{cases}f(n) = \\begin{cases} n/2, &amp; \\text{if }n\\text{ is even} \\\\ 3n+1, &amp; \\text{if }n\\text{ is odd} \\end{cases}多行等式 Multiline equations\\begin{align} f(x) &amp; = (a+b)^2\\\\ &amp; = a^2+2ab+b^2 \\end{align}\\begin{align} f(x) &amp; = (a+b)^2\\\\ &amp; = a^2+2ab+b^2 \\end{align}\\begin{alignat}{2} f(x) &amp; = (a-b)^2 \\\\ &amp; = a^2-2ab+b^2 \\end{alignat}\\begin{alignat}{2} f(x) &amp; = (a-b)^2 \\\\ &amp; = a^2-2ab+b^2 \\end{alignat}\\begin{array}{lcl} z &amp; = &amp; a \\\\ f(x,y,z) &amp; = &amp; x + y + z \\end{array}\\begin{array}{lcl} z &amp; = &amp; a \\\\ f(x,y,z) &amp; = &amp; x + y + z \\end{array}\\begin{array}{lcr} z &amp; = &amp; a \\\\ f(x,y,z) &amp; = &amp; x + y + z \\end{array}\\begin{array}{lcr} z &amp; = &amp; a \\\\ f(x,y,z) &amp; = &amp; x + y + z \\end{array}方程组 Simultaneous equations\\begin{cases} 3x + 5y + z \\\\ 7x - 2y + 4z \\\\ -6x + 3y + 2z \\end{cases}\\begin{cases} 3x + 5y + z \\ 7x - 2y + 4z \\\\ -6x + 3y + 2z \\end{cases}数组 Arrays\\begin{array}{ | c | c | c | } a &amp; b &amp; S \\\\ \\hline 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 1 \\\\ 1 &amp; 1 &amp; 0 \\end{array}\n1.5 括号 Brackets\n常用的括号符号例如( )[ ]{ }……这些也可以在输入环境中直接使用：\n2(x+y)=z\n\n\n\n                  \n                  Example\n                  \n                \n\n2(x+y)=z\n\n\n但如果是在较大的表达式中这些符号就显得不合适了\n( \\frac{\\pi}{2} )^n\n\n\n\n                  \n                  Example\n                  \n                \n\n( \\frac{\\pi}{2} )^n\n\n\n正确用法应配合\\left和\\right命令使用。\n\\left ( \\frac{\\pi}{2} \\right )^n\n\n\n\n                  \n                  Example\n                  \n                \n\n\\left ( \\frac{\\pi}{2} \\right )^n\n\n\n具体可参考下表。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型样式LaTeX圆括号、小括号 Parentheses\\left ( \\frac{a}{b} \\right )\\left ( \\frac{a}{b} \\right )方括号、中括号 Brackets\\left [ \\frac{a}{b} \\right ] \\quad \\left \\lbrack \\frac{a}{b} \\right \\rbrack\\left [ \\frac{a}{b} \\right ] \\quad \\left \\lbrack \\frac{a}{b} \\right \\rbrack花括号、大括号 Braces\\left { \\frac{a}{b} \\right } \\quad \\left \\lbrace \\frac{a}{b} \\right \\rbrace角括号 Angle brackets\\left \\langle \\frac{a}{b} \\right \\rangle\\left \\langle \\frac{a}{b} \\right \\rangle单竖线和双竖线 Bars and double bars\\left | \\frac{a}{b} \\right \\vert \\quad \\left \\Vert \\frac{c}{d} \\right |取整函数与取顶函数 Floor and ceiling functions:\\left \\lfloor \\frac{a}{b} \\right \\rfloor \\quad \\left \\lceil \\frac{c}{d} \\right \\rceil\\left \\lfloor \\frac{a}{b} \\right \\rfloor \\quad \\left \\lceil \\frac{c}{d} \\right \\rceil斜线与反斜线 Slashes and backslashes\\left / \\frac{a}{b} \\right \\backslash\\left / \\frac{a}{b} \\right \\backslash上下箭头 Up, down, and up-down arrows\\left \\uparrow \\frac{a}{b} \\right \\downarrow \\quad &lt;br&gt;\\left \\Uparrow \\frac{a}{b} \\right \\Downarrow \\quad &lt;br&gt;\\left \\updownarrow \\frac{a}{b} \\right \\Updownarrow\\left \\uparrow \\frac{a}{b} \\right \\downarrow \\quad \\left \\Uparrow \\frac{a}{b} \\right \\Downarrow \\quad \\left \\updownarrow \\frac{a}{b} \\right \\Updownarrow混合括号 Delimiters can be mixed,as long as \\left and \\right match\\left [ 0,1 \\right ) \\left \\langle \\psi \\right |如果您不希望某一侧括号显示，可以使用\\left. 和 \\right.（带有英文句号） Use \\left. and \\right. if you do not want a delimiter to appear\\left . \\frac{A}{B} \\right } \\to X括号的大小 Size of the delimiters (add “l” or “r” to indicate the side for proper spacing)(((((…]]]]]( \\bigl( \\Bigl( \\biggl( \\Biggl( \\dots \\Biggr] \\biggr] \\Bigr] \\bigr] ]{{{{{…⟩⟩⟩⟩⟩{ \\bigl{ \\Bigl{ \\biggl{ \\Biggl{ \\dots \\Biggr\\rangle \\biggr\\rangle \\Bigr\\rangle \\bigr\\rangle \\rangle∥‖‖‖‖…|| \\big| \\Big| \\bigg| \\Bigg| \\dots \\Bigg | \\bigg | \\Big | \\big |⌊⌊⌊⌊⌊…⌉⌉⌉⌉⌉\\lfloor \\bigl\\lfloor \\Bigl\\lfloor \\biggl\\lfloor \\Biggl\\lfloor \\dots \\Biggr\\rceil \\biggr\\rceil \\Bigr\\rceil \\bigr\\rceil \\rceil↑↑↑↑↑⋯⇓⇓⇓⇓⇓\\uparrow \\big\\uparrow \\Big\\uparrow \\bigg\\uparrow \\Bigg\\uparrow \\dots \\Bigg\\Downarrow \\bigg\\Downarrow \\Big\\Downarrow \\big\\Downarrow \\Downarrow↕↕↕↕↕⋯⇕⇕⇕⇕⇕\\updownarrow \\big\\updownarrow \\Big\\updownarrow \\bigg\\updownarrow \\Bigg\\updownarrow \\dots \\Bigg\\Updownarrow \\bigg\\Updownarrow \\Big\\Updownarrow \\big\\Updownarrow \\Updownarrow/////…\\\\∖/ \\big/ \\Big/ \\bigg/ \\Bigg/ \\dots \\Bigg\\backslash \\bigg\\backslash \\Big\\backslash \\big\\backslash \\backslash\n1.6 空格与换行 Spacing &amp; Line breaking\n1.6.1 空格 Spacing\nMathJax 能够自动处理大多数空格间距的大小，但如果您需要自己控制，可参考下表。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号样式LaTeX中文说明英文说明1a \\qquad ba \\qquad b双空格2a \\quad ba \\quad b单空格3a\\ ba\\ b字符空格4a \\text{ } ba \\text{ } b文本模式中的字符空格5a\\;ba;b大空格6a\\,ba,b小空格7abab极小空格(用于乘因子)8a ba b极小空格(用于区分其它语法)9\\mathit{ab}\\mathit{ab}没有空格(用于多字母变量)10a!ba!b负空格\n1.6.2 换行 Line breaking\n在 MathJax3.0 中取消了使用\\\\进行强制换行的功能，因此本页面也采取同样的逻辑，默认为单行公式环境。\\\\强制换行命令只在支持多行编辑的数学环境中才起作用，如eqnarray环境、align环境、array环境、matrix环境等等。如您需要显示多行公式，建议在此类环境中输入公式，具体用法参见章节2.10。\n或者您可直接在\\displaylines{}显示行命令中使用\\\\强制换行命令，例如：\n\\displaylines{y=1729x \\\\ y=1729-x}\n\n\n\n                  \n                  Example\n                  \n                \n\n\\displaylines{y=1729x \\\\ y=1729-x}\n\n\n1.7 颜色 Colors\n1.7.1 字体颜色 Font colors\n在公式中可以使用\\color{options}{math}来调用颜色命令，第一个参数为颜色，第二个参数为公式或文本内容。例如:\n{\\color{Blue}x^2}+{\\color{Orange}2x}-{\\color{LimeGreen}1}\n\n\n\n                  \n                  Example\n                  \n                \n\n{\\color{Blue}x^2}+{\\color{Orange}2x}-{\\color{LimeGreen}1}\n\n\nx_{1,2}=\\frac{{\\color{Blue}-b}\\pm\\sqrt{\\color{Red}b^2-4ac}}{\\color{Green}2a }\n\n\n\n                  \n                  Example\n                  \n                \n\nx_{1,2}=\\frac{{\\color{Blue}-b}\\pm\\sqrt{\\color{Red}b^2-4ac}}{\\color{Green}2a }\n\n\n\n\n                  \n                  Attention\n                  \n                \n\n使用\\color命令时，请将需要设置颜色的部分用{ }整体扩住，以表明\\color函数作用范围。\n\n\n1.7.2 背景颜色 Background color\n在文本环境中可以使用\\colorbox{options}{text}来调用背景颜色命令，第一个参数为颜色，第二个颜色为文本内容。例如：\n\\colorbox{yellow}{This is text}\n\n\n\n                  \n                  Example\n                  \n                \n\n\\colorbox{yellow}{This is text}\n\n\n\n\n                  \n                  Attention\n                  \n                \n\n若需要在数学环境中使用\\colorbox{}{}，请在第二个参数内加入$\\displaystyle + 公式$，例如：\n\\colorbox{yellow}{$\\displaystyle \\frac{a}{b}$}\n\n\\colorbox{yellow}{$\\displaystyle \\frac{a}{b}$}\n\n\n或者您可以使用  Bbox 扩展  来替换\\colorbox命令，详见下条 1.7.3。\n1.7.3 用 Bbox 扩展设置背景颜色 Setting background color with Bbox\nBbox 扩展是一款自定义宏包，如需使用请在公式页面右上角【设置】处勾选后使用。 具体用法如下：\n1.7.3.1 设置背景颜色 Setting Background color\n在公式中可以使用\\bbox[options]{math}来调用背景颜色命令，第一个参数为颜色或大小，需注意用[ ]包围，第二个参数为公式。例如:\n\\bbox[red]{x+y}\n\n\n\n                  \n                  Example\n                  \n                \n\n\\bbox[red]{x+y}\n\n\n1.7.3.2 调整背景大小 Setting Background Size\n默认情况下，背景大小为作用范围的最大边界，如需扩大背景，可在第一个参数中加入大小信息，例如：\n\\bbox[2pt]{x+y} %设置透明背景，并增加2pt额外距离\n\n\n\n                  \n                  Example\n                  \n                \n\n\\bbox[2pt]{x+y}\n\n\n\\bbox[red,5pt]{x+y} %设置红色背景，并增加5pt额外距离\n\n\n\n                  \n                  Example\n                  \n                \n\n\\bbox[red,5pt]{x+y}\n\n\n1.7.4 默认支持颜色 Colors supported\n支持的颜色\n1.7.5 使用 RGB 颜色 Use RGB color\n如需在\\color命令中使用自选 RGB 颜色，可使用{\\color[RGB]{0,0,0} }命令，例如：\n{\\color[RGB]{0,200,0} e^{i \\pi} + 1 = 0}\n\n\n\n                  \n                  Example\n                  \n                \n\n{\\color[RGB]{0,200,0} e^{i \\pi} + 1 = 0}\n\n\n1.7.6 自定义颜色 Custom colors\n可使用\\definecolor命令进行自定义颜色，例如：\n\\definecolor{mygreen}{RGB}{0,200,0} {\\color{mygreen}e^{i \\pi} + 1 = 0 }\n\n\n\n                  \n                  Example\n                  \n                \n\n\\definecolor{mygreen}{RGB}{0,200,0} {\\color{mygreen}e^{i \\pi} + 1 = 0 }\n\n\n1.8 字体字号 Fonts &amp; Size\n1.8.1 字体 Fonts\n字体\n1.8.2 字号 Size\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n样式LaTeX{\\tiny abc 巨小 tiny}{\\tiny abc 巨小 tiny}{\\scriptsize abc 超小 scriptsize}{\\scriptsize abc 超小 scriptsize}{\\small abc 小 small}{\\small abc 小 small}{\\normalsize abc 正常 normal}{\\normalsize abc 正常 normal}{\\large abc 大 large}{\\large abc 大 large}{\\Large abc 超大 Large}{\\Large abc 超大 Large}{\\LARGE abc 特大 LARGE}{\\LARGE abc 特大 LARGE}{\\huge abc 巨大 huge}{\\huge abc 巨大 huge}{\\Huge abc 巨无霸 Huge}{\\Huge abc 巨无霸 Huge}\n1.9 方程式编号 Equation numbering\n需要开启 AMS 宏包的方式获得方程自动编号，AMS 拓展包的具体开启方式请参考2.11.4。\n默认自动编号只在部分环境中起作用，如{equation}、{eqnarray}等，例如：\n在 AMS 包开启状态下，会在公式后进行自动编号：\n\\begin{eqnarray}\nE = mc^2 \\\\\ne^{i\\pi}+1=0\n\\end{eqnarray}\n\n如您在开启了 AMS 包状态下，整个公式均不希望出现编号，可使用{equation*}、或者{eqnarray*}环境；或单个方程不希望出现编号，可以在指定方程后面添加\\nonumber命令，如：\n\\begin{eqnarray*}\nE = mc^2 \\\\\ne^{i\\pi}+1=0\n\\end{eqnarray*}\n\n\\begin{eqnarray}\nE = mc^2 \\\\\ne^{i\\pi}+1=0 \\nonumber\n\\end{eqnarray}\n\n如您在开启了 AMS 包状态下，个别公式不希望出现编号，或者个别公式希望出现特有编号，可在公式后面使用\\tag{}或者\\notag命令，如：\n\\begin{eqnarray}\nE = mc^2 \\notag\\\\\ne^{i\\pi}+1=0 \\tag{b}\n\\end{eqnarray}\n\n1.10 LaTeX 环境 LaTeX environments\n环境通常是对代码段的整体描述，用于表达此段代码的角色，如，是矩阵？单行公式？多行公式？还是对齐公式等（本页面不支持文档环境），不同的环境起到的作用不同。以\\begin{environments}开始，\\end{environments}结束。如最常用的矩阵命令，也是环境的一种，用法如下：\n\\begin{bmatrix}\n1 &amp; 0 \\\\\n0 &amp; 1\n\\end{bmatrix}\n\n具体矩阵用法可参考章节2.4，下面给出几种其它常用环境的具体用法：\n1.10.1 equation 环境\n\\begin{equation}是单行公式环境，这意味着在此环境中只可以输入单行公式，同时\\\\等强制换行命令失效。如需对单行长公式进行强制换行，可使用\\begin{split}环境进行嵌套，并用&amp;字符表示对齐位置，如：\n\\begin{equation}\n\\begin{split}\ne ^ { x } = &amp; 1 + \\frac { x } { 1 ! } + \\frac { x ^ { 2 } } { 2 ! } + \\frac { x ^ { 3 } } { 3 ! } + \\cdots\n\\\\\n&amp; - \\infty &lt; x &lt; \\infty\n\\end{split}\n\\end{equation}\n\n\\begin{equation}环境在排版时可能会出现重影错误，可通过对整体添加{ }解决，如{\\begin{equation}……\\end{equation}}.\n1.10.2 eqnarray 环境\n\\begin{eqnarray}是多行公式环境，环境内的所有公式默认右对齐，由 LaTeX 内核提供。\n1.10.3 align 环境\n\\begin{align}是多行公式环境，环境内的所有公式默认右对齐，由 amsmath 提供，排版较为灵活，如需表示多行公式推荐使用此环境。\n\\begin{align}\ny = x \\\\\ny = 3x^2 + 5x + 2\n\\end{align}\n\n可使用&amp;字符调整对齐位置。\n\\begin{align}\ny &amp; = x \\\\\ny &amp; = 3x^2 + 5x + 2\n\\end{align}\n\n1.10.4 array 环境\n\\begin{array}{}是数组环境，需手动输入对齐参数：\n\\begin{array}{|c|l|r|}\na &amp; b &amp; S \\\\\n\\hline\n0 &amp; 0 &amp; 1 \\\\\n0 &amp; 1 &amp; 1 \\\\\n1 &amp; 0 &amp; 1 \\\\\n1 &amp; 1 &amp; 0 \\\\\n\\end{array}\n\n对齐参数使用c l r分别表示居中、居左和居右，如需竖线边框可直接在对齐参数区域输入|即可，如需横线边框可使用\\hline命令。\n更多环境使用可参考章节2.4。\n2 参考文献 Reference\n\nLaTeX 公式编辑器\nMathJax Documentation\nDisplaying a formula\nmathjax/MathJax: Beautiful math in all browsers - GitHub\nmhchem for MathJax\n"},"Quick-References/Markdown-Syntax":{"slug":"Quick-References/Markdown-Syntax","filePath":"Quick References/Markdown Syntax.md","title":"Markdown Syntax","links":[],"tags":["Reference","Programming/Markdown"],"content":"基本语法\n标题 (Heading)\n# h1\n\n## h2\n\n### h3\n\nhead level 1\n============\n\nhead level 2\n------------\n\n加粗 (Bold)\n**bold text**\n__bold text__\n\n斜体 (Italic)\n*italicized text*\n_italicized text_\n\n引用 (Blockquote)\n&gt; blockquote\n\n有序列表 (Ordered List)\n1. First item\n    1. Nested first item\n    2. Nested second item\n2. Second item\n\n无序列表 (Unordered List)\n- First item\n- Second item\n- Third item\n\n* First item\n* Second item\n* Third item\n\n+ First item\n+ Second item\n+ Third item\n\n嵌入代码 (Inline Code)\n`code`\n\n水平分割线 (Horizontal Rule)\n---\n\n链接 (Link)\n[title](www.example.com)\n[in document link](#heading)\n\n&lt;raw.http.link&gt;\n&lt;raw@mail.link&gt;\n\n[reference style link][1]\n[1]: &lt;not.supported.in.all.editor&gt;\n\n图片 (Image)\n![alt text](image.jpg)\n![alt text](image.jpg &quot;optional title&quot;)\n\n增强的语法\n\n\n                  \n                  Tips\n                  \n                \n\n增强的语法并不是所有的 markdown render 都支持，使用时需要注意。\n\n\n表格 (Table)\n| Syntax    | Description     |\n| --------- | --------------- |\n| Header    | Title           |\n| Paragraph | Text &lt;br&gt; Text1 |\n\nalign text in table\n\n| Syntax    | Description |   Test Text |\n| :-------- | :---------: | ----------: |\n| Header    |    Title    | Here&#039;s this |\n| Paragraph |    Text     |    And more |\n\n代码块 (Code Block)\n```json\n{\n  &quot;firstName&quot;: &quot;John&quot;,\n  &quot;lastName&quot;: &quot;Smith&quot;,\n  &quot;age&quot;: 25\n}\n```\n脚注 (Footnote)\nHere&#039;s a sentence with a footnote. [^1]\n\n[^1]: This is the footnote.\n\n标题ID (Heading ID)\n### My Great Heading {#custom-id}\n\n定义列表 (Definition Lists)\nFirst Term\n: This is the definition of the first term.\n\nSecond Term\n: This is one definition of the second term.\n: This is another definition of the second term.\n\n删除线 (Strikethrough)\n~~The world is flat.~~\n\n任务清单 (Task List)\n- [x] Write the press release\n- [ ] Update the website\n- [ ] Contact the media\n\n表情 (Emoji)\nThat is so funny! :joy:\n\n高亮 (Highlight)\nI need to highlight these ==very important words==.\n\n上下标 (Superscript/Subscript)\nX^2^\nH~2~O\n\n对于不支持的 markdown 程序，可以直接使用内嵌 html 的方式实现。\nX&lt;sup&gt;2&lt;/sup&gt;\nH&lt;sub&gt;2&lt;/sub&gt;O\n"},"Quick-References/Obsidian-Formatting-Syntax":{"slug":"Quick-References/Obsidian-Formatting-Syntax","filePath":"Quick References/Obsidian Formatting Syntax.md","title":"Obsidian Formatting Syntax","links":["Quick-References/Markdown-Syntax","Quick-References/LaTeX-Quick-Reference"],"tags":["Reference","Software/Obsidian","Programming/Markdown"],"content":"基于 markdown 的语法\nObsidian 本身的 notes 都是 markdown 文件，所以支持大部分的 Markdown Syntax，对一些语法有所增加，有一些语意有稍微的改变。主要的不同有下面这些。\nMarkdown Link 语法的增强\n首先对 Markdown Syntax ❯ 链接 (Link) 增加了一种特殊种类，[[link]] 表示内部引用。当然也可以使用原本的 markdown 语法 []() 来表示。\n其次类似 Markdown Syntax ❯ 图片 (Image) 的语法，可以使用 ![[note-id]] 的方法在当前笔记中嵌入其它笔记的内容。\n特殊的引用标注语法 (callouts)\nCallouts 是对 Markdown Syntax ❯ 引用 (Blockquote) 的增强，可以生成在笔记中生成特定样式的插注，比如 info 插注。\n&gt; [!info]\n&gt; \n&gt; Here&#039;s a callout block.\n&gt; It supports **Markdown**, [[202404131056-markdown-syntax|Markdown Syntax]], and other.\n\n\n                  \n                  Info\n                  \n                \n\nHere’s a callout block.\nIt supports Markdown, Markdown Syntax, and other.\n\n\nCallouts 也支持折叠和嵌套。\n&gt; [!faq]- Are callouts foldable? &gt;\n&gt; \n&gt; Yes! In a foldable callout, the contents are hidden when the callout is collapsed.\n \n&gt; [!question] Can callouts be nested?\n&gt; \n&gt;\n&gt; &gt; [!todo] Yes!, they can.\n&gt; &gt;\n&gt; &gt; &gt; [!example] You can even use multiple layers of nesting.\n\n\n                  \n                  Are callouts foldable? \n                  \n                \n\nYes! In a foldable callout, the contents are hidden when the callout is collapsed.\n\n\n\n\n                  \n                  Can callouts be nested? \n                  \n                \n\n\n\n                  \n                  Yes!, they can. \n                  \n                \n\n\n\n                  \n                  You can even use multiple layers of nesting. \n                  \n                \n\n\n\n\n\n\n\n                  \n                  Callouts 支持的种类。 \n                  \n                \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntypealiasesabstractsummary, tldrinfotodotiphint, importantquestionhelp, faqsuccesscheck, donewarningcaution, attentionfailurefail, missingdangererrorbugexamplequotecite\n\n\n上下角标的实现\nObsidian 并不支持 Subscript)。如果需要有两个办法：\n\n数学公式中的脚标可以直接是用 数学符号 的方法，直接使用 LaTeX 实现。\n使用内嵌 html 的方法实现。\n\nX&lt;sup&gt;2&lt;/sup&gt;\nH&lt;sub&gt;2&lt;/sub&gt;O\n\n\n\n                  \n                  Example\n                  \n                \n\nX2\nH2O\n\n\nmarkdown 之外的增强语法\n除了对于 markdown 的支持和增强之外，Obsidian 还通过使用 Mermaid 和 MathJax 增加了对图表和数学符号的支持。\n图表\n使用 markdown codeblock 的语法来添加 mermaid 图表。\n```mermaid\nsequenceDiagram\n\tAlice-&gt;&gt;+John: Hello John, how are you?\n\tAlice-&gt;&gt;+John: John, can you hear me?\n\tJohn--&gt;&gt;-Alice: Hi Alice, I can hear you!\n\tJohn--&gt;&gt;-Alice: I feel great!\n```\n\n\n                  \n                  Example\n                  \n                \n\nsequenceDiagram\n\tAlice-&gt;&gt;+John: Hello John, how are you?\n\tAlice-&gt;&gt;+John: John, can you hear me?\n\tJohn--&gt;&gt;-Alice: Hi Alice, I can hear you!\n\tJohn--&gt;&gt;-Alice: I feel great!\n\n\n\n```mermaid\n\tgraph TD\n\tBiology --&gt; Chemistry\n```\n\n\n                  \n                  Example\n                  \n                \n\ngraph TD\nBiology --&gt; Chemistry\n\n\n\n通过图中节点添加 class 的方式可以在图中增加 obsidian 的内部连接。\n\n\n                  \n                  Example\n                  \n                \n\ngraph TD\nTypeclass --&gt; Monad\nclass Typeclass,Monad internal-link;\n\n\n\n更多的语法的图表类型可以参照 Mermaid 的文档。\n数学符号\nObsidian 支持使用 MathJax 显示使用 LaTeX 编写的数学符号和公式，有两种公式显示方式，块状的公式与行内公式，分别使用 $$ 和 $ 来实现。\n使用 $$ 可以添加块状的数学公式。\n$$\n\\begin{vmatrix}a &amp; b\\\\\nc &amp; d\n\\end{vmatrix}=ad-bc\n$$\n\n\n                  \n                  Example\n                  \n                \n\n\\begin{vmatrix}a &amp; b\\\\\nc &amp; d\n\\end{vmatrix}=ad-bc\n\n\n使用 $ 可添加行内的数学符号与公式。\nThis is an inline math expression $e^{2i\\pi} = 1$.\n\n\n\n                  \n                  Example\n                  \n                \n\nThis is an inline math expression e^{2i\\pi} = 1.\n\n\n更多的 LaTeX 语法可以查阅在线文档 MathJax Quick Reference。或者 LaTeX Quick Reference。\n注释\nObsidian 中还支持使用 `inline This is a block comment. Block comments can span multiple lines.\n这段文字在预览模式中不可见。\n%%"},"Quick-References/Pacman-常用命令":{"slug":"Quick-References/Pacman-常用命令","filePath":"Quick References/Pacman 常用命令.md","title":"Pacman 常用命令","links":[],"tags":["Reference","Linux/Command"],"content":"常用命令\n查找软件包：\n$ pacman -Ss keywords\n查询特定软件包的详细信息：\n$ pacman -Si pkgName1\n安装软件包（或者叫同步软件包更合适）：\n$ pacman -S pkgName1 pkgName2\n删除软件包：\n$ pacman -R pkgName1 pkgName2\n删除软件包和其不再被其它软件包依赖的依赖软件包：\n$ pacman -Rs pkgName1\n删除软件包时，pacman 会将重要的配置文件扩展名改为 .pacsave 用以备份，使用 -n 参数可以取消备份操作：\n$ pacman -Rn pkgName1\n升级所有软件包：\n$ pacman -Syu\n同步软件仓库的数据库而不升级：\n$ pacman -Sy\n列出所有已安装的软件包：\n$ pacman -Q\n搜索已安装的软件包：\n$ pacman -Qs keyword1 keyword2\n查询已安装软件包的详细信息：\n$ pacman -Qi pkgName1\n列出所有不再需要的依赖：\n$ pacman -Qdt\n清除缓存：\n$ pacman -Sc\npacman 的软件包数据库\npacman 使用中会遇到三个不同的软件包数据库\n\n本地已安装的软件包数据库，使用 -Q 参数来指定；\n远程的软件包数据库，使用 -S 参数来指定；\n软件包文件的数据库，使用 -F 参数来指定。\n\n明白了这一点，命令中该使用哪个参数就比较清楚了。如果忘记了也可以通过帮助命令快速查询：\n$ pacman -S --help\n$ pacman -Q --help\n$ pacman -F --help\nReferences\n\npacman usage\npacman command rosetta\n"},"Quick-References/ViFM-Cheatsheet":{"slug":"Quick-References/ViFM-Cheatsheet","filePath":"Quick References/ViFM Cheatsheet.md","title":"ViFM Cheatsheet","links":["2023/Terminal-File-Manager"],"tags":["Reference","Software"],"content":"Vifm 是一个终端文件管理软件，其按键基本可以和 vim 是使用逻辑相对应。\n"},"index":{"slug":"index","filePath":"index.md","title":"Yi's Cyber Records","links":["2024/使用自引用与闭包实现优美的多参数配置","Blogs/Moral-Lessons-from-GNU-Emacs---Protesilaos","Blogs/Windows-开机端口被随机占用的原因与修复","2023/Terminal-File-Manager","Blogs/VIM实用技巧","2023/用-Scheme-简单解释停机问题","Blogs/UTXO的委托代理问题","Blogs/让-Emacs-的-paredit-的编辑快捷键更符合直觉","Blogs/Emacs-中英文的对齐设置","Blogs/解决-org-mode-中-LaTeX-数学公式中的中文渲染问题","Blogs/经济学综合笔记","Blogs/使用-orgmode-+-github-pages-搭建博客","Quick-References/LaTeX-Quick-Reference","Quick-References/Markdown-Syntax","Quick-References/Obsidian-Formatting-Syntax","Quick-References/Editor-Config-File","Quick-References/Pacman-常用命令","Quick-References/ViFM-Cheatsheet","Quick-References/ACM-Code-Of-Ethics"],"tags":["Homepage"],"content":"你好，陌生人：\n欢迎来到我的赛博花园！\n希望你是被搜索引擎检索带到了这里，因为那样意味着这里的某些信息可能对你有所帮助。如果真的能够帮助到你，我会十分高兴。\n如果不是，那不管目的是什么，希望你也能找到你需要的信息。\n这个空间中的文章是我本地的个人笔记的同步，当然并不是全部的笔记都会同步，目前只有少部分的文章同步，但我的目标是逐步的将更多的没有个人隐私的笔记同步到这里。\n如果你有任何问题或者建议，可以在此空间的 Github Repo 提 issue。或者向我发邮件。\n以上。\n文章\n\n在 Golang 中使用自引用与闭包实现优美的多参数配置\nMoral Lessons from GNU Emacs - Protesilaos\nWindows 开机端口被随机占用的原因与修复\n终端文件管理软件\nVim 实用技巧\n用 Scheme 简单解释停机问题\nUTXO的委托代理问题\n让 Emacs 的 paredit 的编辑快捷键更符合直觉\nEmacs 中英文的对齐设置\n解决 org-mode 中 LaTeX 数学公式中的中文渲染问题\n经济学综合笔记\n使用 orgmode + github pages 搭建博客\n\n迷你手册\n\nLaTex 语法速查\nMarkdown 语法\nObsidian 编辑语法速查\nEditor Config File\nPacman 常用命令\nViFM Cheatsheet\nACM Code Of Ethics\n\n联系信息\n\nGithub: github.com/q3yi\nEmail: qing.yi[at]outlook.com\n"}}